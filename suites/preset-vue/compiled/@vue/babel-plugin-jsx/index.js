(function () {
  var e = {
    831: function (e, t, r) {
      'use strict';
      var s = Object.create;
      var i = Object.defineProperty;
      var n = Object.defineProperties;
      var a = Object.getOwnPropertyDescriptor;
      var o = Object.getOwnPropertyDescriptors;
      var l = Object.getOwnPropertyNames;
      var c = Object.getOwnPropertySymbols;
      var p = Object.getPrototypeOf;
      var u = Object.prototype.hasOwnProperty;
      var d = Object.prototype.propertyIsEnumerable;
      var __defNormalProp = (e, t, r) =>
        t in e
          ? i(e, t, {
              enumerable: true,
              configurable: true,
              writable: true,
              value: r,
            })
          : (e[t] = r);
      var __spreadValues = (e, t) => {
        for (var r in t || (t = {}))
          if (u.call(t, r)) __defNormalProp(e, r, t[r]);
        if (c)
          for (var r of c(t)) {
            if (d.call(t, r)) __defNormalProp(e, r, t[r]);
          }
        return e;
      };
      var __spreadProps = (e, t) => n(e, o(t));
      var __export = (e, t) => {
        for (var r in t) i(e, r, { get: t[r], enumerable: true });
      };
      var __copyProps = (e, t, r, s) => {
        if ((t && typeof t === 'object') || typeof t === 'function') {
          for (let n of l(t))
            if (!u.call(e, n) && n !== r)
              i(e, n, {
                get: () => t[n],
                enumerable: !(s = a(t, n)) || s.enumerable,
              });
        }
        return e;
      };
      var __toESM = (e, t, r) => (
        (r = e != null ? s(p(e)) : {}),
        __copyProps(
          t || !e || !e.__esModule
            ? i(r, 'default', { value: e, enumerable: true })
            : r,
          e,
        )
      );
      var __toCommonJS = (e) =>
        __copyProps(i({}, '__esModule', { value: true }), e);
      var f = {};
      __export(f, { default: () => src_default });
      e.exports = __toCommonJS(f);
      var h = __toESM(r(4739));
      var y = __toESM(r(8063));
      var m = __toESM(r(4435));
      var T = r(2408);
      var S = __toESM(r(4739));
      var x = r(2408);
      var b = __toESM(r(4739));
      var E = __toESM(r(5346));
      var P = __toESM(r(7860));
      var g = ((e) => {
        e[(e['STABLE'] = 1)] = 'STABLE';
        e[(e['DYNAMIC'] = 2)] = 'DYNAMIC';
        e[(e['FORWARDED'] = 3)] = 'FORWARDED';
        return e;
      })(g || {});
      var A = g;
      var v = 'Fragment';
      var I = 'KeepAlive';
      var createIdentifier = (e, t) => e.get(t)();
      var isDirective = (e) =>
        e.startsWith('v-') ||
        (e.startsWith('v') && e.length >= 2 && e[1] >= 'A' && e[1] <= 'Z');
      var shouldTransformedToSlots = (e) =>
        !(e.match(RegExp(`^_?${v}\\d*$`)) || e === I);
      var checkIsComponent = (e, t) => {
        var r, s;
        const i = e.get('name');
        if (i.isJSXMemberExpression()) {
          return shouldTransformedToSlots(i.node.property.name);
        }
        const n = i.node.name;
        return (
          !((s = (r = t.opts).isCustomElement) == null
            ? void 0
            : s.call(r, n)) &&
          shouldTransformedToSlots(n) &&
          !E.default.includes(n) &&
          !P.default.includes(n)
        );
      };
      var transformJSXMemberExpression = (e) => {
        const t = e.node.object;
        const r = e.node.property;
        const s = b.isJSXMemberExpression(t)
          ? transformJSXMemberExpression(e.get('object'))
          : b.isJSXIdentifier(t)
          ? b.identifier(t.name)
          : b.nullLiteral();
        const i = b.identifier(r.name);
        return b.memberExpression(s, i);
      };
      var getTag = (e, t) => {
        var r, s;
        const i = e.get('openingElement').get('name');
        if (i.isJSXIdentifier()) {
          const { name: n } = i.node;
          if (!E.default.includes(n) && !P.default.includes(n)) {
            return n === v
              ? createIdentifier(t, v)
              : e.scope.hasBinding(n)
              ? b.identifier(n)
              : (
                  (s = (r = t.opts).isCustomElement) == null
                    ? void 0
                    : s.call(r, n)
                )
              ? b.stringLiteral(n)
              : b.callExpression(createIdentifier(t, 'resolveComponent'), [
                  b.stringLiteral(n),
                ]);
          }
          return b.stringLiteral(n);
        }
        if (i.isJSXMemberExpression()) {
          return transformJSXMemberExpression(i);
        }
        throw new Error(`getTag: ${i.type} is not supported`);
      };
      var getJSXAttributeName = (e) => {
        const t = e.node.name;
        if (b.isJSXIdentifier(t)) {
          return t.name;
        }
        return `${t.namespace.name}:${t.name.name}`;
      };
      var transformJSXText = (e) => {
        const t = transformText(e.node.value);
        return t !== '' ? b.stringLiteral(t) : null;
      };
      var transformText = (e) => {
        const t = e.split(/\r\n|\n|\r/);
        let r = 0;
        for (let e = 0; e < t.length; e++) {
          if (t[e].match(/[^ \t]/)) {
            r = e;
          }
        }
        let s = '';
        for (let e = 0; e < t.length; e++) {
          const i = t[e];
          const n = e === 0;
          const a = e === t.length - 1;
          const o = e === r;
          let l = i.replace(/\t/g, ' ');
          if (!n) {
            l = l.replace(/^[ ]+/, '');
          }
          if (!a) {
            l = l.replace(/[ ]+$/, '');
          }
          if (l) {
            if (!o) {
              l += ' ';
            }
            s += l;
          }
        }
        return s;
      };
      var transformJSXExpressionContainer = (e) => e.get('expression').node;
      var transformJSXSpreadChild = (e) =>
        b.spreadElement(e.get('expression').node);
      var walksScope = (e, t, r) => {
        if (e.scope.hasBinding(t) && e.parentPath) {
          if (b.isJSXElement(e.parentPath.node)) {
            e.parentPath.setData('slotFlag', r);
          }
          walksScope(e.parentPath, t, r);
        }
      };
      var buildIIFE = (e, t) => {
        const { parentPath: r } = e;
        if (r.isAssignmentExpression()) {
          const { left: s } = r.node;
          if (b.isIdentifier(s)) {
            return t.map((t) => {
              if (b.isIdentifier(t) && t.name === s.name) {
                const s = e.scope.generateUidIdentifier(t.name);
                r.insertBefore(
                  b.variableDeclaration('const', [
                    b.variableDeclarator(
                      s,
                      b.callExpression(
                        b.functionExpression(
                          null,
                          [],
                          b.blockStatement([b.returnStatement(t)]),
                        ),
                        [],
                      ),
                    ),
                  ]),
                );
                return s;
              }
              return t;
            });
          }
        }
        return t;
      };
      var w = /^on[^a-z]/;
      var isOn = (e) => w.test(e);
      var mergeAsArray = (e, t) => {
        if (b.isArrayExpression(e.value)) {
          e.value.elements.push(t.value);
        } else {
          e.value = b.arrayExpression([e.value, t.value]);
        }
      };
      var dedupeProperties = (e = [], t) => {
        if (!t) {
          return e;
        }
        const r = new Map();
        const s = [];
        e.forEach((e) => {
          if (b.isStringLiteral(e.key)) {
            const { value: t } = e.key;
            const i = r.get(t);
            if (i) {
              if (t === 'style' || t === 'class' || t.startsWith('on')) {
                mergeAsArray(i, e);
              }
            } else {
              r.set(t, e);
              s.push(e);
            }
          } else {
            s.push(e);
          }
        });
        return s;
      };
      var isConstant = (e) => {
        if (b.isIdentifier(e)) {
          return e.name === 'undefined';
        }
        if (b.isArrayExpression(e)) {
          const { elements: t } = e;
          return t.every((e) => e && isConstant(e));
        }
        if (b.isObjectExpression(e)) {
          return e.properties.every((e) => isConstant(e.value));
        }
        if (b.isLiteral(e)) {
          return true;
        }
        return false;
      };
      var transformJSXSpreadAttribute = (e, t, r, s) => {
        const i = t.get('argument');
        const n = b.isObjectExpression(i.node) ? i.node.properties : void 0;
        if (!n) {
          if (i.isIdentifier()) {
            walksScope(e, i.node.name, A.DYNAMIC);
          }
          s.push(r ? i.node : b.spreadElement(i.node));
        } else if (r) {
          s.push(b.objectExpression(n));
        } else {
          s.push(...n);
        }
      };
      var N = __toESM(r(4739));
      var getType = (e) => {
        const t = e.get('attributes').find((e) => {
          if (!e.isJSXAttribute()) {
            return false;
          }
          return (
            e.get('name').isJSXIdentifier() &&
            e.get('name').node.name === 'type'
          );
        });
        return t ? t.get('value').node : null;
      };
      var parseModifiers = (e) =>
        N.isArrayExpression(e)
          ? e.elements
              .map((e) => (N.isStringLiteral(e) ? e.value : ''))
              .filter(Boolean)
          : [];
      var parseDirectives = (e) => {
        var t, r;
        const { path: s, value: i, state: n, tag: a, isComponent: o } = e;
        const l = [];
        const c = [];
        const p = [];
        let u;
        let d;
        let f;
        if ('namespace' in s.node.name) {
          [u, d] = e.name.split(':');
          u = s.node.name.namespace.name;
          d = s.node.name.name.name;
          f = d.split('_').slice(1);
        } else {
          const t = e.name.split('_');
          u = t.shift() || '';
          f = t;
        }
        u = u
          .replace(/^v/, '')
          .replace(/^-/, '')
          .replace(/^\S/, (e) => e.toLowerCase());
        if (d) {
          l.push(N.stringLiteral(d));
        }
        const h = u === 'models';
        const y = u === 'model';
        if (y && !s.get('value').isJSXExpressionContainer()) {
          throw new Error('You have to use JSX Expression inside your v-model');
        }
        if (h && !o) {
          throw new Error('v-models can only use in custom components');
        }
        const m = !['html', 'text', 'model', 'models'].includes(u) || (y && !o);
        let T = f;
        if (N.isArrayExpression(i)) {
          const e = h ? i.elements : [i];
          e.forEach((e) => {
            if (h && !N.isArrayExpression(e)) {
              throw new Error(
                'You should pass a Two-dimensional Arrays to v-models',
              );
            }
            const { elements: t } = e;
            const [r, s, i] = t;
            if (s && !N.isArrayExpression(s) && !N.isSpreadElement(s)) {
              l.push(s);
              T = parseModifiers(i);
            } else if (N.isArrayExpression(s)) {
              if (!m) {
                l.push(N.nullLiteral());
              }
              T = parseModifiers(s);
            } else if (!m) {
              l.push(N.nullLiteral());
            }
            p.push(new Set(T));
            c.push(r);
          });
        } else if (y && !m) {
          l.push(N.nullLiteral());
          p.push(new Set(f));
        } else {
          p.push(new Set(f));
        }
        return {
          directiveName: u,
          modifiers: p,
          values: c.length ? c : [i],
          args: l,
          directive: m
            ? [
                resolveDirective(s, n, a, u),
                c[0] || i,
                ((t = p[0]) == null ? void 0 : t.size)
                  ? l[0] || N.unaryExpression('void', N.numericLiteral(0), true)
                  : l[0],
                !!((r = p[0]) == null ? void 0 : r.size) &&
                  N.objectExpression(
                    [...p[0]].map((e) =>
                      N.objectProperty(N.identifier(e), N.booleanLiteral(true)),
                    ),
                  ),
              ].filter(Boolean)
            : void 0,
        };
      };
      var resolveDirective = (e, t, r, s) => {
        if (s === 'show') {
          return createIdentifier(t, 'vShow');
        }
        if (s === 'model') {
          let s;
          const i = getType(e.parentPath);
          switch (r.value) {
            case 'select':
              s = createIdentifier(t, 'vModelSelect');
              break;
            case 'textarea':
              s = createIdentifier(t, 'vModelText');
              break;
            default:
              if (N.isStringLiteral(i) || !i) {
                switch (i == null ? void 0 : i.value) {
                  case 'checkbox':
                    s = createIdentifier(t, 'vModelCheckbox');
                    break;
                  case 'radio':
                    s = createIdentifier(t, 'vModelRadio');
                    break;
                  default:
                    s = createIdentifier(t, 'vModelText');
                }
              } else {
                s = createIdentifier(t, 'vModelDynamic');
              }
          }
          return s;
        }
        return N.callExpression(createIdentifier(t, 'resolveDirective'), [
          N.stringLiteral(s),
        ]);
      };
      var O = parseDirectives;
      var C = /^xlink([A-Z])/;
      var getJSXAttributeValue = (e, t) => {
        const r = e.get('value');
        if (r.isJSXElement()) {
          return transformJSXElement(r, t);
        }
        if (r.isStringLiteral()) {
          return S.stringLiteral(transformText(r.node.value));
        }
        if (r.isJSXExpressionContainer()) {
          return transformJSXExpressionContainer(r);
        }
        return null;
      };
      var buildProps = (e, t) => {
        const r = getTag(e, t);
        const s = checkIsComponent(e.get('openingElement'), t);
        const i = e.get('openingElement').get('attributes');
        const n = [];
        const a = new Set();
        let o = null;
        let l = 0;
        if (i.length === 0) {
          return {
            tag: r,
            isComponent: s,
            slots: o,
            props: S.nullLiteral(),
            directives: n,
            patchFlag: l,
            dynamicPropNames: a,
          };
        }
        let c = [];
        let p = false;
        let u = false;
        let d = false;
        let f = false;
        let h = false;
        const y = [];
        const { mergeProps: m = true } = t.opts;
        i.forEach((i) => {
          if (i.isJSXAttribute()) {
            let l = getJSXAttributeName(i);
            const m = getJSXAttributeValue(i, t);
            if (!isConstant(m) || l === 'ref') {
              if (
                !s &&
                isOn(l) &&
                l.toLowerCase() !== 'onclick' &&
                l !== 'onUpdate:modelValue'
              ) {
                f = true;
              }
              if (l === 'ref') {
                p = true;
              } else if (l === 'class' && !s) {
                u = true;
              } else if (l === 'style' && !s) {
                d = true;
              } else if (l !== 'key' && !isDirective(l) && l !== 'on') {
                a.add(l);
              }
            }
            if (t.opts.transformOn && (l === 'on' || l === 'nativeOn')) {
              if (!t.get('transformOn')) {
                t.set(
                  'transformOn',
                  (0, x.addDefault)(e, '@vue/babel-helper-vue-transform-on', {
                    nameHint: '_transformOn',
                  }),
                );
              }
              y.push(
                S.callExpression(t.get('transformOn'), [
                  m || S.booleanLiteral(true),
                ]),
              );
              return;
            }
            if (isDirective(l)) {
              const {
                directive: e,
                modifiers: p,
                values: u,
                args: d,
                directiveName: f,
              } = O({
                tag: r,
                isComponent: s,
                name: l,
                path: i,
                state: t,
                value: m,
              });
              if (f === 'slots') {
                o = m;
                return;
              }
              if (e) {
                n.push(S.arrayExpression(e));
              } else if (f === 'html') {
                c.push(S.objectProperty(S.stringLiteral('innerHTML'), u[0]));
                a.add('innerHTML');
              } else if (f === 'text') {
                c.push(S.objectProperty(S.stringLiteral('textContent'), u[0]));
                a.add('textContent');
              }
              if (['models', 'model'].includes(f)) {
                u.forEach((t, r) => {
                  var s;
                  const i = d[r];
                  const n = i && !S.isStringLiteral(i) && !S.isNullLiteral(i);
                  if (!e) {
                    c.push(
                      S.objectProperty(
                        S.isNullLiteral(i) ? S.stringLiteral('modelValue') : i,
                        t,
                        n,
                      ),
                    );
                    if (!n) {
                      a.add((i == null ? void 0 : i.value) || 'modelValue');
                    }
                    if ((s = p[r]) == null ? void 0 : s.size) {
                      c.push(
                        S.objectProperty(
                          n
                            ? S.binaryExpression(
                                '+',
                                i,
                                S.stringLiteral('Modifiers'),
                              )
                            : S.stringLiteral(
                                `${
                                  (i == null ? void 0 : i.value) || 'model'
                                }Modifiers`,
                              ),
                          S.objectExpression(
                            [...p[r]].map((e) =>
                              S.objectProperty(
                                S.stringLiteral(e),
                                S.booleanLiteral(true),
                              ),
                            ),
                          ),
                          n,
                        ),
                      );
                    }
                  }
                  const o = n
                    ? S.binaryExpression('+', S.stringLiteral('onUpdate'), i)
                    : S.stringLiteral(
                        `onUpdate:${
                          (i == null ? void 0 : i.value) || 'modelValue'
                        }`,
                      );
                  c.push(
                    S.objectProperty(
                      o,
                      S.arrowFunctionExpression(
                        [S.identifier('$event')],
                        S.assignmentExpression('=', t, S.identifier('$event')),
                      ),
                      n,
                    ),
                  );
                  if (!n) {
                    a.add(o.value);
                  } else {
                    h = true;
                  }
                });
              }
            } else {
              if (l.match(C)) {
                l = l.replace(C, (e, t) => `xlink:${t.toLowerCase()}`);
              }
              c.push(
                S.objectProperty(
                  S.stringLiteral(l),
                  m || S.booleanLiteral(true),
                ),
              );
            }
          } else {
            if (c.length && m) {
              y.push(S.objectExpression(dedupeProperties(c, m)));
              c = [];
            }
            h = true;
            transformJSXSpreadAttribute(e, i, m, m ? y : c);
          }
        });
        if (h) {
          l |= 16;
        } else {
          if (u) {
            l |= 2;
          }
          if (d) {
            l |= 4;
          }
          if (a.size) {
            l |= 8;
          }
          if (f) {
            l |= 32;
          }
        }
        if ((l === 0 || l === 32) && (p || n.length > 0)) {
          l |= 512;
        }
        let T = S.nullLiteral();
        if (y.length) {
          if (c.length) {
            y.push(S.objectExpression(dedupeProperties(c, m)));
          }
          if (y.length > 1) {
            T = S.callExpression(createIdentifier(t, 'mergeProps'), y);
          } else {
            T = y[0];
          }
        } else if (c.length) {
          if (c.length === 1 && S.isSpreadElement(c[0])) {
            T = c[0].argument;
          } else {
            T = S.objectExpression(dedupeProperties(c, m));
          }
        }
        return {
          tag: r,
          props: T,
          isComponent: s,
          slots: o,
          directives: n,
          patchFlag: l,
          dynamicPropNames: a,
        };
      };
      var getChildren = (e, t) =>
        e
          .map((e) => {
            if (e.isJSXText()) {
              const r = transformJSXText(e);
              if (r) {
                return S.callExpression(
                  createIdentifier(t, 'createTextVNode'),
                  [r],
                );
              }
              return r;
            }
            if (e.isJSXExpressionContainer()) {
              const t = transformJSXExpressionContainer(e);
              if (S.isIdentifier(t)) {
                const { name: r } = t;
                const { referencePaths: s = [] } = e.scope.getBinding(r) || {};
                s.forEach((e) => {
                  walksScope(e, r, A.DYNAMIC);
                });
              }
              return t;
            }
            if (e.isJSXSpreadChild()) {
              return transformJSXSpreadChild(e);
            }
            if (e.isCallExpression()) {
              return e.node;
            }
            if (e.isJSXElement()) {
              return transformJSXElement(e, t);
            }
            throw new Error(`getChildren: ${e.type} is not supported`);
          })
          .filter((e) => e != null && !S.isJSXEmptyExpression(e));
      var transformJSXElement = (e, t) => {
        const r = getChildren(e.get('children'), t);
        const {
          tag: s,
          props: i,
          isComponent: n,
          directives: a,
          patchFlag: o,
          dynamicPropNames: l,
          slots: c,
        } = buildProps(e, t);
        const { optimize: p = false } = t.opts;
        const u = e.getData('slotFlag') || A.STABLE;
        let d;
        if (r.length > 1 || c) {
          d = n
            ? r.length
              ? S.objectExpression(
                  [
                    !!r.length &&
                      S.objectProperty(
                        S.identifier('default'),
                        S.arrowFunctionExpression(
                          [],
                          S.arrayExpression(buildIIFE(e, r)),
                        ),
                      ),
                    ...(c
                      ? S.isObjectExpression(c)
                        ? c.properties
                        : [S.spreadElement(c)]
                      : []),
                    p &&
                      S.objectProperty(S.identifier('_'), S.numericLiteral(u)),
                  ].filter(Boolean),
                )
              : c
            : S.arrayExpression(r);
        } else if (r.length === 1) {
          const { enableObjectSlots: s = true } = t.opts;
          const i = r[0];
          const a = S.objectExpression(
            [
              S.objectProperty(
                S.identifier('default'),
                S.arrowFunctionExpression(
                  [],
                  S.arrayExpression(buildIIFE(e, [i])),
                ),
              ),
              p && S.objectProperty(S.identifier('_'), S.numericLiteral(u)),
            ].filter(Boolean),
          );
          if (S.isIdentifier(i) && n) {
            d = s
              ? S.conditionalExpression(
                  S.callExpression(
                    t.get('@vue/babel-plugin-jsx/runtimeIsSlot')(),
                    [i],
                  ),
                  i,
                  a,
                )
              : a;
          } else if (S.isCallExpression(i) && i.loc && n) {
            if (s) {
              const { scope: r } = e;
              const s = r.generateUidIdentifier('slot');
              if (r) {
                r.push({ id: s, kind: 'let' });
              }
              const n = S.objectExpression(
                [
                  S.objectProperty(
                    S.identifier('default'),
                    S.arrowFunctionExpression(
                      [],
                      S.arrayExpression(buildIIFE(e, [s])),
                    ),
                  ),
                  p && S.objectProperty(S.identifier('_'), S.numericLiteral(u)),
                ].filter(Boolean),
              );
              const a = S.assignmentExpression('=', s, i);
              const o = S.callExpression(
                t.get('@vue/babel-plugin-jsx/runtimeIsSlot')(),
                [a],
              );
              d = S.conditionalExpression(o, s, n);
            } else {
              d = a;
            }
          } else if (
            S.isFunctionExpression(i) ||
            S.isArrowFunctionExpression(i)
          ) {
            d = S.objectExpression([
              S.objectProperty(S.identifier('default'), i),
            ]);
          } else if (S.isObjectExpression(i)) {
            d = S.objectExpression(
              [
                ...i.properties,
                p && S.objectProperty(S.identifier('_'), S.numericLiteral(u)),
              ].filter(Boolean),
            );
          } else {
            d = n
              ? S.objectExpression([
                  S.objectProperty(
                    S.identifier('default'),
                    S.arrowFunctionExpression([], S.arrayExpression([i])),
                  ),
                ])
              : S.arrayExpression([i]);
          }
        }
        const f = S.callExpression(
          createIdentifier(t, 'createVNode'),
          [
            s,
            i,
            d || S.nullLiteral(),
            !!o && p && S.numericLiteral(o),
            !!l.size &&
              p &&
              S.arrayExpression([...l.keys()].map((e) => S.stringLiteral(e))),
          ].filter(Boolean),
        );
        if (!a.length) {
          return f;
        }
        return S.callExpression(createIdentifier(t, 'withDirectives'), [
          f,
          S.arrayExpression(a),
        ]);
      };
      var D = {
        JSXElement: {
          exit(e, t) {
            e.replaceWith(transformJSXElement(e, t));
          },
        },
      };
      var k = __toESM(r(4739));
      var transformFragment = (e, t) => {
        const r = e.get('children') || [];
        return k.jsxElement(
          k.jsxOpeningElement(t, []),
          k.jsxClosingElement(t),
          r.map(({ node: e }) => e),
          false,
        );
      };
      var L = {
        JSXFragment: {
          enter(e, t) {
            const r = createIdentifier(t, v);
            e.replaceWith(
              transformFragment(
                e,
                k.isIdentifier(r)
                  ? k.jsxIdentifier(r.name)
                  : k.jsxMemberExpression(
                      k.jsxIdentifier(r.object.name),
                      k.jsxIdentifier(r.property.name),
                    ),
              ),
            );
          },
        },
      };
      var hasJSX = (e) => {
        let t = false;
        e.traverse({
          JSXElement(e) {
            t = true;
            e.stop();
          },
          JSXFragment(e) {
            t = true;
            e.stop();
          },
        });
        return t;
      };
      var M = /\*?\s*@jsx\s+([^\s]+)/;
      var src_default = ({ types: e }) => ({
        name: 'babel-plugin-jsx',
        inherits: m.default,
        visitor: __spreadProps(__spreadValues(__spreadValues({}, D), L), {
          Program: {
            enter(t, r) {
              if (hasJSX(t)) {
                const s = [
                  'createVNode',
                  'Fragment',
                  'resolveComponent',
                  'withDirectives',
                  'vShow',
                  'vModelSelect',
                  'vModelText',
                  'vModelCheckbox',
                  'vModelRadio',
                  'vModelText',
                  'vModelDynamic',
                  'resolveDirective',
                  'mergeProps',
                  'createTextVNode',
                  'isVNode',
                ];
                if ((0, T.isModule)(t)) {
                  const i = {};
                  s.forEach((s) => {
                    r.set(s, () => {
                      if (i[s]) {
                        return e.cloneNode(i[s]);
                      }
                      const r = (0, T.addNamed)(t, s, 'vue', {
                        ensureLiveReference: true,
                      });
                      i[s] = r;
                      return r;
                    });
                  });
                  const { enableObjectSlots: n = true } = r.opts;
                  if (n) {
                    r.set('@vue/babel-plugin-jsx/runtimeIsSlot', () => {
                      if (i.runtimeIsSlot) {
                        return i.runtimeIsSlot;
                      }
                      const { name: e } = r.get('isVNode')();
                      const s = t.scope.generateUidIdentifier('isSlot');
                      const n = y.default.ast`
                  function ${s.name}(s) {
                    return typeof s === 'function' || (Object.prototype.toString.call(s) === '[object Object]' && !${e}(s));
                  }
                `;
                      const a = t
                        .get('body')
                        .filter((e) => e.isImportDeclaration())
                        .pop();
                      if (a) {
                        a.insertAfter(n);
                      }
                      i.runtimeIsSlot = s;
                      return s;
                    });
                  }
                } else {
                  let e;
                  s.forEach((s) => {
                    r.set(s, () => {
                      if (!e) {
                        e = (0, T.addNamespace)(t, 'vue', {
                          ensureLiveReference: true,
                        });
                      }
                      return h.memberExpression(e, h.identifier(s));
                    });
                  });
                  const i = {};
                  const { enableObjectSlots: n = true } = r.opts;
                  if (n) {
                    r.set('@vue/babel-plugin-jsx/runtimeIsSlot', () => {
                      if (i.runtimeIsSlot) {
                        return i.runtimeIsSlot;
                      }
                      const s = t.scope.generateUidIdentifier('isSlot');
                      const { object: n } = r.get('isVNode')();
                      const a = y.default.ast`
                  function ${s.name}(s) {
                    return typeof s === 'function' || (Object.prototype.toString.call(s) === '[object Object]' && !${n.name}.isVNode(s));
                  }
                `;
                      const o = t.get('body');
                      const l = o
                        .filter(
                          (t) =>
                            t.isVariableDeclaration() &&
                            t.node.declarations.some((t) => {
                              var r;
                              return (
                                ((r = t.id) == null ? void 0 : r.name) ===
                                e.name
                              );
                            }),
                        )
                        .pop();
                      if (l) {
                        l.insertAfter(a);
                      }
                      return s;
                    });
                  }
                }
                const {
                  opts: { pragma: i = '' },
                  file: n,
                } = r;
                if (i) {
                  r.set('createVNode', () => h.identifier(i));
                }
                if (n.ast.comments) {
                  for (const e of n.ast.comments) {
                    const t = M.exec(e.value);
                    if (t) {
                      r.set('createVNode', () => h.identifier(t[1]));
                    }
                  }
                }
              }
            },
            exit(e) {
              const t = e.get('body');
              const r = new Map();
              t.filter(
                (e) =>
                  h.isImportDeclaration(e.node) &&
                  e.node.source.value === 'vue',
              ).forEach((e) => {
                const { specifiers: t } = e.node;
                let s = false;
                t.forEach((e) => {
                  if (
                    !e.loc &&
                    h.isImportSpecifier(e) &&
                    h.isIdentifier(e.imported)
                  ) {
                    r.set(e.imported.name, e);
                    s = true;
                  }
                });
                if (s) {
                  e.remove();
                }
              });
              const s = [...r.keys()].map((e) => r.get(e));
              if (s.length) {
                e.unshiftContainer(
                  'body',
                  h.importDeclaration(s, h.stringLiteral('vue')),
                );
              }
            },
          },
        }),
      });
    },
    4571: function (e, t, r) {
      'use strict';
      e = r.nmd(e);
      const s = r(6755);
      const wrapAnsi16 = (e, t) =>
        function () {
          const r = e.apply(s, arguments);
          return `[${r + t}m`;
        };
      const wrapAnsi256 = (e, t) =>
        function () {
          const r = e.apply(s, arguments);
          return `[${38 + t};5;${r}m`;
        };
      const wrapAnsi16m = (e, t) =>
        function () {
          const r = e.apply(s, arguments);
          return `[${38 + t};2;${r[0]};${r[1]};${r[2]}m`;
        };
      function assembleStyles() {
        const e = new Map();
        const t = {
          modifier: {
            reset: [0, 0],
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29],
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            gray: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39],
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49],
          },
        };
        t.color.grey = t.color.gray;
        for (const r of Object.keys(t)) {
          const s = t[r];
          for (const r of Object.keys(s)) {
            const i = s[r];
            t[r] = { open: `[${i[0]}m`, close: `[${i[1]}m` };
            s[r] = t[r];
            e.set(i[0], i[1]);
          }
          Object.defineProperty(t, r, { value: s, enumerable: false });
          Object.defineProperty(t, 'codes', { value: e, enumerable: false });
        }
        const ansi2ansi = (e) => e;
        const rgb2rgb = (e, t, r) => [e, t, r];
        t.color.close = '[39m';
        t.bgColor.close = '[49m';
        t.color.ansi = { ansi: wrapAnsi16(ansi2ansi, 0) };
        t.color.ansi256 = { ansi256: wrapAnsi256(ansi2ansi, 0) };
        t.color.ansi16m = { rgb: wrapAnsi16m(rgb2rgb, 0) };
        t.bgColor.ansi = { ansi: wrapAnsi16(ansi2ansi, 10) };
        t.bgColor.ansi256 = { ansi256: wrapAnsi256(ansi2ansi, 10) };
        t.bgColor.ansi16m = { rgb: wrapAnsi16m(rgb2rgb, 10) };
        for (let e of Object.keys(s)) {
          if (typeof s[e] !== 'object') {
            continue;
          }
          const r = s[e];
          if (e === 'ansi16') {
            e = 'ansi';
          }
          if ('ansi16' in r) {
            t.color.ansi[e] = wrapAnsi16(r.ansi16, 0);
            t.bgColor.ansi[e] = wrapAnsi16(r.ansi16, 10);
          }
          if ('ansi256' in r) {
            t.color.ansi256[e] = wrapAnsi256(r.ansi256, 0);
            t.bgColor.ansi256[e] = wrapAnsi256(r.ansi256, 10);
          }
          if ('rgb' in r) {
            t.color.ansi16m[e] = wrapAnsi16m(r.rgb, 0);
            t.bgColor.ansi16m[e] = wrapAnsi16m(r.rgb, 10);
          }
        }
        return t;
      }
      Object.defineProperty(e, 'exports', {
        enumerable: true,
        get: assembleStyles,
      });
    },
    6673: function (e, t, r) {
      'use strict';
      const s = r(4434);
      const i = r(4571);
      const n = r(2332).stdout;
      const a = r(1956);
      const o =
        process.platform === 'win32' &&
        !(process.env.TERM || '').toLowerCase().startsWith('xterm');
      const l = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
      const c = new Set(['gray']);
      const p = Object.create(null);
      function applyOptions(e, t) {
        t = t || {};
        const r = n ? n.level : 0;
        e.level = t.level === undefined ? r : t.level;
        e.enabled = 'enabled' in t ? t.enabled : e.level > 0;
      }
      function Chalk(e) {
        if (!this || !(this instanceof Chalk) || this.template) {
          const t = {};
          applyOptions(t, e);
          t.template = function () {
            const e = [].slice.call(arguments);
            return chalkTag.apply(null, [t.template].concat(e));
          };
          Object.setPrototypeOf(t, Chalk.prototype);
          Object.setPrototypeOf(t.template, t);
          t.template.constructor = Chalk;
          return t.template;
        }
        applyOptions(this, e);
      }
      if (o) {
        i.blue.open = '[94m';
      }
      for (const e of Object.keys(i)) {
        i[e].closeRe = new RegExp(s(i[e].close), 'g');
        p[e] = {
          get() {
            const t = i[e];
            return build.call(
              this,
              this._styles ? this._styles.concat(t) : [t],
              this._empty,
              e,
            );
          },
        };
      }
      p.visible = {
        get() {
          return build.call(this, this._styles || [], true, 'visible');
        },
      };
      i.color.closeRe = new RegExp(s(i.color.close), 'g');
      for (const e of Object.keys(i.color.ansi)) {
        if (c.has(e)) {
          continue;
        }
        p[e] = {
          get() {
            const t = this.level;
            return function () {
              const r = i.color[l[t]][e].apply(null, arguments);
              const s = {
                open: r,
                close: i.color.close,
                closeRe: i.color.closeRe,
              };
              return build.call(
                this,
                this._styles ? this._styles.concat(s) : [s],
                this._empty,
                e,
              );
            };
          },
        };
      }
      i.bgColor.closeRe = new RegExp(s(i.bgColor.close), 'g');
      for (const e of Object.keys(i.bgColor.ansi)) {
        if (c.has(e)) {
          continue;
        }
        const t = 'bg' + e[0].toUpperCase() + e.slice(1);
        p[t] = {
          get() {
            const t = this.level;
            return function () {
              const r = i.bgColor[l[t]][e].apply(null, arguments);
              const s = {
                open: r,
                close: i.bgColor.close,
                closeRe: i.bgColor.closeRe,
              };
              return build.call(
                this,
                this._styles ? this._styles.concat(s) : [s],
                this._empty,
                e,
              );
            };
          },
        };
      }
      const u = Object.defineProperties(() => {}, p);
      function build(e, t, r) {
        const builder = function () {
          return applyStyle.apply(builder, arguments);
        };
        builder._styles = e;
        builder._empty = t;
        const s = this;
        Object.defineProperty(builder, 'level', {
          enumerable: true,
          get() {
            return s.level;
          },
          set(e) {
            s.level = e;
          },
        });
        Object.defineProperty(builder, 'enabled', {
          enumerable: true,
          get() {
            return s.enabled;
          },
          set(e) {
            s.enabled = e;
          },
        });
        builder.hasGrey = this.hasGrey || r === 'gray' || r === 'grey';
        builder.__proto__ = u;
        return builder;
      }
      function applyStyle() {
        const e = arguments;
        const t = e.length;
        let r = String(arguments[0]);
        if (t === 0) {
          return '';
        }
        if (t > 1) {
          for (let s = 1; s < t; s++) {
            r += ' ' + e[s];
          }
        }
        if (!this.enabled || this.level <= 0 || !r) {
          return this._empty ? '' : r;
        }
        const s = i.dim.open;
        if (o && this.hasGrey) {
          i.dim.open = '';
        }
        for (const e of this._styles.slice().reverse()) {
          r = e.open + r.replace(e.closeRe, e.open) + e.close;
          r = r.replace(/\r?\n/g, `${e.close}$&${e.open}`);
        }
        i.dim.open = s;
        return r;
      }
      function chalkTag(e, t) {
        if (!Array.isArray(t)) {
          return [].slice.call(arguments, 1).join(' ');
        }
        const r = [].slice.call(arguments, 2);
        const s = [t.raw[0]];
        for (let e = 1; e < t.length; e++) {
          s.push(String(r[e - 1]).replace(/[{}\\]/g, '\\$&'));
          s.push(String(t.raw[e]));
        }
        return a(e, s.join(''));
      }
      Object.defineProperties(Chalk.prototype, p);
      e.exports = Chalk();
      e.exports.supportsColor = n;
      e.exports['default'] = e.exports;
    },
    1956: function (e) {
      'use strict';
      const t =
        /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
      const r = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
      const s = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
      const i = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
      const n = new Map([
        ['n', '\n'],
        ['r', '\r'],
        ['t', '\t'],
        ['b', '\b'],
        ['f', '\f'],
        ['v', '\v'],
        ['0', '\0'],
        ['\\', '\\'],
        ['e', ''],
        ['a', ''],
      ]);
      function unescape(e) {
        if (
          (e[0] === 'u' && e.length === 5) ||
          (e[0] === 'x' && e.length === 3)
        ) {
          return String.fromCharCode(parseInt(e.slice(1), 16));
        }
        return n.get(e) || e;
      }
      function parseArguments(e, t) {
        const r = [];
        const n = t.trim().split(/\s*,\s*/g);
        let a;
        for (const t of n) {
          if (!isNaN(t)) {
            r.push(Number(t));
          } else if ((a = t.match(s))) {
            r.push(a[2].replace(i, (e, t, r) => (t ? unescape(t) : r)));
          } else {
            throw new Error(
              `Invalid Chalk template style argument: ${t} (in style '${e}')`,
            );
          }
        }
        return r;
      }
      function parseStyle(e) {
        r.lastIndex = 0;
        const t = [];
        let s;
        while ((s = r.exec(e)) !== null) {
          const e = s[1];
          if (s[2]) {
            const r = parseArguments(e, s[2]);
            t.push([e].concat(r));
          } else {
            t.push([e]);
          }
        }
        return t;
      }
      function buildStyle(e, t) {
        const r = {};
        for (const e of t) {
          for (const t of e.styles) {
            r[t[0]] = e.inverse ? null : t.slice(1);
          }
        }
        let s = e;
        for (const e of Object.keys(r)) {
          if (Array.isArray(r[e])) {
            if (!(e in s)) {
              throw new Error(`Unknown Chalk style: ${e}`);
            }
            if (r[e].length > 0) {
              s = s[e].apply(s, r[e]);
            } else {
              s = s[e];
            }
          }
        }
        return s;
      }
      e.exports = (e, r) => {
        const s = [];
        const i = [];
        let n = [];
        r.replace(t, (t, r, a, o, l, c) => {
          if (r) {
            n.push(unescape(r));
          } else if (o) {
            const t = n.join('');
            n = [];
            i.push(s.length === 0 ? t : buildStyle(e, s)(t));
            s.push({ inverse: a, styles: parseStyle(o) });
          } else if (l) {
            if (s.length === 0) {
              throw new Error('Found extraneous } in Chalk template literal');
            }
            i.push(buildStyle(e, s)(n.join('')));
            n = [];
            s.pop();
          } else {
            n.push(c);
          }
        });
        i.push(n.join(''));
        if (s.length > 0) {
          const e = `Chalk template literal is missing ${
            s.length
          } closing bracket${s.length === 1 ? '' : 's'} (\`}\`)`;
          throw new Error(e);
        }
        return i.join('');
      };
    },
    4461: function (e, t, r) {
      var s = r(391);
      var i = {};
      for (var n in s) {
        if (s.hasOwnProperty(n)) {
          i[s[n]] = n;
        }
      }
      var a = (e.exports = {
        rgb: { channels: 3, labels: 'rgb' },
        hsl: { channels: 3, labels: 'hsl' },
        hsv: { channels: 3, labels: 'hsv' },
        hwb: { channels: 3, labels: 'hwb' },
        cmyk: { channels: 4, labels: 'cmyk' },
        xyz: { channels: 3, labels: 'xyz' },
        lab: { channels: 3, labels: 'lab' },
        lch: { channels: 3, labels: 'lch' },
        hex: { channels: 1, labels: ['hex'] },
        keyword: { channels: 1, labels: ['keyword'] },
        ansi16: { channels: 1, labels: ['ansi16'] },
        ansi256: { channels: 1, labels: ['ansi256'] },
        hcg: { channels: 3, labels: ['h', 'c', 'g'] },
        apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
        gray: { channels: 1, labels: ['gray'] },
      });
      for (var o in a) {
        if (a.hasOwnProperty(o)) {
          if (!('channels' in a[o])) {
            throw new Error('missing channels property: ' + o);
          }
          if (!('labels' in a[o])) {
            throw new Error('missing channel labels property: ' + o);
          }
          if (a[o].labels.length !== a[o].channels) {
            throw new Error('channel and label counts mismatch: ' + o);
          }
          var l = a[o].channels;
          var c = a[o].labels;
          delete a[o].channels;
          delete a[o].labels;
          Object.defineProperty(a[o], 'channels', { value: l });
          Object.defineProperty(a[o], 'labels', { value: c });
        }
      }
      a.rgb.hsl = function (e) {
        var t = e[0] / 255;
        var r = e[1] / 255;
        var s = e[2] / 255;
        var i = Math.min(t, r, s);
        var n = Math.max(t, r, s);
        var a = n - i;
        var o;
        var l;
        var c;
        if (n === i) {
          o = 0;
        } else if (t === n) {
          o = (r - s) / a;
        } else if (r === n) {
          o = 2 + (s - t) / a;
        } else if (s === n) {
          o = 4 + (t - r) / a;
        }
        o = Math.min(o * 60, 360);
        if (o < 0) {
          o += 360;
        }
        c = (i + n) / 2;
        if (n === i) {
          l = 0;
        } else if (c <= 0.5) {
          l = a / (n + i);
        } else {
          l = a / (2 - n - i);
        }
        return [o, l * 100, c * 100];
      };
      a.rgb.hsv = function (e) {
        var t;
        var r;
        var s;
        var i;
        var n;
        var a = e[0] / 255;
        var o = e[1] / 255;
        var l = e[2] / 255;
        var c = Math.max(a, o, l);
        var p = c - Math.min(a, o, l);
        var diffc = function (e) {
          return (c - e) / 6 / p + 1 / 2;
        };
        if (p === 0) {
          i = n = 0;
        } else {
          n = p / c;
          t = diffc(a);
          r = diffc(o);
          s = diffc(l);
          if (a === c) {
            i = s - r;
          } else if (o === c) {
            i = 1 / 3 + t - s;
          } else if (l === c) {
            i = 2 / 3 + r - t;
          }
          if (i < 0) {
            i += 1;
          } else if (i > 1) {
            i -= 1;
          }
        }
        return [i * 360, n * 100, c * 100];
      };
      a.rgb.hwb = function (e) {
        var t = e[0];
        var r = e[1];
        var s = e[2];
        var i = a.rgb.hsl(e)[0];
        var n = (1 / 255) * Math.min(t, Math.min(r, s));
        s = 1 - (1 / 255) * Math.max(t, Math.max(r, s));
        return [i, n * 100, s * 100];
      };
      a.rgb.cmyk = function (e) {
        var t = e[0] / 255;
        var r = e[1] / 255;
        var s = e[2] / 255;
        var i;
        var n;
        var a;
        var o;
        o = Math.min(1 - t, 1 - r, 1 - s);
        i = (1 - t - o) / (1 - o) || 0;
        n = (1 - r - o) / (1 - o) || 0;
        a = (1 - s - o) / (1 - o) || 0;
        return [i * 100, n * 100, a * 100, o * 100];
      };
      function comparativeDistance(e, t) {
        return (
          Math.pow(e[0] - t[0], 2) +
          Math.pow(e[1] - t[1], 2) +
          Math.pow(e[2] - t[2], 2)
        );
      }
      a.rgb.keyword = function (e) {
        var t = i[e];
        if (t) {
          return t;
        }
        var r = Infinity;
        var n;
        for (var a in s) {
          if (s.hasOwnProperty(a)) {
            var o = s[a];
            var l = comparativeDistance(e, o);
            if (l < r) {
              r = l;
              n = a;
            }
          }
        }
        return n;
      };
      a.keyword.rgb = function (e) {
        return s[e];
      };
      a.rgb.xyz = function (e) {
        var t = e[0] / 255;
        var r = e[1] / 255;
        var s = e[2] / 255;
        t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92;
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        s = s > 0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92;
        var i = t * 0.4124 + r * 0.3576 + s * 0.1805;
        var n = t * 0.2126 + r * 0.7152 + s * 0.0722;
        var a = t * 0.0193 + r * 0.1192 + s * 0.9505;
        return [i * 100, n * 100, a * 100];
      };
      a.rgb.lab = function (e) {
        var t = a.rgb.xyz(e);
        var r = t[0];
        var s = t[1];
        var i = t[2];
        var n;
        var o;
        var l;
        r /= 95.047;
        s /= 100;
        i /= 108.883;
        r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116;
        s = s > 0.008856 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116;
        i = i > 0.008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116;
        n = 116 * s - 16;
        o = 500 * (r - s);
        l = 200 * (s - i);
        return [n, o, l];
      };
      a.hsl.rgb = function (e) {
        var t = e[0] / 360;
        var r = e[1] / 100;
        var s = e[2] / 100;
        var i;
        var n;
        var a;
        var o;
        var l;
        if (r === 0) {
          l = s * 255;
          return [l, l, l];
        }
        if (s < 0.5) {
          n = s * (1 + r);
        } else {
          n = s + r - s * r;
        }
        i = 2 * s - n;
        o = [0, 0, 0];
        for (var c = 0; c < 3; c++) {
          a = t + (1 / 3) * -(c - 1);
          if (a < 0) {
            a++;
          }
          if (a > 1) {
            a--;
          }
          if (6 * a < 1) {
            l = i + (n - i) * 6 * a;
          } else if (2 * a < 1) {
            l = n;
          } else if (3 * a < 2) {
            l = i + (n - i) * (2 / 3 - a) * 6;
          } else {
            l = i;
          }
          o[c] = l * 255;
        }
        return o;
      };
      a.hsl.hsv = function (e) {
        var t = e[0];
        var r = e[1] / 100;
        var s = e[2] / 100;
        var i = r;
        var n = Math.max(s, 0.01);
        var a;
        var o;
        s *= 2;
        r *= s <= 1 ? s : 2 - s;
        i *= n <= 1 ? n : 2 - n;
        o = (s + r) / 2;
        a = s === 0 ? (2 * i) / (n + i) : (2 * r) / (s + r);
        return [t, a * 100, o * 100];
      };
      a.hsv.rgb = function (e) {
        var t = e[0] / 60;
        var r = e[1] / 100;
        var s = e[2] / 100;
        var i = Math.floor(t) % 6;
        var n = t - Math.floor(t);
        var a = 255 * s * (1 - r);
        var o = 255 * s * (1 - r * n);
        var l = 255 * s * (1 - r * (1 - n));
        s *= 255;
        switch (i) {
          case 0:
            return [s, l, a];
          case 1:
            return [o, s, a];
          case 2:
            return [a, s, l];
          case 3:
            return [a, o, s];
          case 4:
            return [l, a, s];
          case 5:
            return [s, a, o];
        }
      };
      a.hsv.hsl = function (e) {
        var t = e[0];
        var r = e[1] / 100;
        var s = e[2] / 100;
        var i = Math.max(s, 0.01);
        var n;
        var a;
        var o;
        o = (2 - r) * s;
        n = (2 - r) * i;
        a = r * i;
        a /= n <= 1 ? n : 2 - n;
        a = a || 0;
        o /= 2;
        return [t, a * 100, o * 100];
      };
      a.hwb.rgb = function (e) {
        var t = e[0] / 360;
        var r = e[1] / 100;
        var s = e[2] / 100;
        var i = r + s;
        var n;
        var a;
        var o;
        var l;
        if (i > 1) {
          r /= i;
          s /= i;
        }
        n = Math.floor(6 * t);
        a = 1 - s;
        o = 6 * t - n;
        if ((n & 1) !== 0) {
          o = 1 - o;
        }
        l = r + o * (a - r);
        var c;
        var p;
        var u;
        switch (n) {
          default:
          case 6:
          case 0:
            c = a;
            p = l;
            u = r;
            break;
          case 1:
            c = l;
            p = a;
            u = r;
            break;
          case 2:
            c = r;
            p = a;
            u = l;
            break;
          case 3:
            c = r;
            p = l;
            u = a;
            break;
          case 4:
            c = l;
            p = r;
            u = a;
            break;
          case 5:
            c = a;
            p = r;
            u = l;
            break;
        }
        return [c * 255, p * 255, u * 255];
      };
      a.cmyk.rgb = function (e) {
        var t = e[0] / 100;
        var r = e[1] / 100;
        var s = e[2] / 100;
        var i = e[3] / 100;
        var n;
        var a;
        var o;
        n = 1 - Math.min(1, t * (1 - i) + i);
        a = 1 - Math.min(1, r * (1 - i) + i);
        o = 1 - Math.min(1, s * (1 - i) + i);
        return [n * 255, a * 255, o * 255];
      };
      a.xyz.rgb = function (e) {
        var t = e[0] / 100;
        var r = e[1] / 100;
        var s = e[2] / 100;
        var i;
        var n;
        var a;
        i = t * 3.2406 + r * -1.5372 + s * -0.4986;
        n = t * -0.9689 + r * 1.8758 + s * 0.0415;
        a = t * 0.0557 + r * -0.204 + s * 1.057;
        i = i > 0.0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i * 12.92;
        n = n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : n * 12.92;
        a = a > 0.0031308 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a * 12.92;
        i = Math.min(Math.max(0, i), 1);
        n = Math.min(Math.max(0, n), 1);
        a = Math.min(Math.max(0, a), 1);
        return [i * 255, n * 255, a * 255];
      };
      a.xyz.lab = function (e) {
        var t = e[0];
        var r = e[1];
        var s = e[2];
        var i;
        var n;
        var a;
        t /= 95.047;
        r /= 100;
        s /= 108.883;
        t = t > 0.008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116;
        r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116;
        s = s > 0.008856 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116;
        i = 116 * r - 16;
        n = 500 * (t - r);
        a = 200 * (r - s);
        return [i, n, a];
      };
      a.lab.xyz = function (e) {
        var t = e[0];
        var r = e[1];
        var s = e[2];
        var i;
        var n;
        var a;
        n = (t + 16) / 116;
        i = r / 500 + n;
        a = n - s / 200;
        var o = Math.pow(n, 3);
        var l = Math.pow(i, 3);
        var c = Math.pow(a, 3);
        n = o > 0.008856 ? o : (n - 16 / 116) / 7.787;
        i = l > 0.008856 ? l : (i - 16 / 116) / 7.787;
        a = c > 0.008856 ? c : (a - 16 / 116) / 7.787;
        i *= 95.047;
        n *= 100;
        a *= 108.883;
        return [i, n, a];
      };
      a.lab.lch = function (e) {
        var t = e[0];
        var r = e[1];
        var s = e[2];
        var i;
        var n;
        var a;
        i = Math.atan2(s, r);
        n = (i * 360) / 2 / Math.PI;
        if (n < 0) {
          n += 360;
        }
        a = Math.sqrt(r * r + s * s);
        return [t, a, n];
      };
      a.lch.lab = function (e) {
        var t = e[0];
        var r = e[1];
        var s = e[2];
        var i;
        var n;
        var a;
        a = (s / 360) * 2 * Math.PI;
        i = r * Math.cos(a);
        n = r * Math.sin(a);
        return [t, i, n];
      };
      a.rgb.ansi16 = function (e) {
        var t = e[0];
        var r = e[1];
        var s = e[2];
        var i = 1 in arguments ? arguments[1] : a.rgb.hsv(e)[2];
        i = Math.round(i / 50);
        if (i === 0) {
          return 30;
        }
        var n =
          30 +
          ((Math.round(s / 255) << 2) |
            (Math.round(r / 255) << 1) |
            Math.round(t / 255));
        if (i === 2) {
          n += 60;
        }
        return n;
      };
      a.hsv.ansi16 = function (e) {
        return a.rgb.ansi16(a.hsv.rgb(e), e[2]);
      };
      a.rgb.ansi256 = function (e) {
        var t = e[0];
        var r = e[1];
        var s = e[2];
        if (t === r && r === s) {
          if (t < 8) {
            return 16;
          }
          if (t > 248) {
            return 231;
          }
          return Math.round(((t - 8) / 247) * 24) + 232;
        }
        var i =
          16 +
          36 * Math.round((t / 255) * 5) +
          6 * Math.round((r / 255) * 5) +
          Math.round((s / 255) * 5);
        return i;
      };
      a.ansi16.rgb = function (e) {
        var t = e % 10;
        if (t === 0 || t === 7) {
          if (e > 50) {
            t += 3.5;
          }
          t = (t / 10.5) * 255;
          return [t, t, t];
        }
        var r = (~~(e > 50) + 1) * 0.5;
        var s = (t & 1) * r * 255;
        var i = ((t >> 1) & 1) * r * 255;
        var n = ((t >> 2) & 1) * r * 255;
        return [s, i, n];
      };
      a.ansi256.rgb = function (e) {
        if (e >= 232) {
          var t = (e - 232) * 10 + 8;
          return [t, t, t];
        }
        e -= 16;
        var r;
        var s = (Math.floor(e / 36) / 5) * 255;
        var i = (Math.floor((r = e % 36) / 6) / 5) * 255;
        var n = ((r % 6) / 5) * 255;
        return [s, i, n];
      };
      a.rgb.hex = function (e) {
        var t =
          ((Math.round(e[0]) & 255) << 16) +
          ((Math.round(e[1]) & 255) << 8) +
          (Math.round(e[2]) & 255);
        var r = t.toString(16).toUpperCase();
        return '000000'.substring(r.length) + r;
      };
      a.hex.rgb = function (e) {
        var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t) {
          return [0, 0, 0];
        }
        var r = t[0];
        if (t[0].length === 3) {
          r = r
            .split('')
            .map(function (e) {
              return e + e;
            })
            .join('');
        }
        var s = parseInt(r, 16);
        var i = (s >> 16) & 255;
        var n = (s >> 8) & 255;
        var a = s & 255;
        return [i, n, a];
      };
      a.rgb.hcg = function (e) {
        var t = e[0] / 255;
        var r = e[1] / 255;
        var s = e[2] / 255;
        var i = Math.max(Math.max(t, r), s);
        var n = Math.min(Math.min(t, r), s);
        var a = i - n;
        var o;
        var l;
        if (a < 1) {
          o = n / (1 - a);
        } else {
          o = 0;
        }
        if (a <= 0) {
          l = 0;
        } else if (i === t) {
          l = ((r - s) / a) % 6;
        } else if (i === r) {
          l = 2 + (s - t) / a;
        } else {
          l = 4 + (t - r) / a + 4;
        }
        l /= 6;
        l %= 1;
        return [l * 360, a * 100, o * 100];
      };
      a.hsl.hcg = function (e) {
        var t = e[1] / 100;
        var r = e[2] / 100;
        var s = 1;
        var i = 0;
        if (r < 0.5) {
          s = 2 * t * r;
        } else {
          s = 2 * t * (1 - r);
        }
        if (s < 1) {
          i = (r - 0.5 * s) / (1 - s);
        }
        return [e[0], s * 100, i * 100];
      };
      a.hsv.hcg = function (e) {
        var t = e[1] / 100;
        var r = e[2] / 100;
        var s = t * r;
        var i = 0;
        if (s < 1) {
          i = (r - s) / (1 - s);
        }
        return [e[0], s * 100, i * 100];
      };
      a.hcg.rgb = function (e) {
        var t = e[0] / 360;
        var r = e[1] / 100;
        var s = e[2] / 100;
        if (r === 0) {
          return [s * 255, s * 255, s * 255];
        }
        var i = [0, 0, 0];
        var n = (t % 1) * 6;
        var a = n % 1;
        var o = 1 - a;
        var l = 0;
        switch (Math.floor(n)) {
          case 0:
            i[0] = 1;
            i[1] = a;
            i[2] = 0;
            break;
          case 1:
            i[0] = o;
            i[1] = 1;
            i[2] = 0;
            break;
          case 2:
            i[0] = 0;
            i[1] = 1;
            i[2] = a;
            break;
          case 3:
            i[0] = 0;
            i[1] = o;
            i[2] = 1;
            break;
          case 4:
            i[0] = a;
            i[1] = 0;
            i[2] = 1;
            break;
          default:
            i[0] = 1;
            i[1] = 0;
            i[2] = o;
        }
        l = (1 - r) * s;
        return [
          (r * i[0] + l) * 255,
          (r * i[1] + l) * 255,
          (r * i[2] + l) * 255,
        ];
      };
      a.hcg.hsv = function (e) {
        var t = e[1] / 100;
        var r = e[2] / 100;
        var s = t + r * (1 - t);
        var i = 0;
        if (s > 0) {
          i = t / s;
        }
        return [e[0], i * 100, s * 100];
      };
      a.hcg.hsl = function (e) {
        var t = e[1] / 100;
        var r = e[2] / 100;
        var s = r * (1 - t) + 0.5 * t;
        var i = 0;
        if (s > 0 && s < 0.5) {
          i = t / (2 * s);
        } else if (s >= 0.5 && s < 1) {
          i = t / (2 * (1 - s));
        }
        return [e[0], i * 100, s * 100];
      };
      a.hcg.hwb = function (e) {
        var t = e[1] / 100;
        var r = e[2] / 100;
        var s = t + r * (1 - t);
        return [e[0], (s - t) * 100, (1 - s) * 100];
      };
      a.hwb.hcg = function (e) {
        var t = e[1] / 100;
        var r = e[2] / 100;
        var s = 1 - r;
        var i = s - t;
        var n = 0;
        if (i < 1) {
          n = (s - i) / (1 - i);
        }
        return [e[0], i * 100, n * 100];
      };
      a.apple.rgb = function (e) {
        return [
          (e[0] / 65535) * 255,
          (e[1] / 65535) * 255,
          (e[2] / 65535) * 255,
        ];
      };
      a.rgb.apple = function (e) {
        return [
          (e[0] / 255) * 65535,
          (e[1] / 255) * 65535,
          (e[2] / 255) * 65535,
        ];
      };
      a.gray.rgb = function (e) {
        return [(e[0] / 100) * 255, (e[0] / 100) * 255, (e[0] / 100) * 255];
      };
      a.gray.hsl = a.gray.hsv = function (e) {
        return [0, 0, e[0]];
      };
      a.gray.hwb = function (e) {
        return [0, 100, e[0]];
      };
      a.gray.cmyk = function (e) {
        return [0, 0, 0, e[0]];
      };
      a.gray.lab = function (e) {
        return [e[0], 0, 0];
      };
      a.gray.hex = function (e) {
        var t = Math.round((e[0] / 100) * 255) & 255;
        var r = (t << 16) + (t << 8) + t;
        var s = r.toString(16).toUpperCase();
        return '000000'.substring(s.length) + s;
      };
      a.rgb.gray = function (e) {
        var t = (e[0] + e[1] + e[2]) / 3;
        return [(t / 255) * 100];
      };
    },
    6755: function (e, t, r) {
      var s = r(4461);
      var i = r(1974);
      var n = {};
      var a = Object.keys(s);
      function wrapRaw(e) {
        var wrappedFn = function (t) {
          if (t === undefined || t === null) {
            return t;
          }
          if (arguments.length > 1) {
            t = Array.prototype.slice.call(arguments);
          }
          return e(t);
        };
        if ('conversion' in e) {
          wrappedFn.conversion = e.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(e) {
        var wrappedFn = function (t) {
          if (t === undefined || t === null) {
            return t;
          }
          if (arguments.length > 1) {
            t = Array.prototype.slice.call(arguments);
          }
          var r = e(t);
          if (typeof r === 'object') {
            for (var s = r.length, i = 0; i < s; i++) {
              r[i] = Math.round(r[i]);
            }
          }
          return r;
        };
        if ('conversion' in e) {
          wrappedFn.conversion = e.conversion;
        }
        return wrappedFn;
      }
      a.forEach(function (e) {
        n[e] = {};
        Object.defineProperty(n[e], 'channels', { value: s[e].channels });
        Object.defineProperty(n[e], 'labels', { value: s[e].labels });
        var t = i(e);
        var r = Object.keys(t);
        r.forEach(function (r) {
          var s = t[r];
          n[e][r] = wrapRounded(s);
          n[e][r].raw = wrapRaw(s);
        });
      });
      e.exports = n;
    },
    1974: function (e, t, r) {
      var s = r(4461);
      function buildGraph() {
        var e = {};
        var t = Object.keys(s);
        for (var r = t.length, i = 0; i < r; i++) {
          e[t[i]] = { distance: -1, parent: null };
        }
        return e;
      }
      function deriveBFS(e) {
        var t = buildGraph();
        var r = [e];
        t[e].distance = 0;
        while (r.length) {
          var i = r.pop();
          var n = Object.keys(s[i]);
          for (var a = n.length, o = 0; o < a; o++) {
            var l = n[o];
            var c = t[l];
            if (c.distance === -1) {
              c.distance = t[i].distance + 1;
              c.parent = i;
              r.unshift(l);
            }
          }
        }
        return t;
      }
      function link(e, t) {
        return function (r) {
          return t(e(r));
        };
      }
      function wrapConversion(e, t) {
        var r = [t[e].parent, e];
        var i = s[t[e].parent][e];
        var n = t[e].parent;
        while (t[n].parent) {
          r.unshift(t[n].parent);
          i = link(s[t[n].parent][n], i);
          n = t[n].parent;
        }
        i.conversion = r;
        return i;
      }
      e.exports = function (e) {
        var t = deriveBFS(e);
        var r = {};
        var s = Object.keys(t);
        for (var i = s.length, n = 0; n < i; n++) {
          var a = s[n];
          var o = t[a];
          if (o.parent === null) {
            continue;
          }
          r[a] = wrapConversion(a, t);
        }
        return r;
      };
    },
    391: function (e) {
      'use strict';
      e.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
      };
    },
    4434: function (e) {
      'use strict';
      var t = /[|\\{}()[\]^$+*?.]/g;
      e.exports = function (e) {
        if (typeof e !== 'string') {
          throw new TypeError('Expected a string');
        }
        return e.replace(t, '\\$&');
      };
    },
    419: function (e) {
      'use strict';
      e.exports = (e, t) => {
        t = t || process.argv;
        const r = e.startsWith('-') ? '' : e.length === 1 ? '-' : '--';
        const s = t.indexOf(r + e);
        const i = t.indexOf('--');
        return s !== -1 && (i === -1 ? true : s < i);
      };
    },
    5346: function (e, t, r) {
      'use strict';
      e.exports = r(5633);
    },
    8629: function (e, t) {
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] =
        /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
      t.matchToToken = function (e) {
        var t = { type: 'invalid', value: e[0], closed: undefined };
        if (e[1]) (t.type = 'string'), (t.closed = !!(e[3] || e[4]));
        else if (e[5]) t.type = 'comment';
        else if (e[6]) (t.type = 'comment'), (t.closed = !!e[7]);
        else if (e[8]) t.type = 'regex';
        else if (e[9]) t.type = 'number';
        else if (e[10]) t.type = 'name';
        else if (e[11]) t.type = 'punctuator';
        else if (e[12]) t.type = 'whitespace';
        return t;
      };
    },
    2332: function (e, t, r) {
      'use strict';
      const s = r(2037);
      const i = r(419);
      const n = process.env;
      let a;
      if (i('no-color') || i('no-colors') || i('color=false')) {
        a = false;
      } else if (
        i('color') ||
        i('colors') ||
        i('color=true') ||
        i('color=always')
      ) {
        a = true;
      }
      if ('FORCE_COLOR' in n) {
        a = n.FORCE_COLOR.length === 0 || parseInt(n.FORCE_COLOR, 10) !== 0;
      }
      function translateLevel(e) {
        if (e === 0) {
          return false;
        }
        return { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
      }
      function supportsColor(e) {
        if (a === false) {
          return 0;
        }
        if (i('color=16m') || i('color=full') || i('color=truecolor')) {
          return 3;
        }
        if (i('color=256')) {
          return 2;
        }
        if (e && !e.isTTY && a !== true) {
          return 0;
        }
        const t = a ? 1 : 0;
        if (process.platform === 'win32') {
          const e = s.release().split('.');
          if (
            Number(process.versions.node.split('.')[0]) >= 8 &&
            Number(e[0]) >= 10 &&
            Number(e[2]) >= 10586
          ) {
            return Number(e[2]) >= 14931 ? 3 : 2;
          }
          return 1;
        }
        if ('CI' in n) {
          if (
            ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(
              (e) => e in n,
            ) ||
            n.CI_NAME === 'codeship'
          ) {
            return 1;
          }
          return t;
        }
        if ('TEAMCITY_VERSION' in n) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(n.TEAMCITY_VERSION)
            ? 1
            : 0;
        }
        if (n.COLORTERM === 'truecolor') {
          return 3;
        }
        if ('TERM_PROGRAM' in n) {
          const e = parseInt((n.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
          switch (n.TERM_PROGRAM) {
            case 'iTerm.app':
              return e >= 3 ? 3 : 2;
            case 'Apple_Terminal':
              return 2;
          }
        }
        if (/-256(color)?$/i.test(n.TERM)) {
          return 2;
        }
        if (
          /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
            n.TERM,
          )
        ) {
          return 1;
        }
        if ('COLORTERM' in n) {
          return 1;
        }
        if (n.TERM === 'dumb') {
          return t;
        }
        return t;
      }
      function getSupportLevel(e) {
        const t = supportsColor(e);
        return translateLevel(t);
      }
      e.exports = {
        supportsColor: getSupportLevel,
        stdout: getSupportLevel(process.stdout),
        stderr: getSupportLevel(process.stderr),
      };
    },
    7860: function (e, t, r) {
      e.exports = r(7188);
    },
    6802: function (e) {
      'use strict';
      let t = null;
      function FastObject(e) {
        if (t !== null && typeof t.property) {
          const e = t;
          t = FastObject.prototype = null;
          return e;
        }
        t = FastObject.prototype = e == null ? Object.create(null) : e;
        return new FastObject();
      }
      FastObject();
      e.exports = function toFastproperties(e) {
        return FastObject(e);
      };
    },
    9491: function (e) {
      'use strict';
      e.exports = require('assert');
    },
    2037: function (e) {
      'use strict';
      e.exports = require('os');
    },
    8135: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.codeFrameColumns = codeFrameColumns;
      t['default'] = _default;
      var s = r(9912);
      var i = _interopRequireWildcard(r(6673), true);
      function _getRequireWildcardCache(e) {
        if (typeof WeakMap !== 'function') return null;
        var t = new WeakMap();
        var r = new WeakMap();
        return (_getRequireWildcardCache = function (e) {
          return e ? r : t;
        })(e);
      }
      function _interopRequireWildcard(e, t) {
        if (!t && e && e.__esModule) {
          return e;
        }
        if (e === null || (typeof e !== 'object' && typeof e !== 'function')) {
          return { default: e };
        }
        var r = _getRequireWildcardCache(t);
        if (r && r.has(e)) {
          return r.get(e);
        }
        var s = {};
        var i = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var n in e) {
          if (n !== 'default' && Object.prototype.hasOwnProperty.call(e, n)) {
            var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
            if (a && (a.get || a.set)) {
              Object.defineProperty(s, n, a);
            } else {
              s[n] = e[n];
            }
          }
        }
        s.default = e;
        if (r) {
          r.set(e, s);
        }
        return s;
      }
      let n = undefined;
      function getChalk(e) {
        if (e) {
          var t;
          (t = n) != null
            ? t
            : (n = new i.default.constructor({ enabled: true, level: 1 }));
          return n;
        }
        return i.default;
      }
      let a = false;
      function getDefs(e) {
        return { gutter: e.grey, marker: e.red.bold, message: e.red.bold };
      }
      const o = /\r\n|[\n\r\u2028\u2029]/;
      function getMarkerLines(e, t, r) {
        const s = Object.assign({ column: 0, line: -1 }, e.start);
        const i = Object.assign({}, s, e.end);
        const { linesAbove: n = 2, linesBelow: a = 3 } = r || {};
        const o = s.line;
        const l = s.column;
        const c = i.line;
        const p = i.column;
        let u = Math.max(o - (n + 1), 0);
        let d = Math.min(t.length, c + a);
        if (o === -1) {
          u = 0;
        }
        if (c === -1) {
          d = t.length;
        }
        const f = c - o;
        const h = {};
        if (f) {
          for (let e = 0; e <= f; e++) {
            const r = e + o;
            if (!l) {
              h[r] = true;
            } else if (e === 0) {
              const e = t[r - 1].length;
              h[r] = [l, e - l + 1];
            } else if (e === f) {
              h[r] = [0, p];
            } else {
              const s = t[r - e].length;
              h[r] = [0, s];
            }
          }
        } else {
          if (l === p) {
            if (l) {
              h[o] = [l, 0];
            } else {
              h[o] = true;
            }
          } else {
            h[o] = [l, p - l];
          }
        }
        return { start: u, end: d, markerLines: h };
      }
      function codeFrameColumns(e, t, r = {}) {
        const i =
          (r.highlightCode || r.forceColor) && (0, s.shouldHighlight)(r);
        const n = getChalk(r.forceColor);
        const a = getDefs(n);
        const maybeHighlight = (e, t) => (i ? e(t) : t);
        const l = e.split(o);
        const { start: c, end: p, markerLines: u } = getMarkerLines(t, l, r);
        const d = t.start && typeof t.start.column === 'number';
        const f = String(p).length;
        const h = i ? (0, s.default)(e, r) : e;
        let y = h
          .split(o, p)
          .slice(c, p)
          .map((e, t) => {
            const s = c + 1 + t;
            const i = ` ${s}`.slice(-f);
            const n = ` ${i} |`;
            const o = u[s];
            const l = !u[s + 1];
            if (o) {
              let t = '';
              if (Array.isArray(o)) {
                const s = e
                  .slice(0, Math.max(o[0] - 1, 0))
                  .replace(/[^\t]/g, ' ');
                const i = o[1] || 1;
                t = [
                  '\n ',
                  maybeHighlight(a.gutter, n.replace(/\d/g, ' ')),
                  ' ',
                  s,
                  maybeHighlight(a.marker, '^').repeat(i),
                ].join('');
                if (l && r.message) {
                  t += ' ' + maybeHighlight(a.message, r.message);
                }
              }
              return [
                maybeHighlight(a.marker, '>'),
                maybeHighlight(a.gutter, n),
                e.length > 0 ? ` ${e}` : '',
                t,
              ].join('');
            } else {
              return ` ${maybeHighlight(a.gutter, n)}${
                e.length > 0 ? ` ${e}` : ''
              }`;
            }
          })
          .join('\n');
        if (r.message && !d) {
          y = `${' '.repeat(f + 1)}${r.message}\n${y}`;
        }
        if (i) {
          return n.reset(y);
        } else {
          return y;
        }
      }
      function _default(e, t, r, s = {}) {
        if (!a) {
          a = true;
          const e =
            'Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.';
          if (process.emitWarning) {
            process.emitWarning(e, 'DeprecationWarning');
          } else {
            const t = new Error(e);
            t.name = 'DeprecationWarning';
            console.warn(new Error(e));
          }
        }
        r = Math.max(r, 0);
        const i = { start: { column: r, line: t } };
        return codeFrameColumns(e, i, s);
      }
    },
    4079: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = void 0;
      var s = r(9491);
      var i = r(4739);
      const {
        callExpression: n,
        cloneNode: a,
        expressionStatement: o,
        identifier: l,
        importDeclaration: c,
        importDefaultSpecifier: p,
        importNamespaceSpecifier: u,
        importSpecifier: d,
        memberExpression: f,
        stringLiteral: h,
        variableDeclaration: y,
        variableDeclarator: m,
      } = i;
      class ImportBuilder {
        constructor(e, t, r) {
          this._statements = [];
          this._resultName = null;
          this._importedSource = void 0;
          this._scope = t;
          this._hub = r;
          this._importedSource = e;
        }
        done() {
          return { statements: this._statements, resultName: this._resultName };
        }
        import() {
          this._statements.push(c([], h(this._importedSource)));
          return this;
        }
        require() {
          this._statements.push(o(n(l('require'), [h(this._importedSource)])));
          return this;
        }
        namespace(e = 'namespace') {
          const t = this._scope.generateUidIdentifier(e);
          const r = this._statements[this._statements.length - 1];
          s(r.type === 'ImportDeclaration');
          s(r.specifiers.length === 0);
          r.specifiers = [u(t)];
          this._resultName = a(t);
          return this;
        }
        default(e) {
          const t = this._scope.generateUidIdentifier(e);
          const r = this._statements[this._statements.length - 1];
          s(r.type === 'ImportDeclaration');
          s(r.specifiers.length === 0);
          r.specifiers = [p(t)];
          this._resultName = a(t);
          return this;
        }
        named(e, t) {
          if (t === 'default') return this.default(e);
          const r = this._scope.generateUidIdentifier(e);
          const i = this._statements[this._statements.length - 1];
          s(i.type === 'ImportDeclaration');
          s(i.specifiers.length === 0);
          i.specifiers = [d(r, l(t))];
          this._resultName = a(r);
          return this;
        }
        var(e) {
          const t = this._scope.generateUidIdentifier(e);
          let r = this._statements[this._statements.length - 1];
          if (r.type !== 'ExpressionStatement') {
            s(this._resultName);
            r = o(this._resultName);
            this._statements.push(r);
          }
          this._statements[this._statements.length - 1] = y('var', [
            m(t, r.expression),
          ]);
          this._resultName = a(t);
          return this;
        }
        defaultInterop() {
          return this._interop(this._hub.addHelper('interopRequireDefault'));
        }
        wildcardInterop() {
          return this._interop(this._hub.addHelper('interopRequireWildcard'));
        }
        _interop(e) {
          const t = this._statements[this._statements.length - 1];
          if (t.type === 'ExpressionStatement') {
            t.expression = n(e, [t.expression]);
          } else if (t.type === 'VariableDeclaration') {
            s(t.declarations.length === 1);
            t.declarations[0].init = n(e, [t.declarations[0].init]);
          } else {
            s.fail('Unexpected type.');
          }
          return this;
        }
        prop(e) {
          const t = this._statements[this._statements.length - 1];
          if (t.type === 'ExpressionStatement') {
            t.expression = f(t.expression, l(e));
          } else if (t.type === 'VariableDeclaration') {
            s(t.declarations.length === 1);
            t.declarations[0].init = f(t.declarations[0].init, l(e));
          } else {
            s.fail('Unexpected type:' + t.type);
          }
          return this;
        }
        read(e) {
          this._resultName = f(this._resultName, l(e));
        }
      }
      t['default'] = ImportBuilder;
    },
    2378: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = void 0;
      var s = r(9491);
      var i = r(4739);
      var n = r(4079);
      var a = r(9898);
      const { numericLiteral: o, sequenceExpression: l } = i;
      class ImportInjector {
        constructor(e, t, r) {
          this._defaultOpts = {
            importedSource: null,
            importedType: 'commonjs',
            importedInterop: 'babel',
            importingInterop: 'babel',
            ensureLiveReference: false,
            ensureNoContext: false,
            importPosition: 'before',
          };
          const s = e.find((e) => e.isProgram());
          this._programPath = s;
          this._programScope = s.scope;
          this._hub = s.hub;
          this._defaultOpts = this._applyDefaults(t, r, true);
        }
        addDefault(e, t) {
          return this.addNamed('default', e, t);
        }
        addNamed(e, t, r) {
          s(typeof e === 'string');
          return this._generateImport(this._applyDefaults(t, r), e);
        }
        addNamespace(e, t) {
          return this._generateImport(this._applyDefaults(e, t), null);
        }
        addSideEffect(e, t) {
          return this._generateImport(this._applyDefaults(e, t), void 0);
        }
        _applyDefaults(e, t, r = false) {
          let i;
          if (typeof e === 'string') {
            i = Object.assign({}, this._defaultOpts, { importedSource: e }, t);
          } else {
            s(!t, 'Unexpected secondary arguments.');
            i = Object.assign({}, this._defaultOpts, e);
          }
          if (!r && t) {
            if (t.nameHint !== undefined) i.nameHint = t.nameHint;
            if (t.blockHoist !== undefined) i.blockHoist = t.blockHoist;
          }
          return i;
        }
        _generateImport(e, t) {
          const r = t === 'default';
          const s = !!t && !r;
          const i = t === null;
          const {
            importedSource: c,
            importedType: p,
            importedInterop: u,
            importingInterop: d,
            ensureLiveReference: f,
            ensureNoContext: h,
            nameHint: y,
            importPosition: m,
            blockHoist: T,
          } = e;
          let S = y || t;
          const x = (0, a.default)(this._programPath);
          const b = x && d === 'node';
          const E = x && d === 'babel';
          if (m === 'after' && !x) {
            throw new Error(
              `"importPosition": "after" is only supported in modules`,
            );
          }
          const P = new n.default(c, this._programScope, this._hub);
          if (p === 'es6') {
            if (!b && !E) {
              throw new Error('Cannot import an ES6 module from CommonJS');
            }
            P.import();
            if (i) {
              P.namespace(y || c);
            } else if (r || s) {
              P.named(S, t);
            }
          } else if (p !== 'commonjs') {
            throw new Error(`Unexpected interopType "${p}"`);
          } else if (u === 'babel') {
            if (b) {
              S = S !== 'default' ? S : c;
              const e = `${c}$es6Default`;
              P.import();
              if (i) {
                P.default(e)
                  .var(S || c)
                  .wildcardInterop();
              } else if (r) {
                if (f) {
                  P.default(e)
                    .var(S || c)
                    .defaultInterop()
                    .read('default');
                } else {
                  P.default(e).var(S).defaultInterop().prop(t);
                }
              } else if (s) {
                P.default(e).read(t);
              }
            } else if (E) {
              P.import();
              if (i) {
                P.namespace(S || c);
              } else if (r || s) {
                P.named(S, t);
              }
            } else {
              P.require();
              if (i) {
                P.var(S || c).wildcardInterop();
              } else if ((r || s) && f) {
                if (r) {
                  S = S !== 'default' ? S : c;
                  P.var(S).read(t);
                  P.defaultInterop();
                } else {
                  P.var(c).read(t);
                }
              } else if (r) {
                P.var(S).defaultInterop().prop(t);
              } else if (s) {
                P.var(S).prop(t);
              }
            }
          } else if (u === 'compiled') {
            if (b) {
              P.import();
              if (i) {
                P.default(S || c);
              } else if (r || s) {
                P.default(c).read(S);
              }
            } else if (E) {
              P.import();
              if (i) {
                P.namespace(S || c);
              } else if (r || s) {
                P.named(S, t);
              }
            } else {
              P.require();
              if (i) {
                P.var(S || c);
              } else if (r || s) {
                if (f) {
                  P.var(c).read(S);
                } else {
                  P.prop(t).var(S);
                }
              }
            }
          } else if (u === 'uncompiled') {
            if (r && f) {
              throw new Error('No live reference for commonjs default');
            }
            if (b) {
              P.import();
              if (i) {
                P.default(S || c);
              } else if (r) {
                P.default(S);
              } else if (s) {
                P.default(c).read(S);
              }
            } else if (E) {
              P.import();
              if (i) {
                P.default(S || c);
              } else if (r) {
                P.default(S);
              } else if (s) {
                P.named(S, t);
              }
            } else {
              P.require();
              if (i) {
                P.var(S || c);
              } else if (r) {
                P.var(S);
              } else if (s) {
                if (f) {
                  P.var(c).read(S);
                } else {
                  P.var(S).prop(t);
                }
              }
            }
          } else {
            throw new Error(`Unknown importedInterop "${u}".`);
          }
          const { statements: g, resultName: A } = P.done();
          this._insertStatements(g, m, T);
          if ((r || s) && h && A.type !== 'Identifier') {
            return l([o(0), A]);
          }
          return A;
        }
        _insertStatements(e, t = 'before', r = 3) {
          const s = this._programPath.get('body');
          if (t === 'after') {
            for (let t = s.length - 1; t >= 0; t--) {
              if (s[t].isImportDeclaration()) {
                s[t].insertAfter(e);
                return;
              }
            }
          } else {
            e.forEach((e) => {
              e._blockHoist = r;
            });
            const t = s.find((e) => {
              const t = e.node._blockHoist;
              return Number.isFinite(t) && t < 4;
            });
            if (t) {
              t.insertBefore(e);
              return;
            }
          }
          this._programPath.unshiftContainer('body', e);
        }
      }
      t['default'] = ImportInjector;
    },
    2408: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      Object.defineProperty(t, 'ImportInjector', {
        enumerable: true,
        get: function () {
          return s.default;
        },
      });
      t.addDefault = addDefault;
      t.addNamed = addNamed;
      t.addNamespace = addNamespace;
      t.addSideEffect = addSideEffect;
      Object.defineProperty(t, 'isModule', {
        enumerable: true,
        get: function () {
          return i.default;
        },
      });
      var s = r(2378);
      var i = r(9898);
      function addDefault(e, t, r) {
        return new s.default(e).addDefault(t, r);
      }
      function addNamed(e, t, r, i) {
        return new s.default(e).addNamed(t, r, i);
      }
      function addNamespace(e, t, r) {
        return new s.default(e).addNamespace(t, r);
      }
      function addSideEffect(e, t, r) {
        return new s.default(e).addSideEffect(t, r);
      }
    },
    9898: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isModule;
      function isModule(e) {
        return e.node.sourceType === 'module';
      }
    },
    6028: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.declare = declare;
      t.declarePreset = void 0;
      const r = {
        assertVersion: (e) => (t) => {
          throwVersionError(t, e.version);
        },
      };
      {
        Object.assign(r, {
          targets: () => () => ({}),
          assumption: () => () => undefined,
        });
      }
      function declare(e) {
        return (t, s, i) => {
          var n;
          let a;
          for (const e of Object.keys(r)) {
            var o;
            if (t[e]) continue;
            (o = a) != null ? o : (a = copyApiObject(t));
            a[e] = r[e](a);
          }
          return e((n = a) != null ? n : t, s || {}, i);
        };
      }
      const s = declare;
      t.declarePreset = s;
      function copyApiObject(e) {
        let t = null;
        if (typeof e.version === 'string' && /^7\./.test(e.version)) {
          t = Object.getPrototypeOf(e);
          if (
            t &&
            (!has(t, 'version') ||
              !has(t, 'transform') ||
              !has(t, 'template') ||
              !has(t, 'types'))
          ) {
            t = null;
          }
        }
        return Object.assign({}, t, e);
      }
      function has(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
      }
      function throwVersionError(e, t) {
        if (typeof e === 'number') {
          if (!Number.isInteger(e)) {
            throw new Error('Expected string or integer value.');
          }
          e = `^${e}.0.0-0`;
        }
        if (typeof e !== 'string') {
          throw new Error('Expected string or integer value.');
        }
        const r = Error.stackTraceLimit;
        if (typeof r === 'number' && r < 25) {
          Error.stackTraceLimit = 25;
        }
        let s;
        if (t.slice(0, 2) === '7.') {
          s = new Error(
            `Requires Babel "^7.0.0-beta.41", but was loaded with "${t}". ` +
              `You'll need to update your @babel/core version.`,
          );
        } else {
          s = new Error(
            `Requires Babel "${e}", but was loaded with "${t}". ` +
              `If you are sure you have a compatible version of @babel/core, ` +
              `it is likely that something in your build process is loading the ` +
              `wrong version. Inspect the stack trace of this error to look for ` +
              `the first entry that doesn't mention "@babel/core" or "babel-core" ` +
              `to see what is calling Babel.`,
          );
        }
        if (typeof r === 'number') {
          Error.stackTraceLimit = r;
        }
        throw Object.assign(s, {
          code: 'BABEL_VERSION_UNSUPPORTED',
          version: t,
          range: e,
        });
      }
    },
    2776: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.readCodePoint = readCodePoint;
      t.readInt = readInt;
      t.readStringContents = readStringContents;
      var r = function isDigit(e) {
        return e >= 48 && e <= 57;
      };
      const s = {
        decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: new Set([46, 88, 95, 120]),
      };
      const i = {
        bin: (e) => e === 48 || e === 49,
        oct: (e) => e >= 48 && e <= 55,
        dec: (e) => e >= 48 && e <= 57,
        hex: (e) =>
          (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102),
      };
      function readStringContents(e, t, r, s, i, n) {
        const a = r;
        const o = s;
        const l = i;
        let c = '';
        let p = null;
        let u = r;
        const { length: d } = t;
        for (;;) {
          if (r >= d) {
            n.unterminated(a, o, l);
            c += t.slice(u, r);
            break;
          }
          const f = t.charCodeAt(r);
          if (isStringEnd(e, f, t, r)) {
            c += t.slice(u, r);
            break;
          }
          if (f === 92) {
            c += t.slice(u, r);
            const a = readEscapedChar(t, r, s, i, e === 'template', n);
            if (a.ch === null && !p) {
              p = { pos: r, lineStart: s, curLine: i };
            } else {
              c += a.ch;
            }
            ({ pos: r, lineStart: s, curLine: i } = a);
            u = r;
          } else if (f === 8232 || f === 8233) {
            ++r;
            ++i;
            s = r;
          } else if (f === 10 || f === 13) {
            if (e === 'template') {
              c += t.slice(u, r) + '\n';
              ++r;
              if (f === 13 && t.charCodeAt(r) === 10) {
                ++r;
              }
              ++i;
              u = s = r;
            } else {
              n.unterminated(a, o, l);
            }
          } else {
            ++r;
          }
        }
        return {
          pos: r,
          str: c,
          firstInvalidLoc: p,
          lineStart: s,
          curLine: i,
          containsInvalid: !!p,
        };
      }
      function isStringEnd(e, t, r, s) {
        if (e === 'template') {
          return t === 96 || (t === 36 && r.charCodeAt(s + 1) === 123);
        }
        return t === (e === 'double' ? 34 : 39);
      }
      function readEscapedChar(e, t, r, s, i, n) {
        const a = !i;
        t++;
        const res = (e) => ({ pos: t, ch: e, lineStart: r, curLine: s });
        const o = e.charCodeAt(t++);
        switch (o) {
          case 110:
            return res('\n');
          case 114:
            return res('\r');
          case 120: {
            let i;
            ({ code: i, pos: t } = readHexChar(e, t, r, s, 2, false, a, n));
            return res(i === null ? null : String.fromCharCode(i));
          }
          case 117: {
            let i;
            ({ code: i, pos: t } = readCodePoint(e, t, r, s, a, n));
            return res(i === null ? null : String.fromCodePoint(i));
          }
          case 116:
            return res('\t');
          case 98:
            return res('\b');
          case 118:
            return res('\v');
          case 102:
            return res('\f');
          case 13:
            if (e.charCodeAt(t) === 10) {
              ++t;
            }
          case 10:
            r = t;
            ++s;
          case 8232:
          case 8233:
            return res('');
          case 56:
          case 57:
            if (i) {
              return res(null);
            } else {
              n.strictNumericEscape(t - 1, r, s);
            }
          default:
            if (o >= 48 && o <= 55) {
              const a = t - 1;
              const o = e.slice(a, t + 2).match(/^[0-7]+/);
              let l = o[0];
              let c = parseInt(l, 8);
              if (c > 255) {
                l = l.slice(0, -1);
                c = parseInt(l, 8);
              }
              t += l.length - 1;
              const p = e.charCodeAt(t);
              if (l !== '0' || p === 56 || p === 57) {
                if (i) {
                  return res(null);
                } else {
                  n.strictNumericEscape(a, r, s);
                }
              }
              return res(String.fromCharCode(c));
            }
            return res(String.fromCharCode(o));
        }
      }
      function readHexChar(e, t, r, s, i, n, a, o) {
        const l = t;
        let c;
        ({ n: c, pos: t } = readInt(e, t, r, s, 16, i, n, false, o, !a));
        if (c === null) {
          if (a) {
            o.invalidEscapeSequence(l, r, s);
          } else {
            t = l - 1;
          }
        }
        return { code: c, pos: t };
      }
      function readInt(e, t, n, a, o, l, c, p, u, d) {
        const f = t;
        const h = o === 16 ? s.hex : s.decBinOct;
        const y = o === 16 ? i.hex : o === 10 ? i.dec : o === 8 ? i.oct : i.bin;
        let m = false;
        let T = 0;
        for (let s = 0, i = l == null ? Infinity : l; s < i; ++s) {
          const s = e.charCodeAt(t);
          let i;
          if (s === 95 && p !== 'bail') {
            const r = e.charCodeAt(t - 1);
            const s = e.charCodeAt(t + 1);
            if (!p) {
              if (d) return { n: null, pos: t };
              u.numericSeparatorInEscapeSequence(t, n, a);
            } else if (Number.isNaN(s) || !y(s) || h.has(r) || h.has(s)) {
              if (d) return { n: null, pos: t };
              u.unexpectedNumericSeparator(t, n, a);
            }
            ++t;
            continue;
          }
          if (s >= 97) {
            i = s - 97 + 10;
          } else if (s >= 65) {
            i = s - 65 + 10;
          } else if (r(s)) {
            i = s - 48;
          } else {
            i = Infinity;
          }
          if (i >= o) {
            if (i <= 9 && d) {
              return { n: null, pos: t };
            } else if (i <= 9 && u.invalidDigit(t, n, a, o)) {
              i = 0;
            } else if (c) {
              i = 0;
              m = true;
            } else {
              break;
            }
          }
          ++t;
          T = T * o + i;
        }
        if (t === f || (l != null && t - f !== l) || m) {
          return { n: null, pos: t };
        }
        return { n: T, pos: t };
      }
      function readCodePoint(e, t, r, s, i, n) {
        const a = e.charCodeAt(t);
        let o;
        if (a === 123) {
          ++t;
          ({ code: o, pos: t } = readHexChar(
            e,
            t,
            r,
            s,
            e.indexOf('}', t) - t,
            true,
            i,
            n,
          ));
          ++t;
          if (o !== null && o > 1114111) {
            if (i) {
              n.invalidCodePoint(t, r, s);
            } else {
              return { code: null, pos: t };
            }
          }
        } else {
          ({ code: o, pos: t } = readHexChar(e, t, r, s, 4, false, i, n));
        }
        return { code: o, pos: t };
      }
    },
    5704: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.isIdentifierChar = isIdentifierChar;
      t.isIdentifierName = isIdentifierName;
      t.isIdentifierStart = isIdentifierStart;
      let r =
        'ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ';
      let s =
        '‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･';
      const i = new RegExp('[' + r + ']');
      const n = new RegExp('[' + r + s + ']');
      r = s = null;
      const a = [
        0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4,
        48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35,
        5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2,
        1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1,
        4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1,
        65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21,
        11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28,
        11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33,
        24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36,
        17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3,
        21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47,
        21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38,
        6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7,
        3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72,
        264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1,
        2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110,
        18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78,
        18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12,
        65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16,
        0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84,
        2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2,
        6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2,
        30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61,
        147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2,
        14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3,
        2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0,
        2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2,
        2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621,
        2467, 541, 1507, 4938, 6, 4191,
      ];
      const o = [
        509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166,
        1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10,
        3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13,
        2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1,
        2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82,
        19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5,
        9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6,
        4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57,
        21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9,
        9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9,
        87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628,
        1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49,
        513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1,
        2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6,
        9, 4759, 9, 787719, 239,
      ];
      function isInAstralSet(e, t) {
        let r = 65536;
        for (let s = 0, i = t.length; s < i; s += 2) {
          r += t[s];
          if (r > e) return false;
          r += t[s + 1];
          if (r >= e) return true;
        }
        return false;
      }
      function isIdentifierStart(e) {
        if (e < 65) return e === 36;
        if (e <= 90) return true;
        if (e < 97) return e === 95;
        if (e <= 122) return true;
        if (e <= 65535) {
          return e >= 170 && i.test(String.fromCharCode(e));
        }
        return isInAstralSet(e, a);
      }
      function isIdentifierChar(e) {
        if (e < 48) return e === 36;
        if (e < 58) return true;
        if (e < 65) return false;
        if (e <= 90) return true;
        if (e < 97) return e === 95;
        if (e <= 122) return true;
        if (e <= 65535) {
          return e >= 170 && n.test(String.fromCharCode(e));
        }
        return isInAstralSet(e, a) || isInAstralSet(e, o);
      }
      function isIdentifierName(e) {
        let t = true;
        for (let r = 0; r < e.length; r++) {
          let s = e.charCodeAt(r);
          if ((s & 64512) === 55296 && r + 1 < e.length) {
            const t = e.charCodeAt(++r);
            if ((t & 64512) === 56320) {
              s = 65536 + ((s & 1023) << 10) + (t & 1023);
            }
          }
          if (t) {
            t = false;
            if (!isIdentifierStart(s)) {
              return false;
            }
          } else if (!isIdentifierChar(s)) {
            return false;
          }
        }
        return !t;
      }
    },
    3442: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      Object.defineProperty(t, 'isIdentifierChar', {
        enumerable: true,
        get: function () {
          return s.isIdentifierChar;
        },
      });
      Object.defineProperty(t, 'isIdentifierName', {
        enumerable: true,
        get: function () {
          return s.isIdentifierName;
        },
      });
      Object.defineProperty(t, 'isIdentifierStart', {
        enumerable: true,
        get: function () {
          return s.isIdentifierStart;
        },
      });
      Object.defineProperty(t, 'isKeyword', {
        enumerable: true,
        get: function () {
          return i.isKeyword;
        },
      });
      Object.defineProperty(t, 'isReservedWord', {
        enumerable: true,
        get: function () {
          return i.isReservedWord;
        },
      });
      Object.defineProperty(t, 'isStrictBindOnlyReservedWord', {
        enumerable: true,
        get: function () {
          return i.isStrictBindOnlyReservedWord;
        },
      });
      Object.defineProperty(t, 'isStrictBindReservedWord', {
        enumerable: true,
        get: function () {
          return i.isStrictBindReservedWord;
        },
      });
      Object.defineProperty(t, 'isStrictReservedWord', {
        enumerable: true,
        get: function () {
          return i.isStrictReservedWord;
        },
      });
      var s = r(5704);
      var i = r(5810);
    },
    5810: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.isKeyword = isKeyword;
      t.isReservedWord = isReservedWord;
      t.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
      t.isStrictBindReservedWord = isStrictBindReservedWord;
      t.isStrictReservedWord = isStrictReservedWord;
      const r = {
        keyword: [
          'break',
          'case',
          'catch',
          'continue',
          'debugger',
          'default',
          'do',
          'else',
          'finally',
          'for',
          'function',
          'if',
          'return',
          'switch',
          'throw',
          'try',
          'var',
          'const',
          'while',
          'with',
          'new',
          'this',
          'super',
          'class',
          'extends',
          'export',
          'import',
          'null',
          'true',
          'false',
          'in',
          'instanceof',
          'typeof',
          'void',
          'delete',
        ],
        strict: [
          'implements',
          'interface',
          'let',
          'package',
          'private',
          'protected',
          'public',
          'static',
          'yield',
        ],
        strictBind: ['eval', 'arguments'],
      };
      const s = new Set(r.keyword);
      const i = new Set(r.strict);
      const n = new Set(r.strictBind);
      function isReservedWord(e, t) {
        return (t && e === 'await') || e === 'enum';
      }
      function isStrictReservedWord(e, t) {
        return isReservedWord(e, t) || i.has(e);
      }
      function isStrictBindOnlyReservedWord(e) {
        return n.has(e);
      }
      function isStrictBindReservedWord(e, t) {
        return isStrictReservedWord(e, t) || isStrictBindOnlyReservedWord(e);
      }
      function isKeyword(e) {
        return s.has(e);
      }
    },
    9912: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = highlight;
      t.shouldHighlight = shouldHighlight;
      var s = r(8629);
      var i = r(3442);
      var n = _interopRequireWildcard(r(6673), true);
      function _getRequireWildcardCache(e) {
        if (typeof WeakMap !== 'function') return null;
        var t = new WeakMap();
        var r = new WeakMap();
        return (_getRequireWildcardCache = function (e) {
          return e ? r : t;
        })(e);
      }
      function _interopRequireWildcard(e, t) {
        if (!t && e && e.__esModule) {
          return e;
        }
        if (e === null || (typeof e !== 'object' && typeof e !== 'function')) {
          return { default: e };
        }
        var r = _getRequireWildcardCache(t);
        if (r && r.has(e)) {
          return r.get(e);
        }
        var s = {};
        var i = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var n in e) {
          if (n !== 'default' && Object.prototype.hasOwnProperty.call(e, n)) {
            var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
            if (a && (a.get || a.set)) {
              Object.defineProperty(s, n, a);
            } else {
              s[n] = e[n];
            }
          }
        }
        s.default = e;
        if (r) {
          r.set(e, s);
        }
        return s;
      }
      const a = new Set(['as', 'async', 'from', 'get', 'of', 'set']);
      function getDefs(e) {
        return {
          keyword: e.cyan,
          capitalized: e.yellow,
          jsxIdentifier: e.yellow,
          punctuator: e.yellow,
          number: e.magenta,
          string: e.green,
          regex: e.magenta,
          comment: e.grey,
          invalid: e.white.bgRed.bold,
        };
      }
      const o = /\r\n|[\n\r\u2028\u2029]/;
      const l = /^[()[\]{}]$/;
      let c;
      {
        const e = /^[a-z][\w-]*$/i;
        const getTokenType = function (t, r, s) {
          if (t.type === 'name') {
            if (
              (0, i.isKeyword)(t.value) ||
              (0, i.isStrictReservedWord)(t.value, true) ||
              a.has(t.value)
            ) {
              return 'keyword';
            }
            if (
              e.test(t.value) &&
              (s[r - 1] === '<' || s.slice(r - 2, r) == '</')
            ) {
              return 'jsxIdentifier';
            }
            if (t.value[0] !== t.value[0].toLowerCase()) {
              return 'capitalized';
            }
          }
          if (t.type === 'punctuator' && l.test(t.value)) {
            return 'bracket';
          }
          if (t.type === 'invalid' && (t.value === '@' || t.value === '#')) {
            return 'punctuator';
          }
          return t.type;
        };
        c = function* (e) {
          let t;
          while ((t = s.default.exec(e))) {
            const r = s.matchToToken(t);
            yield { type: getTokenType(r, t.index, e), value: r.value };
          }
        };
      }
      function highlightTokens(e, t) {
        let r = '';
        for (const { type: s, value: i } of c(t)) {
          const t = e[s];
          if (t) {
            r += i
              .split(o)
              .map((e) => t(e))
              .join('\n');
          } else {
            r += i;
          }
        }
        return r;
      }
      function shouldHighlight(e) {
        return n.default.level > 0 || e.forceColor;
      }
      let p = undefined;
      function getChalk(e) {
        if (e) {
          var t;
          (t = p) != null
            ? t
            : (p = new n.default.constructor({ enabled: true, level: 1 }));
          return p;
        }
        return n.default;
      }
      {
        t.getChalk = (e) => getChalk(e.forceColor);
      }
      function highlight(e, t = {}) {
        if (e !== '' && shouldHighlight(t)) {
          const r = getDefs(getChalk(t.forceColor));
          return highlightTokens(r, e);
        } else {
          return e;
        }
      }
    },
    3033: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      function _objectWithoutPropertiesLoose(e, t) {
        if (e == null) return {};
        var r = {};
        var s = Object.keys(e);
        var i, n;
        for (n = 0; n < s.length; n++) {
          i = s[n];
          if (t.indexOf(i) >= 0) continue;
          r[i] = e[i];
        }
        return r;
      }
      class Position {
        constructor(e, t, r) {
          this.line = void 0;
          this.column = void 0;
          this.index = void 0;
          this.line = e;
          this.column = t;
          this.index = r;
        }
      }
      class SourceLocation {
        constructor(e, t) {
          this.start = void 0;
          this.end = void 0;
          this.filename = void 0;
          this.identifierName = void 0;
          this.start = e;
          this.end = t;
        }
      }
      function createPositionWithColumnOffset(e, t) {
        const { line: r, column: s, index: i } = e;
        return new Position(r, s + t, i + t);
      }
      const r = 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED';
      var s = {
        ImportMetaOutsideModule: {
          message: `import.meta may appear only with 'sourceType: "module"'`,
          code: r,
        },
        ImportOutsideModule: {
          message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
          code: r,
        },
      };
      const i = {
        ArrayPattern: 'array destructuring pattern',
        AssignmentExpression: 'assignment expression',
        AssignmentPattern: 'assignment expression',
        ArrowFunctionExpression: 'arrow function expression',
        ConditionalExpression: 'conditional expression',
        CatchClause: 'catch clause',
        ForOfStatement: 'for-of statement',
        ForInStatement: 'for-in statement',
        ForStatement: 'for-loop',
        FormalParameters: 'function parameter list',
        Identifier: 'identifier',
        ImportSpecifier: 'import specifier',
        ImportDefaultSpecifier: 'import default specifier',
        ImportNamespaceSpecifier: 'import namespace specifier',
        ObjectPattern: 'object destructuring pattern',
        ParenthesizedExpression: 'parenthesized expression',
        RestElement: 'rest element',
        UpdateExpression: {
          true: 'prefix operation',
          false: 'postfix operation',
        },
        VariableDeclarator: 'variable declaration',
        YieldExpression: 'yield expression',
      };
      const toNodeDescription = ({ type: e, prefix: t }) =>
        e === 'UpdateExpression' ? i.UpdateExpression[String(t)] : i[e];
      var n = {
        AccessorIsGenerator: ({ kind: e }) =>
          `A ${e}ter cannot be a generator.`,
        ArgumentsInClass:
          "'arguments' is only allowed in functions and class methods.",
        AsyncFunctionInSingleStatementContext:
          'Async functions can only be declared at the top level or inside a block.',
        AwaitBindingIdentifier:
          "Can not use 'await' as identifier inside an async function.",
        AwaitBindingIdentifierInStaticBlock:
          "Can not use 'await' as identifier inside a static block.",
        AwaitExpressionFormalParameter:
          "'await' is not allowed in async function parameters.",
        AwaitUsingNotInAsyncContext:
          "'await using' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncContext:
          "'await' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncFunction:
          "'await' is only allowed within async functions.",
        BadGetterArity: "A 'get' accessor must not have any formal parameters.",
        BadSetterArity:
          "A 'set' accessor must have exactly one formal parameter.",
        BadSetterRestParameter:
          "A 'set' accessor function argument must not be a rest parameter.",
        ConstructorClassField:
          "Classes may not have a field named 'constructor'.",
        ConstructorClassPrivateField:
          "Classes may not have a private field named '#constructor'.",
        ConstructorIsAccessor: 'Class constructor may not be an accessor.',
        ConstructorIsAsync: "Constructor can't be an async function.",
        ConstructorIsGenerator: "Constructor can't be a generator.",
        DeclarationMissingInitializer: ({ kind: e }) =>
          `Missing initializer in ${e} declaration.`,
        DecoratorArgumentsOutsideParentheses:
          "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
        DecoratorBeforeExport:
          "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
        DecoratorsBeforeAfterExport:
          "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
        DecoratorConstructor:
          "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass:
          "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
        DecoratorSemicolon: 'Decorators must not be followed by a semicolon.',
        DecoratorStaticBlock: "Decorators can't be used with a static block.",
        DeferImportRequiresNamespace:
          'Only `import defer * as x from "./module"` is valid.',
        DeletePrivateField: 'Deleting a private field is not allowed.',
        DestructureNamedImport:
          'ES2015 named imports do not destructure. Use another statement for destructuring after the import.',
        DuplicateConstructor: 'Duplicate constructor in the same class.',
        DuplicateDefaultExport: 'Only one default export allowed per module.',
        DuplicateExport: ({ exportName: e }) =>
          `\`${e}\` has already been exported. Exported identifiers must be unique.`,
        DuplicateProto: 'Redefinition of __proto__ property.',
        DuplicateRegExpFlags: 'Duplicate regular expression flag.',
        DynamicImportPhaseRequiresImportExpressions: ({ phase: e }) =>
          `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`,
        ElementAfterRest: 'Rest element must be last element.',
        EscapedCharNotAnIdentifier: 'Invalid Unicode escape.',
        ExportBindingIsString: ({ localName: e, exportName: t }) =>
          `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`,
        ExportDefaultFromAsIdentifier:
          "'from' is not allowed as an identifier after 'export default'.",
        ForInOfLoopInitializer: ({ type: e }) =>
          `'${
            e === 'ForInStatement' ? 'for-in' : 'for-of'
          }' loop variable declaration may not have an initializer.`,
        ForInUsing: "For-in loop may not start with 'using' declaration.",
        ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
        ForOfLet:
          "The left-hand side of a for-of loop may not start with 'let'.",
        GeneratorInSingleStatementContext:
          'Generators can only be declared at the top level or inside a block.',
        IllegalBreakContinue: ({ type: e }) =>
          `Unsyntactic ${e === 'BreakStatement' ? 'break' : 'continue'}.`,
        IllegalLanguageModeDirective:
          "Illegal 'use strict' directive in function with non-simple parameter list.",
        IllegalReturn: "'return' outside of function.",
        ImportAttributesUseAssert:
          'The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.',
        ImportBindingIsString: ({ importName: e }) =>
          `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${e}" as foo }\`?`,
        ImportCallArgumentTrailingComma:
          'Trailing comma is disallowed inside import(...) arguments.',
        ImportCallArity: ({ maxArgumentCount: e }) =>
          `\`import()\` requires exactly ${
            e === 1 ? 'one argument' : 'one or two arguments'
          }.`,
        ImportCallNotNewExpression: 'Cannot use new with import(...).',
        ImportCallSpreadArgument: '`...` is not allowed in `import()`.',
        ImportJSONBindingNotDefault:
          'A JSON module can only be imported with `default`.',
        ImportReflectionHasAssertion:
          '`import module x` cannot have assertions.',
        ImportReflectionNotBinding:
          'Only `import module x from "./module"` is valid.',
        IncompatibleRegExpUVFlags:
          "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
        InvalidBigIntLiteral: 'Invalid BigIntLiteral.',
        InvalidCodePoint: 'Code point out of bounds.',
        InvalidCoverInitializedName: 'Invalid shorthand property initializer.',
        InvalidDecimal: 'Invalid decimal.',
        InvalidDigit: ({ radix: e }) => `Expected number in radix ${e}.`,
        InvalidEscapeSequence: 'Bad character escape sequence.',
        InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template.',
        InvalidEscapedReservedWord: ({ reservedWord: e }) =>
          `Escape sequence in keyword ${e}.`,
        InvalidIdentifier: ({ identifierName: e }) =>
          `Invalid identifier ${e}.`,
        InvalidLhs: ({ ancestor: e }) =>
          `Invalid left-hand side in ${toNodeDescription(e)}.`,
        InvalidLhsBinding: ({ ancestor: e }) =>
          `Binding invalid left-hand side in ${toNodeDescription(e)}.`,
        InvalidLhsOptionalChaining: ({ ancestor: e }) =>
          `Invalid optional chaining in the left-hand side of ${toNodeDescription(
            e,
          )}.`,
        InvalidNumber: 'Invalid number.',
        InvalidOrMissingExponent:
          "Floating-point numbers require a valid exponent after the 'e'.",
        InvalidOrUnexpectedToken: ({ unexpected: e }) =>
          `Unexpected character '${e}'.`,
        InvalidParenthesizedAssignment:
          'Invalid parenthesized assignment pattern.',
        InvalidPrivateFieldResolution: ({ identifierName: e }) =>
          `Private name #${e} is not defined.`,
        InvalidPropertyBindingPattern: 'Binding member expression.',
        InvalidRecordProperty:
          'Only properties and spread elements are allowed in record definitions.',
        InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
        LabelRedeclaration: ({ labelName: e }) =>
          `Label '${e}' is already declared.`,
        LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
        MalformedRegExpFlags: 'Invalid regular expression flag.',
        MissingClassName: 'A class name is required.',
        MissingEqInAssignment:
          "Only '=' operator can be used for specifying default value.",
        MissingSemicolon: 'Missing semicolon.',
        MissingPlugin: ({ missingPlugin: e }) =>
          `This experimental syntax requires enabling the parser plugin: ${e
            .map((e) => JSON.stringify(e))
            .join(', ')}.`,
        MissingOneOfPlugins: ({ missingPlugin: e }) =>
          `This experimental syntax requires enabling one of the following parser plugin(s): ${e
            .map((e) => JSON.stringify(e))
            .join(', ')}.`,
        MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX.',
        MixingCoalesceWithLogical:
          'Nullish coalescing operator(??) requires parens when mixing with logical operators.',
        ModuleAttributeDifferentFromType:
          'The only accepted module attribute is `type`.',
        ModuleAttributeInvalidValue:
          'Only string literals are allowed as module attribute values.',
        ModuleAttributesWithDuplicateKeys: ({ key: e }) =>
          `Duplicate key "${e}" is not allowed in module attributes.`,
        ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: e }) =>
          `An export name cannot include a lone surrogate, found '\\u${e.toString(
            16,
          )}'.`,
        ModuleExportUndefined: ({ localName: e }) =>
          `Export '${e}' is not defined.`,
        MultipleDefaultsInSwitch: 'Multiple default clauses.',
        NewlineAfterThrow: 'Illegal newline after throw.',
        NoCatchOrFinally: 'Missing catch or finally clause.',
        NumberIdentifier: 'Identifier directly after number.',
        NumericSeparatorInEscapeSequence:
          'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.',
        ObsoleteAwaitStar:
          "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew:
          'Constructors in/after an Optional Chain are not allowed.',
        OptionalChainingNoTemplate:
          'Tagged Template Literals are not allowed in optionalChain.',
        OverrideOnConstructor:
          "'override' modifier cannot appear on a constructor declaration.",
        ParamDupe: 'Argument name clash.',
        PatternHasAccessor: "Object pattern can't contain getter or setter.",
        PatternHasMethod: "Object pattern can't contain methods.",
        PrivateInExpectedIn: ({ identifierName: e }) =>
          `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`,
        PrivateNameRedeclaration: ({ identifierName: e }) =>
          `Duplicate private name #${e}.`,
        RecordExpressionBarIncorrectEndSyntaxType:
          "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionBarIncorrectStartSyntaxType:
          "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionHashIncorrectStartSyntaxType:
          "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        RecordNoProto: "'__proto__' is not allowed in Record expressions.",
        RestTrailingComma: 'Unexpected trailing comma after rest element.',
        SloppyFunction:
          'In non-strict mode code, functions can only be declared at top level or inside a block.',
        SloppyFunctionAnnexB:
          'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.',
        SourcePhaseImportRequiresDefault:
          'Only `import source x from "./module"` is valid.',
        StaticPrototype:
          'Classes may not have static property named prototype.',
        SuperNotAllowed:
          "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super.",
        TrailingDecorator: 'Decorators must be attached to a class element.',
        TupleExpressionBarIncorrectEndSyntaxType:
          "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionBarIncorrectStartSyntaxType:
          "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionHashIncorrectStartSyntaxType:
          "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder.',
        UnexpectedAwaitAfterPipelineBody:
          'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
        UnexpectedDigitAfterHash: 'Unexpected digit after hash token.',
        UnexpectedImportExport:
          "'import' and 'export' may only appear at the top level.",
        UnexpectedKeyword: ({ keyword: e }) => `Unexpected keyword '${e}'.`,
        UnexpectedLeadingDecorator:
          'Leading decorators must be attached to a class declaration.',
        UnexpectedLexicalDeclaration:
          'Lexical declaration cannot appear in a single-statement context.',
        UnexpectedNewTarget:
          '`new.target` can only be used in functions or class properties.',
        UnexpectedNumericSeparator:
          'A numeric separator is only allowed between two digits.',
        UnexpectedPrivateField: 'Unexpected private name.',
        UnexpectedReservedWord: ({ reservedWord: e }) =>
          `Unexpected reserved word '${e}'.`,
        UnexpectedSuper:
          "'super' is only allowed in object methods and classes.",
        UnexpectedToken: ({ expected: e, unexpected: t }) =>
          `Unexpected token${t ? ` '${t}'.` : ''}${
            e ? `, expected "${e}"` : ''
          }`,
        UnexpectedTokenUnaryExponentiation:
          'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.',
        UnexpectedUsingDeclaration:
          'Using declaration cannot appear in the top level when source type is `script`.',
        UnsupportedBind: 'Binding should be performed on object property.',
        UnsupportedDecoratorExport:
          'A decorated export must export a class declaration.',
        UnsupportedDefaultExport:
          'Only expressions, functions or classes are allowed as the `default` export.',
        UnsupportedImport:
          '`import` can only be used in `import()` or `import.meta`.',
        UnsupportedMetaProperty: ({ target: e, onlyValidPropertyName: t }) =>
          `The only valid meta property for ${e} is ${e}.${t}.`,
        UnsupportedParameterDecorator:
          'Decorators cannot be used to decorate parameters.',
        UnsupportedPropertyDecorator:
          'Decorators cannot be used to decorate object literal properties.',
        UnsupportedSuper:
          "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
        UnterminatedComment: 'Unterminated comment.',
        UnterminatedRegExp: 'Unterminated regular expression.',
        UnterminatedString: 'Unterminated string constant.',
        UnterminatedTemplate: 'Unterminated template.',
        UsingDeclarationHasBindingPattern:
          'Using declaration cannot have destructuring patterns.',
        VarRedeclaration: ({ identifierName: e }) =>
          `Identifier '${e}' has already been declared.`,
        YieldBindingIdentifier:
          "Can not use 'yield' as identifier inside a generator.",
        YieldInParameter:
          'Yield expression is not allowed in formal parameters.',
        ZeroDigitNumericSeparator:
          'Numeric separator can not be used after leading 0.',
      };
      var a = {
        StrictDelete: 'Deleting local variable in strict mode.',
        StrictEvalArguments: ({ referenceName: e }) =>
          `Assigning to '${e}' in strict mode.`,
        StrictEvalArgumentsBinding: ({ bindingName: e }) =>
          `Binding '${e}' in strict mode.`,
        StrictFunction:
          'In strict mode code, functions can only be declared at top level or inside a block.',
        StrictNumericEscape:
          "The only valid numeric escape in strict mode is '\\0'.",
        StrictOctalLiteral:
          'Legacy octal literals are not allowed in strict mode.',
        StrictWith: "'with' in strict mode.",
      };
      const o = new Set([
        'ArrowFunctionExpression',
        'AssignmentExpression',
        'ConditionalExpression',
        'YieldExpression',
      ]);
      var l = {
        PipeBodyIsTighter:
          'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.',
        PipeTopicRequiresHackPipes:
          'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
        PipeTopicUnbound:
          'Topic reference is unbound; it must be inside a pipe body.',
        PipeTopicUnconfiguredToken: ({ token: e }) =>
          `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`,
        PipeTopicUnused:
          'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.',
        PipeUnparenthesizedBody: ({ type: e }) =>
          `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription(
            { type: e },
          )}; please wrap it in parentheses.`,
        PipelineBodyNoArrow:
          'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
        PipelineBodySequenceExpression:
          'Pipeline body may not be a comma-separated sequence expression.',
        PipelineHeadSequenceExpression:
          'Pipeline head should not be a comma-separated sequence expression.',
        PipelineTopicUnused:
          'Pipeline is in topic style but does not use topic reference.',
        PrimaryTopicNotAllowed:
          'Topic reference was used in a lexical context without topic binding.',
        PrimaryTopicRequiresSmartPipeline:
          'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      };
      const c = ['toMessage'],
        p = ['message'];
      function defineHidden(e, t, r) {
        Object.defineProperty(e, t, {
          enumerable: false,
          configurable: true,
          value: r,
        });
      }
      function toParseErrorConstructor(e) {
        let { toMessage: t } = e,
          r = _objectWithoutPropertiesLoose(e, c);
        return function constructor({ loc: e, details: s }) {
          const i = new SyntaxError();
          Object.assign(i, r, { loc: e, pos: e.index });
          if ('missingPlugin' in s) {
            Object.assign(i, { missingPlugin: s.missingPlugin });
          }
          defineHidden(i, 'clone', function clone(t = {}) {
            var r;
            const {
              line: i,
              column: n,
              index: a,
            } = (r = t.loc) != null ? r : e;
            return constructor({
              loc: new Position(i, n, a),
              details: Object.assign({}, s, t.details),
            });
          });
          defineHidden(i, 'details', s);
          Object.defineProperty(i, 'message', {
            configurable: true,
            get() {
              const r = `${t(s)} (${e.line}:${e.column})`;
              this.message = r;
              return r;
            },
            set(e) {
              Object.defineProperty(this, 'message', {
                value: e,
                writable: true,
              });
            },
          });
          return i;
        };
      }
      function ParseErrorEnum(e, t) {
        if (Array.isArray(e)) {
          return (t) => ParseErrorEnum(t, e[0]);
        }
        const r = {};
        for (const s of Object.keys(e)) {
          const i = e[s];
          const n =
              typeof i === 'string'
                ? { message: () => i }
                : typeof i === 'function'
                ? { message: i }
                : i,
            { message: a } = n,
            o = _objectWithoutPropertiesLoose(n, p);
          const l = typeof a === 'string' ? () => a : a;
          r[s] = toParseErrorConstructor(
            Object.assign(
              {
                code: 'BABEL_PARSER_SYNTAX_ERROR',
                reasonCode: s,
                toMessage: l,
              },
              t ? { syntaxPlugin: t } : {},
              o,
            ),
          );
        }
        return r;
      }
      const u = Object.assign(
        {},
        ParseErrorEnum(s),
        ParseErrorEnum(n),
        ParseErrorEnum(a),
        ParseErrorEnum`pipelineOperator`(l),
      );
      const { defineProperty: d } = Object;
      const toUnenumerable = (e, t) =>
        d(e, t, { enumerable: false, value: e[t] });
      function toESTreeLocation(e) {
        e.loc.start && toUnenumerable(e.loc.start, 'index');
        e.loc.end && toUnenumerable(e.loc.end, 'index');
        return e;
      }
      var estree = (e) =>
        class ESTreeParserMixin extends e {
          parse() {
            const e = toESTreeLocation(super.parse());
            if (this.options.tokens) {
              e.tokens = e.tokens.map(toESTreeLocation);
            }
            return e;
          }
          parseRegExpLiteral({ pattern: e, flags: t }) {
            let r = null;
            try {
              r = new RegExp(e, t);
            } catch (e) {}
            const s = this.estreeParseLiteral(r);
            s.regex = { pattern: e, flags: t };
            return s;
          }
          parseBigIntLiteral(e) {
            let t;
            try {
              t = BigInt(e);
            } catch (e) {
              t = null;
            }
            const r = this.estreeParseLiteral(t);
            r.bigint = String(r.value || e);
            return r;
          }
          parseDecimalLiteral(e) {
            const t = null;
            const r = this.estreeParseLiteral(t);
            r.decimal = String(r.value || e);
            return r;
          }
          estreeParseLiteral(e) {
            return this.parseLiteral(e, 'Literal');
          }
          parseStringLiteral(e) {
            return this.estreeParseLiteral(e);
          }
          parseNumericLiteral(e) {
            return this.estreeParseLiteral(e);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(e) {
            return this.estreeParseLiteral(e);
          }
          directiveToStmt(e) {
            const t = e.value;
            delete e.value;
            t.type = 'Literal';
            t.raw = t.extra.raw;
            t.value = t.extra.expressionValue;
            const r = e;
            r.type = 'ExpressionStatement';
            r.expression = t;
            r.directive = t.extra.rawValue;
            delete t.extra;
            return r;
          }
          initFunction(e, t) {
            super.initFunction(e, t);
            e.expression = false;
          }
          checkDeclaration(e) {
            if (e != null && this.isObjectProperty(e)) {
              this.checkDeclaration(e.value);
            } else {
              super.checkDeclaration(e);
            }
          }
          getObjectOrClassMethodParams(e) {
            return e.value.params;
          }
          isValidDirective(e) {
            var t;
            return (
              e.type === 'ExpressionStatement' &&
              e.expression.type === 'Literal' &&
              typeof e.expression.value === 'string' &&
              !((t = e.expression.extra) != null && t.parenthesized)
            );
          }
          parseBlockBody(e, t, r, s, i) {
            super.parseBlockBody(e, t, r, s, i);
            const n = e.directives.map((e) => this.directiveToStmt(e));
            e.body = n.concat(e.body);
            delete e.directives;
          }
          pushClassMethod(e, t, r, s, i, n) {
            this.parseMethod(t, r, s, i, n, 'ClassMethod', true);
            if (t.typeParameters) {
              t.value.typeParameters = t.typeParameters;
              delete t.typeParameters;
            }
            e.body.push(t);
          }
          parsePrivateName() {
            const e = super.parsePrivateName();
            {
              if (!this.getPluginOption('estree', 'classFeatures')) {
                return e;
              }
            }
            return this.convertPrivateNameToPrivateIdentifier(e);
          }
          convertPrivateNameToPrivateIdentifier(e) {
            const t = super.getPrivateNameSV(e);
            e = e;
            delete e.id;
            e.name = t;
            e.type = 'PrivateIdentifier';
            return e;
          }
          isPrivateName(e) {
            {
              if (!this.getPluginOption('estree', 'classFeatures')) {
                return super.isPrivateName(e);
              }
            }
            return e.type === 'PrivateIdentifier';
          }
          getPrivateNameSV(e) {
            {
              if (!this.getPluginOption('estree', 'classFeatures')) {
                return super.getPrivateNameSV(e);
              }
            }
            return e.name;
          }
          parseLiteral(e, t) {
            const r = super.parseLiteral(e, t);
            r.raw = r.extra.raw;
            delete r.extra;
            return r;
          }
          parseFunctionBody(e, t, r = false) {
            super.parseFunctionBody(e, t, r);
            e.expression = e.body.type !== 'BlockStatement';
          }
          parseMethod(e, t, r, s, i, n, a = false) {
            let o = this.startNode();
            o.kind = e.kind;
            o = super.parseMethod(o, t, r, s, i, n, a);
            o.type = 'FunctionExpression';
            delete o.kind;
            e.value = o;
            if (n === 'ClassPrivateMethod') {
              e.computed = false;
            }
            return this.finishNode(e, 'MethodDefinition');
          }
          parseClassProperty(...e) {
            const t = super.parseClassProperty(...e);
            {
              if (!this.getPluginOption('estree', 'classFeatures')) {
                return t;
              }
            }
            t.type = 'PropertyDefinition';
            return t;
          }
          parseClassPrivateProperty(...e) {
            const t = super.parseClassPrivateProperty(...e);
            {
              if (!this.getPluginOption('estree', 'classFeatures')) {
                return t;
              }
            }
            t.type = 'PropertyDefinition';
            t.computed = false;
            return t;
          }
          parseObjectMethod(e, t, r, s, i) {
            const n = super.parseObjectMethod(e, t, r, s, i);
            if (n) {
              n.type = 'Property';
              if (n.kind === 'method') {
                n.kind = 'init';
              }
              n.shorthand = false;
            }
            return n;
          }
          parseObjectProperty(e, t, r, s) {
            const i = super.parseObjectProperty(e, t, r, s);
            if (i) {
              i.kind = 'init';
              i.type = 'Property';
            }
            return i;
          }
          isValidLVal(e, t, r) {
            return e === 'Property' ? 'value' : super.isValidLVal(e, t, r);
          }
          isAssignable(e, t) {
            if (e != null && this.isObjectProperty(e)) {
              return this.isAssignable(e.value, t);
            }
            return super.isAssignable(e, t);
          }
          toAssignable(e, t = false) {
            if (e != null && this.isObjectProperty(e)) {
              const { key: r, value: s } = e;
              if (this.isPrivateName(r)) {
                this.classScope.usePrivateName(
                  this.getPrivateNameSV(r),
                  r.loc.start,
                );
              }
              this.toAssignable(s, t);
            } else {
              super.toAssignable(e, t);
            }
          }
          toAssignableObjectExpressionProp(e, t, r) {
            if (e.kind === 'get' || e.kind === 'set') {
              this.raise(u.PatternHasAccessor, { at: e.key });
            } else if (e.method) {
              this.raise(u.PatternHasMethod, { at: e.key });
            } else {
              super.toAssignableObjectExpressionProp(e, t, r);
            }
          }
          finishCallExpression(e, t) {
            const r = super.finishCallExpression(e, t);
            if (r.callee.type === 'Import') {
              r.type = 'ImportExpression';
              r.source = r.arguments[0];
              if (
                this.hasPlugin('importAttributes') ||
                this.hasPlugin('importAssertions')
              ) {
                var s, i;
                r.options = (s = r.arguments[1]) != null ? s : null;
                r.attributes = (i = r.arguments[1]) != null ? i : null;
              }
              delete r.arguments;
              delete r.callee;
            }
            return r;
          }
          toReferencedArguments(e) {
            if (e.type === 'ImportExpression') {
              return;
            }
            super.toReferencedArguments(e);
          }
          parseExport(e, t) {
            const r = this.state.lastTokStartLoc;
            const s = super.parseExport(e, t);
            switch (s.type) {
              case 'ExportAllDeclaration':
                s.exported = null;
                break;
              case 'ExportNamedDeclaration':
                if (
                  s.specifiers.length === 1 &&
                  s.specifiers[0].type === 'ExportNamespaceSpecifier'
                ) {
                  s.type = 'ExportAllDeclaration';
                  s.exported = s.specifiers[0].exported;
                  delete s.specifiers;
                }
              case 'ExportDefaultDeclaration':
                {
                  var i;
                  const { declaration: e } = s;
                  if (
                    (e == null ? void 0 : e.type) === 'ClassDeclaration' &&
                    ((i = e.decorators) == null ? void 0 : i.length) > 0 &&
                    e.start === s.start
                  ) {
                    this.resetStartLocation(s, r);
                  }
                }
                break;
            }
            return s;
          }
          parseSubscript(e, t, r, s) {
            const i = super.parseSubscript(e, t, r, s);
            if (s.optionalChainMember) {
              if (
                i.type === 'OptionalMemberExpression' ||
                i.type === 'OptionalCallExpression'
              ) {
                i.type = i.type.substring(8);
              }
              if (s.stop) {
                const e = this.startNodeAtNode(i);
                e.expression = i;
                return this.finishNode(e, 'ChainExpression');
              }
            } else if (
              i.type === 'MemberExpression' ||
              i.type === 'CallExpression'
            ) {
              i.optional = false;
            }
            return i;
          }
          isOptionalMemberExpression(e) {
            if (e.type === 'ChainExpression') {
              return e.expression.type === 'MemberExpression';
            }
            return super.isOptionalMemberExpression(e);
          }
          hasPropertyAsPrivateName(e) {
            if (e.type === 'ChainExpression') {
              e = e.expression;
            }
            return super.hasPropertyAsPrivateName(e);
          }
          isObjectProperty(e) {
            return e.type === 'Property' && e.kind === 'init' && !e.method;
          }
          isObjectMethod(e) {
            return e.method || e.kind === 'get' || e.kind === 'set';
          }
          finishNodeAt(e, t, r) {
            return toESTreeLocation(super.finishNodeAt(e, t, r));
          }
          resetStartLocation(e, t) {
            super.resetStartLocation(e, t);
            toESTreeLocation(e);
          }
          resetEndLocation(e, t = this.state.lastTokEndLoc) {
            super.resetEndLocation(e, t);
            toESTreeLocation(e);
          }
        };
      class TokContext {
        constructor(e, t) {
          this.token = void 0;
          this.preserveSpace = void 0;
          this.token = e;
          this.preserveSpace = !!t;
        }
      }
      const f = {
        brace: new TokContext('{'),
        j_oTag: new TokContext('<tag'),
        j_cTag: new TokContext('</tag'),
        j_expr: new TokContext('<tag>...</tag>', true),
      };
      {
        f.template = new TokContext('`', true);
      }
      const h = true;
      const y = true;
      const m = true;
      const T = true;
      const S = true;
      const x = true;
      class ExportedTokenType {
        constructor(e, t = {}) {
          this.label = void 0;
          this.keyword = void 0;
          this.beforeExpr = void 0;
          this.startsExpr = void 0;
          this.rightAssociative = void 0;
          this.isLoop = void 0;
          this.isAssign = void 0;
          this.prefix = void 0;
          this.postfix = void 0;
          this.binop = void 0;
          this.label = e;
          this.keyword = t.keyword;
          this.beforeExpr = !!t.beforeExpr;
          this.startsExpr = !!t.startsExpr;
          this.rightAssociative = !!t.rightAssociative;
          this.isLoop = !!t.isLoop;
          this.isAssign = !!t.isAssign;
          this.prefix = !!t.prefix;
          this.postfix = !!t.postfix;
          this.binop = t.binop != null ? t.binop : null;
          {
            this.updateContext = null;
          }
        }
      }
      const b = new Map();
      function createKeyword(e, t = {}) {
        t.keyword = e;
        const r = createToken(e, t);
        b.set(e, r);
        return r;
      }
      function createBinop(e, t) {
        return createToken(e, { beforeExpr: h, binop: t });
      }
      let E = -1;
      const P = [];
      const g = [];
      const A = [];
      const v = [];
      const I = [];
      const w = [];
      function createToken(e, t = {}) {
        var r, s, i, n;
        ++E;
        g.push(e);
        A.push((r = t.binop) != null ? r : -1);
        v.push((s = t.beforeExpr) != null ? s : false);
        I.push((i = t.startsExpr) != null ? i : false);
        w.push((n = t.prefix) != null ? n : false);
        P.push(new ExportedTokenType(e, t));
        return E;
      }
      function createKeywordLike(e, t = {}) {
        var r, s, i, n;
        ++E;
        b.set(e, E);
        g.push(e);
        A.push((r = t.binop) != null ? r : -1);
        v.push((s = t.beforeExpr) != null ? s : false);
        I.push((i = t.startsExpr) != null ? i : false);
        w.push((n = t.prefix) != null ? n : false);
        P.push(new ExportedTokenType('name', t));
        return E;
      }
      const N = {
        bracketL: createToken('[', { beforeExpr: h, startsExpr: y }),
        bracketHashL: createToken('#[', { beforeExpr: h, startsExpr: y }),
        bracketBarL: createToken('[|', { beforeExpr: h, startsExpr: y }),
        bracketR: createToken(']'),
        bracketBarR: createToken('|]'),
        braceL: createToken('{', { beforeExpr: h, startsExpr: y }),
        braceBarL: createToken('{|', { beforeExpr: h, startsExpr: y }),
        braceHashL: createToken('#{', { beforeExpr: h, startsExpr: y }),
        braceR: createToken('}'),
        braceBarR: createToken('|}'),
        parenL: createToken('(', { beforeExpr: h, startsExpr: y }),
        parenR: createToken(')'),
        comma: createToken(',', { beforeExpr: h }),
        semi: createToken(';', { beforeExpr: h }),
        colon: createToken(':', { beforeExpr: h }),
        doubleColon: createToken('::', { beforeExpr: h }),
        dot: createToken('.'),
        question: createToken('?', { beforeExpr: h }),
        questionDot: createToken('?.'),
        arrow: createToken('=>', { beforeExpr: h }),
        template: createToken('template'),
        ellipsis: createToken('...', { beforeExpr: h }),
        backQuote: createToken('`', { startsExpr: y }),
        dollarBraceL: createToken('${', { beforeExpr: h, startsExpr: y }),
        templateTail: createToken('...`', { startsExpr: y }),
        templateNonTail: createToken('...${', { beforeExpr: h, startsExpr: y }),
        at: createToken('@'),
        hash: createToken('#', { startsExpr: y }),
        interpreterDirective: createToken('#!...'),
        eq: createToken('=', { beforeExpr: h, isAssign: T }),
        assign: createToken('_=', { beforeExpr: h, isAssign: T }),
        slashAssign: createToken('_=', { beforeExpr: h, isAssign: T }),
        xorAssign: createToken('_=', { beforeExpr: h, isAssign: T }),
        moduloAssign: createToken('_=', { beforeExpr: h, isAssign: T }),
        incDec: createToken('++/--', { prefix: S, postfix: x, startsExpr: y }),
        bang: createToken('!', { beforeExpr: h, prefix: S, startsExpr: y }),
        tilde: createToken('~', { beforeExpr: h, prefix: S, startsExpr: y }),
        doubleCaret: createToken('^^', { startsExpr: y }),
        doubleAt: createToken('@@', { startsExpr: y }),
        pipeline: createBinop('|>', 0),
        nullishCoalescing: createBinop('??', 1),
        logicalOR: createBinop('||', 1),
        logicalAND: createBinop('&&', 2),
        bitwiseOR: createBinop('|', 3),
        bitwiseXOR: createBinop('^', 4),
        bitwiseAND: createBinop('&', 5),
        equality: createBinop('==/!=/===/!==', 6),
        lt: createBinop('</>/<=/>=', 7),
        gt: createBinop('</>/<=/>=', 7),
        relational: createBinop('</>/<=/>=', 7),
        bitShift: createBinop('<</>>/>>>', 8),
        bitShiftL: createBinop('<</>>/>>>', 8),
        bitShiftR: createBinop('<</>>/>>>', 8),
        plusMin: createToken('+/-', {
          beforeExpr: h,
          binop: 9,
          prefix: S,
          startsExpr: y,
        }),
        modulo: createToken('%', { binop: 10, startsExpr: y }),
        star: createToken('*', { binop: 10 }),
        slash: createBinop('/', 10),
        exponent: createToken('**', {
          beforeExpr: h,
          binop: 11,
          rightAssociative: true,
        }),
        _in: createKeyword('in', { beforeExpr: h, binop: 7 }),
        _instanceof: createKeyword('instanceof', { beforeExpr: h, binop: 7 }),
        _break: createKeyword('break'),
        _case: createKeyword('case', { beforeExpr: h }),
        _catch: createKeyword('catch'),
        _continue: createKeyword('continue'),
        _debugger: createKeyword('debugger'),
        _default: createKeyword('default', { beforeExpr: h }),
        _else: createKeyword('else', { beforeExpr: h }),
        _finally: createKeyword('finally'),
        _function: createKeyword('function', { startsExpr: y }),
        _if: createKeyword('if'),
        _return: createKeyword('return', { beforeExpr: h }),
        _switch: createKeyword('switch'),
        _throw: createKeyword('throw', {
          beforeExpr: h,
          prefix: S,
          startsExpr: y,
        }),
        _try: createKeyword('try'),
        _var: createKeyword('var'),
        _const: createKeyword('const'),
        _with: createKeyword('with'),
        _new: createKeyword('new', { beforeExpr: h, startsExpr: y }),
        _this: createKeyword('this', { startsExpr: y }),
        _super: createKeyword('super', { startsExpr: y }),
        _class: createKeyword('class', { startsExpr: y }),
        _extends: createKeyword('extends', { beforeExpr: h }),
        _export: createKeyword('export'),
        _import: createKeyword('import', { startsExpr: y }),
        _null: createKeyword('null', { startsExpr: y }),
        _true: createKeyword('true', { startsExpr: y }),
        _false: createKeyword('false', { startsExpr: y }),
        _typeof: createKeyword('typeof', {
          beforeExpr: h,
          prefix: S,
          startsExpr: y,
        }),
        _void: createKeyword('void', {
          beforeExpr: h,
          prefix: S,
          startsExpr: y,
        }),
        _delete: createKeyword('delete', {
          beforeExpr: h,
          prefix: S,
          startsExpr: y,
        }),
        _do: createKeyword('do', { isLoop: m, beforeExpr: h }),
        _for: createKeyword('for', { isLoop: m }),
        _while: createKeyword('while', { isLoop: m }),
        _as: createKeywordLike('as', { startsExpr: y }),
        _assert: createKeywordLike('assert', { startsExpr: y }),
        _async: createKeywordLike('async', { startsExpr: y }),
        _await: createKeywordLike('await', { startsExpr: y }),
        _defer: createKeywordLike('defer', { startsExpr: y }),
        _from: createKeywordLike('from', { startsExpr: y }),
        _get: createKeywordLike('get', { startsExpr: y }),
        _let: createKeywordLike('let', { startsExpr: y }),
        _meta: createKeywordLike('meta', { startsExpr: y }),
        _of: createKeywordLike('of', { startsExpr: y }),
        _sent: createKeywordLike('sent', { startsExpr: y }),
        _set: createKeywordLike('set', { startsExpr: y }),
        _source: createKeywordLike('source', { startsExpr: y }),
        _static: createKeywordLike('static', { startsExpr: y }),
        _using: createKeywordLike('using', { startsExpr: y }),
        _yield: createKeywordLike('yield', { startsExpr: y }),
        _asserts: createKeywordLike('asserts', { startsExpr: y }),
        _checks: createKeywordLike('checks', { startsExpr: y }),
        _exports: createKeywordLike('exports', { startsExpr: y }),
        _global: createKeywordLike('global', { startsExpr: y }),
        _implements: createKeywordLike('implements', { startsExpr: y }),
        _intrinsic: createKeywordLike('intrinsic', { startsExpr: y }),
        _infer: createKeywordLike('infer', { startsExpr: y }),
        _is: createKeywordLike('is', { startsExpr: y }),
        _mixins: createKeywordLike('mixins', { startsExpr: y }),
        _proto: createKeywordLike('proto', { startsExpr: y }),
        _require: createKeywordLike('require', { startsExpr: y }),
        _satisfies: createKeywordLike('satisfies', { startsExpr: y }),
        _keyof: createKeywordLike('keyof', { startsExpr: y }),
        _readonly: createKeywordLike('readonly', { startsExpr: y }),
        _unique: createKeywordLike('unique', { startsExpr: y }),
        _abstract: createKeywordLike('abstract', { startsExpr: y }),
        _declare: createKeywordLike('declare', { startsExpr: y }),
        _enum: createKeywordLike('enum', { startsExpr: y }),
        _module: createKeywordLike('module', { startsExpr: y }),
        _namespace: createKeywordLike('namespace', { startsExpr: y }),
        _interface: createKeywordLike('interface', { startsExpr: y }),
        _type: createKeywordLike('type', { startsExpr: y }),
        _opaque: createKeywordLike('opaque', { startsExpr: y }),
        name: createToken('name', { startsExpr: y }),
        string: createToken('string', { startsExpr: y }),
        num: createToken('num', { startsExpr: y }),
        bigint: createToken('bigint', { startsExpr: y }),
        decimal: createToken('decimal', { startsExpr: y }),
        regexp: createToken('regexp', { startsExpr: y }),
        privateName: createToken('#name', { startsExpr: y }),
        eof: createToken('eof'),
        jsxName: createToken('jsxName'),
        jsxText: createToken('jsxText', { beforeExpr: true }),
        jsxTagStart: createToken('jsxTagStart', { startsExpr: true }),
        jsxTagEnd: createToken('jsxTagEnd'),
        placeholder: createToken('%%', { startsExpr: true }),
      };
      function tokenIsIdentifier(e) {
        return e >= 93 && e <= 132;
      }
      function tokenKeywordOrIdentifierIsKeyword(e) {
        return e <= 92;
      }
      function tokenIsKeywordOrIdentifier(e) {
        return e >= 58 && e <= 132;
      }
      function tokenIsLiteralPropertyName(e) {
        return e >= 58 && e <= 136;
      }
      function tokenComesBeforeExpression(e) {
        return v[e];
      }
      function tokenCanStartExpression(e) {
        return I[e];
      }
      function tokenIsAssignment(e) {
        return e >= 29 && e <= 33;
      }
      function tokenIsFlowInterfaceOrTypeOrOpaque(e) {
        return e >= 129 && e <= 131;
      }
      function tokenIsLoop(e) {
        return e >= 90 && e <= 92;
      }
      function tokenIsKeyword(e) {
        return e >= 58 && e <= 92;
      }
      function tokenIsOperator(e) {
        return e >= 39 && e <= 59;
      }
      function tokenIsPostfix(e) {
        return e === 34;
      }
      function tokenIsPrefix(e) {
        return w[e];
      }
      function tokenIsTSTypeOperator(e) {
        return e >= 121 && e <= 123;
      }
      function tokenIsTSDeclarationStart(e) {
        return e >= 124 && e <= 130;
      }
      function tokenLabelName(e) {
        return g[e];
      }
      function tokenOperatorPrecedence(e) {
        return A[e];
      }
      function tokenIsRightAssociative(e) {
        return e === 57;
      }
      function tokenIsTemplate(e) {
        return e >= 24 && e <= 25;
      }
      function getExportedToken(e) {
        return P[e];
      }
      {
        P[8].updateContext = (e) => {
          e.pop();
        };
        P[5].updateContext =
          P[7].updateContext =
          P[23].updateContext =
            (e) => {
              e.push(f.brace);
            };
        P[22].updateContext = (e) => {
          if (e[e.length - 1] === f.template) {
            e.pop();
          } else {
            e.push(f.template);
          }
        };
        P[142].updateContext = (e) => {
          e.push(f.j_expr, f.j_oTag);
        };
      }
      let O =
        'ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ';
      let C =
        '‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･';
      const D = new RegExp('[' + O + ']');
      const k = new RegExp('[' + O + C + ']');
      O = C = null;
      const L = [
        0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4,
        48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35,
        5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2,
        1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1,
        4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1,
        65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21,
        11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28,
        11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33,
        24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36,
        17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3,
        21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47,
        21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38,
        6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7,
        3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72,
        264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1,
        2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110,
        18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78,
        18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12,
        65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16,
        0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84,
        2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2,
        6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2,
        30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61,
        147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2,
        14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3,
        2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0,
        2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2,
        2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621,
        2467, 541, 1507, 4938, 6, 4191,
      ];
      const M = [
        509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166,
        1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10,
        3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13,
        2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1,
        2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82,
        19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5,
        9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6,
        4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57,
        21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9,
        9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9,
        87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628,
        1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49,
        513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1,
        2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6,
        9, 4759, 9, 787719, 239,
      ];
      function isInAstralSet(e, t) {
        let r = 65536;
        for (let s = 0, i = t.length; s < i; s += 2) {
          r += t[s];
          if (r > e) return false;
          r += t[s + 1];
          if (r >= e) return true;
        }
        return false;
      }
      function isIdentifierStart(e) {
        if (e < 65) return e === 36;
        if (e <= 90) return true;
        if (e < 97) return e === 95;
        if (e <= 122) return true;
        if (e <= 65535) {
          return e >= 170 && D.test(String.fromCharCode(e));
        }
        return isInAstralSet(e, L);
      }
      function isIdentifierChar(e) {
        if (e < 48) return e === 36;
        if (e < 58) return true;
        if (e < 65) return false;
        if (e <= 90) return true;
        if (e < 97) return e === 95;
        if (e <= 122) return true;
        if (e <= 65535) {
          return e >= 170 && k.test(String.fromCharCode(e));
        }
        return isInAstralSet(e, L) || isInAstralSet(e, M);
      }
      const j = {
        keyword: [
          'break',
          'case',
          'catch',
          'continue',
          'debugger',
          'default',
          'do',
          'else',
          'finally',
          'for',
          'function',
          'if',
          'return',
          'switch',
          'throw',
          'try',
          'var',
          'const',
          'while',
          'with',
          'new',
          'this',
          'super',
          'class',
          'extends',
          'export',
          'import',
          'null',
          'true',
          'false',
          'in',
          'instanceof',
          'typeof',
          'void',
          'delete',
        ],
        strict: [
          'implements',
          'interface',
          'let',
          'package',
          'private',
          'protected',
          'public',
          'static',
          'yield',
        ],
        strictBind: ['eval', 'arguments'],
      };
      const B = new Set(j.keyword);
      const F = new Set(j.strict);
      const _ = new Set(j.strictBind);
      function isReservedWord(e, t) {
        return (t && e === 'await') || e === 'enum';
      }
      function isStrictReservedWord(e, t) {
        return isReservedWord(e, t) || F.has(e);
      }
      function isStrictBindOnlyReservedWord(e) {
        return _.has(e);
      }
      function isStrictBindReservedWord(e, t) {
        return isStrictReservedWord(e, t) || isStrictBindOnlyReservedWord(e);
      }
      function isKeyword(e) {
        return B.has(e);
      }
      function isIteratorStart(e, t, r) {
        return e === 64 && t === 64 && isIdentifierStart(r);
      }
      const R = new Set([
        'break',
        'case',
        'catch',
        'continue',
        'debugger',
        'default',
        'do',
        'else',
        'finally',
        'for',
        'function',
        'if',
        'return',
        'switch',
        'throw',
        'try',
        'var',
        'const',
        'while',
        'with',
        'new',
        'this',
        'super',
        'class',
        'extends',
        'export',
        'import',
        'null',
        'true',
        'false',
        'in',
        'instanceof',
        'typeof',
        'void',
        'delete',
        'implements',
        'interface',
        'let',
        'package',
        'private',
        'protected',
        'public',
        'static',
        'yield',
        'eval',
        'arguments',
        'enum',
        'await',
      ]);
      function canBeReservedWord(e) {
        return R.has(e);
      }
      class Scope {
        constructor(e) {
          this.var = new Set();
          this.lexical = new Set();
          this.functions = new Set();
          this.flags = e;
        }
      }
      class ScopeHandler {
        constructor(e, t) {
          this.parser = void 0;
          this.scopeStack = [];
          this.inModule = void 0;
          this.undefinedExports = new Map();
          this.parser = e;
          this.inModule = t;
        }
        get inTopLevel() {
          return (this.currentScope().flags & 1) > 0;
        }
        get inFunction() {
          return (this.currentVarScopeFlags() & 2) > 0;
        }
        get allowSuper() {
          return (this.currentThisScopeFlags() & 16) > 0;
        }
        get allowDirectSuper() {
          return (this.currentThisScopeFlags() & 32) > 0;
        }
        get inClass() {
          return (this.currentThisScopeFlags() & 64) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
          const e = this.currentThisScopeFlags();
          return (e & 64) > 0 && (e & 2) === 0;
        }
        get inStaticBlock() {
          for (let e = this.scopeStack.length - 1; ; e--) {
            const { flags: t } = this.scopeStack[e];
            if (t & 128) {
              return true;
            }
            if (t & (387 | 64)) {
              return false;
            }
          }
        }
        get inNonArrowFunction() {
          return (this.currentThisScopeFlags() & 2) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(e) {
          return new Scope(e);
        }
        enter(e) {
          this.scopeStack.push(this.createScope(e));
        }
        exit() {
          const e = this.scopeStack.pop();
          return e.flags;
        }
        treatFunctionsAsVarInScope(e) {
          return !!(
            e.flags & (2 | 128) ||
            (!this.parser.inModule && e.flags & 1)
          );
        }
        declareName(e, t, r) {
          let s = this.currentScope();
          if (t & 8 || t & 16) {
            this.checkRedeclarationInScope(s, e, t, r);
            if (t & 16) {
              s.functions.add(e);
            } else {
              s.lexical.add(e);
            }
            if (t & 8) {
              this.maybeExportDefined(s, e);
            }
          } else if (t & 4) {
            for (let i = this.scopeStack.length - 1; i >= 0; --i) {
              s = this.scopeStack[i];
              this.checkRedeclarationInScope(s, e, t, r);
              s.var.add(e);
              this.maybeExportDefined(s, e);
              if (s.flags & 387) break;
            }
          }
          if (this.parser.inModule && s.flags & 1) {
            this.undefinedExports.delete(e);
          }
        }
        maybeExportDefined(e, t) {
          if (this.parser.inModule && e.flags & 1) {
            this.undefinedExports.delete(t);
          }
        }
        checkRedeclarationInScope(e, t, r, s) {
          if (this.isRedeclaredInScope(e, t, r)) {
            this.parser.raise(u.VarRedeclaration, { at: s, identifierName: t });
          }
        }
        isRedeclaredInScope(e, t, r) {
          if (!(r & 1)) return false;
          if (r & 8) {
            return e.lexical.has(t) || e.functions.has(t) || e.var.has(t);
          }
          if (r & 16) {
            return (
              e.lexical.has(t) ||
              (!this.treatFunctionsAsVarInScope(e) && e.var.has(t))
            );
          }
          return (
            (e.lexical.has(t) &&
              !(e.flags & 8 && e.lexical.values().next().value === t)) ||
            (!this.treatFunctionsAsVarInScope(e) && e.functions.has(t))
          );
        }
        checkLocalExport(e) {
          const { name: t } = e;
          const r = this.scopeStack[0];
          if (!r.lexical.has(t) && !r.var.has(t) && !r.functions.has(t)) {
            this.undefinedExports.set(t, e.loc.start);
          }
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
          for (let e = this.scopeStack.length - 1; ; e--) {
            const { flags: t } = this.scopeStack[e];
            if (t & 387) {
              return t;
            }
          }
        }
        currentThisScopeFlags() {
          for (let e = this.scopeStack.length - 1; ; e--) {
            const { flags: t } = this.scopeStack[e];
            if (t & (387 | 64) && !(t & 4)) {
              return t;
            }
          }
        }
      }
      class FlowScope extends Scope {
        constructor(...e) {
          super(...e);
          this.declareFunctions = new Set();
        }
      }
      class FlowScopeHandler extends ScopeHandler {
        createScope(e) {
          return new FlowScope(e);
        }
        declareName(e, t, r) {
          const s = this.currentScope();
          if (t & 2048) {
            this.checkRedeclarationInScope(s, e, t, r);
            this.maybeExportDefined(s, e);
            s.declareFunctions.add(e);
            return;
          }
          super.declareName(e, t, r);
        }
        isRedeclaredInScope(e, t, r) {
          if (super.isRedeclaredInScope(e, t, r)) return true;
          if (r & 2048) {
            return (
              !e.declareFunctions.has(t) &&
              (e.lexical.has(t) || e.functions.has(t))
            );
          }
          return false;
        }
        checkLocalExport(e) {
          if (!this.scopeStack[0].declareFunctions.has(e.name)) {
            super.checkLocalExport(e);
          }
        }
      }
      class BaseParser {
        constructor() {
          this.sawUnambiguousESM = false;
          this.ambiguousScriptDifferentAst = false;
        }
        hasPlugin(e) {
          if (typeof e === 'string') {
            return this.plugins.has(e);
          } else {
            const [t, r] = e;
            if (!this.hasPlugin(t)) {
              return false;
            }
            const s = this.plugins.get(t);
            for (const e of Object.keys(r)) {
              if ((s == null ? void 0 : s[e]) !== r[e]) {
                return false;
              }
            }
            return true;
          }
        }
        getPluginOption(e, t) {
          var r;
          return (r = this.plugins.get(e)) == null ? void 0 : r[t];
        }
      }
      function setTrailingComments(e, t) {
        if (e.trailingComments === undefined) {
          e.trailingComments = t;
        } else {
          e.trailingComments.unshift(...t);
        }
      }
      function setLeadingComments(e, t) {
        if (e.leadingComments === undefined) {
          e.leadingComments = t;
        } else {
          e.leadingComments.unshift(...t);
        }
      }
      function setInnerComments(e, t) {
        if (e.innerComments === undefined) {
          e.innerComments = t;
        } else {
          e.innerComments.unshift(...t);
        }
      }
      function adjustInnerComments(e, t, r) {
        let s = null;
        let i = t.length;
        while (s === null && i > 0) {
          s = t[--i];
        }
        if (s === null || s.start > r.start) {
          setInnerComments(e, r.comments);
        } else {
          setTrailingComments(s, r.comments);
        }
      }
      class CommentsParser extends BaseParser {
        addComment(e) {
          if (this.filename) e.loc.filename = this.filename;
          this.state.comments.push(e);
        }
        processComment(e) {
          const { commentStack: t } = this.state;
          const r = t.length;
          if (r === 0) return;
          let s = r - 1;
          const i = t[s];
          if (i.start === e.end) {
            i.leadingNode = e;
            s--;
          }
          const { start: n } = e;
          for (; s >= 0; s--) {
            const r = t[s];
            const i = r.end;
            if (i > n) {
              r.containingNode = e;
              this.finalizeComment(r);
              t.splice(s, 1);
            } else {
              if (i === n) {
                r.trailingNode = e;
              }
              break;
            }
          }
        }
        finalizeComment(e) {
          const { comments: t } = e;
          if (e.leadingNode !== null || e.trailingNode !== null) {
            if (e.leadingNode !== null) {
              setTrailingComments(e.leadingNode, t);
            }
            if (e.trailingNode !== null) {
              setLeadingComments(e.trailingNode, t);
            }
          } else {
            const { containingNode: r, start: s } = e;
            if (this.input.charCodeAt(s - 1) === 44) {
              switch (r.type) {
                case 'ObjectExpression':
                case 'ObjectPattern':
                case 'RecordExpression':
                  adjustInnerComments(r, r.properties, e);
                  break;
                case 'CallExpression':
                case 'OptionalCallExpression':
                  adjustInnerComments(r, r.arguments, e);
                  break;
                case 'FunctionDeclaration':
                case 'FunctionExpression':
                case 'ArrowFunctionExpression':
                case 'ObjectMethod':
                case 'ClassMethod':
                case 'ClassPrivateMethod':
                  adjustInnerComments(r, r.params, e);
                  break;
                case 'ArrayExpression':
                case 'ArrayPattern':
                case 'TupleExpression':
                  adjustInnerComments(r, r.elements, e);
                  break;
                case 'ExportNamedDeclaration':
                case 'ImportDeclaration':
                  adjustInnerComments(r, r.specifiers, e);
                  break;
                default: {
                  setInnerComments(r, t);
                }
              }
            } else {
              setInnerComments(r, t);
            }
          }
        }
        finalizeRemainingComments() {
          const { commentStack: e } = this.state;
          for (let t = e.length - 1; t >= 0; t--) {
            this.finalizeComment(e[t]);
          }
          this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(e) {
          const { commentStack: t } = this.state;
          const { length: r } = t;
          if (r === 0) return;
          const s = t[r - 1];
          if (s.leadingNode === e) {
            s.leadingNode = null;
          }
        }
        resetPreviousIdentifierLeadingComments(e) {
          const { commentStack: t } = this.state;
          const { length: r } = t;
          if (r === 0) return;
          if (t[r - 1].trailingNode === e) {
            t[r - 1].trailingNode = null;
          } else if (r >= 2 && t[r - 2].trailingNode === e) {
            t[r - 2].trailingNode = null;
          }
        }
        takeSurroundingComments(e, t, r) {
          const { commentStack: s } = this.state;
          const i = s.length;
          if (i === 0) return;
          let n = i - 1;
          for (; n >= 0; n--) {
            const i = s[n];
            const a = i.end;
            const o = i.start;
            if (o === r) {
              i.leadingNode = e;
            } else if (a === t) {
              i.trailingNode = e;
            } else if (a < t) {
              break;
            }
          }
        }
      }
      const K = /\r\n?|[\n\u2028\u2029]/;
      const U = new RegExp(K.source, 'g');
      function isNewLine(e) {
        switch (e) {
          case 10:
          case 13:
          case 8232:
          case 8233:
            return true;
          default:
            return false;
        }
      }
      const V = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      const X = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
      const J = new RegExp(
        '(?=(' +
          X.source +
          '))\\1' +
          /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
        'y',
      );
      function isWhitespace(e) {
        switch (e) {
          case 9:
          case 11:
          case 12:
          case 32:
          case 160:
          case 5760:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }
      class State {
        constructor() {
          this.strict = void 0;
          this.curLine = void 0;
          this.lineStart = void 0;
          this.startLoc = void 0;
          this.endLoc = void 0;
          this.errors = [];
          this.potentialArrowAt = -1;
          this.noArrowAt = [];
          this.noArrowParamsConversionAt = [];
          this.maybeInArrowParameters = false;
          this.inType = false;
          this.noAnonFunctionType = false;
          this.hasFlowComment = false;
          this.isAmbientContext = false;
          this.inAbstractClass = false;
          this.inDisallowConditionalTypesContext = false;
          this.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null,
          };
          this.soloAwait = false;
          this.inFSharpPipelineDirectBody = false;
          this.labels = [];
          this.comments = [];
          this.commentStack = [];
          this.pos = 0;
          this.type = 139;
          this.value = null;
          this.start = 0;
          this.end = 0;
          this.lastTokEndLoc = null;
          this.lastTokStartLoc = null;
          this.lastTokStart = 0;
          this.context = [f.brace];
          this.canStartJSXElement = true;
          this.containsEsc = false;
          this.firstInvalidTemplateEscapePos = null;
          this.strictErrors = new Map();
          this.tokensLength = 0;
        }
        init({ strictMode: e, sourceType: t, startLine: r, startColumn: s }) {
          this.strict =
            e === false ? false : e === true ? true : t === 'module';
          this.curLine = r;
          this.lineStart = -s;
          this.startLoc = this.endLoc = new Position(r, s, 0);
        }
        curPosition() {
          return new Position(
            this.curLine,
            this.pos - this.lineStart,
            this.pos,
          );
        }
        clone(e) {
          const t = new State();
          const r = Object.keys(this);
          for (let s = 0, i = r.length; s < i; s++) {
            const i = r[s];
            let n = this[i];
            if (!e && Array.isArray(n)) {
              n = n.slice();
            }
            t[i] = n;
          }
          return t;
        }
      }
      var Y = function isDigit(e) {
        return e >= 48 && e <= 57;
      };
      const W = {
        decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: new Set([46, 88, 95, 120]),
      };
      const q = {
        bin: (e) => e === 48 || e === 49,
        oct: (e) => e >= 48 && e <= 55,
        dec: (e) => e >= 48 && e <= 57,
        hex: (e) =>
          (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102),
      };
      function readStringContents(e, t, r, s, i, n) {
        const a = r;
        const o = s;
        const l = i;
        let c = '';
        let p = null;
        let u = r;
        const { length: d } = t;
        for (;;) {
          if (r >= d) {
            n.unterminated(a, o, l);
            c += t.slice(u, r);
            break;
          }
          const f = t.charCodeAt(r);
          if (isStringEnd(e, f, t, r)) {
            c += t.slice(u, r);
            break;
          }
          if (f === 92) {
            c += t.slice(u, r);
            const a = readEscapedChar(t, r, s, i, e === 'template', n);
            if (a.ch === null && !p) {
              p = { pos: r, lineStart: s, curLine: i };
            } else {
              c += a.ch;
            }
            ({ pos: r, lineStart: s, curLine: i } = a);
            u = r;
          } else if (f === 8232 || f === 8233) {
            ++r;
            ++i;
            s = r;
          } else if (f === 10 || f === 13) {
            if (e === 'template') {
              c += t.slice(u, r) + '\n';
              ++r;
              if (f === 13 && t.charCodeAt(r) === 10) {
                ++r;
              }
              ++i;
              u = s = r;
            } else {
              n.unterminated(a, o, l);
            }
          } else {
            ++r;
          }
        }
        return {
          pos: r,
          str: c,
          firstInvalidLoc: p,
          lineStart: s,
          curLine: i,
          containsInvalid: !!p,
        };
      }
      function isStringEnd(e, t, r, s) {
        if (e === 'template') {
          return t === 96 || (t === 36 && r.charCodeAt(s + 1) === 123);
        }
        return t === (e === 'double' ? 34 : 39);
      }
      function readEscapedChar(e, t, r, s, i, n) {
        const a = !i;
        t++;
        const res = (e) => ({ pos: t, ch: e, lineStart: r, curLine: s });
        const o = e.charCodeAt(t++);
        switch (o) {
          case 110:
            return res('\n');
          case 114:
            return res('\r');
          case 120: {
            let i;
            ({ code: i, pos: t } = readHexChar(e, t, r, s, 2, false, a, n));
            return res(i === null ? null : String.fromCharCode(i));
          }
          case 117: {
            let i;
            ({ code: i, pos: t } = readCodePoint(e, t, r, s, a, n));
            return res(i === null ? null : String.fromCodePoint(i));
          }
          case 116:
            return res('\t');
          case 98:
            return res('\b');
          case 118:
            return res('\v');
          case 102:
            return res('\f');
          case 13:
            if (e.charCodeAt(t) === 10) {
              ++t;
            }
          case 10:
            r = t;
            ++s;
          case 8232:
          case 8233:
            return res('');
          case 56:
          case 57:
            if (i) {
              return res(null);
            } else {
              n.strictNumericEscape(t - 1, r, s);
            }
          default:
            if (o >= 48 && o <= 55) {
              const a = t - 1;
              const o = e.slice(a, t + 2).match(/^[0-7]+/);
              let l = o[0];
              let c = parseInt(l, 8);
              if (c > 255) {
                l = l.slice(0, -1);
                c = parseInt(l, 8);
              }
              t += l.length - 1;
              const p = e.charCodeAt(t);
              if (l !== '0' || p === 56 || p === 57) {
                if (i) {
                  return res(null);
                } else {
                  n.strictNumericEscape(a, r, s);
                }
              }
              return res(String.fromCharCode(c));
            }
            return res(String.fromCharCode(o));
        }
      }
      function readHexChar(e, t, r, s, i, n, a, o) {
        const l = t;
        let c;
        ({ n: c, pos: t } = readInt(e, t, r, s, 16, i, n, false, o, !a));
        if (c === null) {
          if (a) {
            o.invalidEscapeSequence(l, r, s);
          } else {
            t = l - 1;
          }
        }
        return { code: c, pos: t };
      }
      function readInt(e, t, r, s, i, n, a, o, l, c) {
        const p = t;
        const u = i === 16 ? W.hex : W.decBinOct;
        const d = i === 16 ? q.hex : i === 10 ? q.dec : i === 8 ? q.oct : q.bin;
        let f = false;
        let h = 0;
        for (let p = 0, y = n == null ? Infinity : n; p < y; ++p) {
          const n = e.charCodeAt(t);
          let p;
          if (n === 95 && o !== 'bail') {
            const i = e.charCodeAt(t - 1);
            const n = e.charCodeAt(t + 1);
            if (!o) {
              if (c) return { n: null, pos: t };
              l.numericSeparatorInEscapeSequence(t, r, s);
            } else if (Number.isNaN(n) || !d(n) || u.has(i) || u.has(n)) {
              if (c) return { n: null, pos: t };
              l.unexpectedNumericSeparator(t, r, s);
            }
            ++t;
            continue;
          }
          if (n >= 97) {
            p = n - 97 + 10;
          } else if (n >= 65) {
            p = n - 65 + 10;
          } else if (Y(n)) {
            p = n - 48;
          } else {
            p = Infinity;
          }
          if (p >= i) {
            if (p <= 9 && c) {
              return { n: null, pos: t };
            } else if (p <= 9 && l.invalidDigit(t, r, s, i)) {
              p = 0;
            } else if (a) {
              p = 0;
              f = true;
            } else {
              break;
            }
          }
          ++t;
          h = h * i + p;
        }
        if (t === p || (n != null && t - p !== n) || f) {
          return { n: null, pos: t };
        }
        return { n: h, pos: t };
      }
      function readCodePoint(e, t, r, s, i, n) {
        const a = e.charCodeAt(t);
        let o;
        if (a === 123) {
          ++t;
          ({ code: o, pos: t } = readHexChar(
            e,
            t,
            r,
            s,
            e.indexOf('}', t) - t,
            true,
            i,
            n,
          ));
          ++t;
          if (o !== null && o > 1114111) {
            if (i) {
              n.invalidCodePoint(t, r, s);
            } else {
              return { code: null, pos: t };
            }
          }
        } else {
          ({ code: o, pos: t } = readHexChar(e, t, r, s, 4, false, i, n));
        }
        return { code: o, pos: t };
      }
      const $ = ['at'],
        z = ['at'];
      function buildPosition(e, t, r) {
        return new Position(r, e - t, e);
      }
      const H = new Set([103, 109, 115, 105, 121, 117, 100, 118]);
      class Token {
        constructor(e) {
          this.type = e.type;
          this.value = e.value;
          this.start = e.start;
          this.end = e.end;
          this.loc = new SourceLocation(e.startLoc, e.endLoc);
        }
      }
      class Tokenizer extends CommentsParser {
        constructor(e, t) {
          super();
          this.isLookahead = void 0;
          this.tokens = [];
          this.errorHandlers_readInt = {
            invalidDigit: (e, t, r, s) => {
              if (!this.options.errorRecovery) return false;
              this.raise(u.InvalidDigit, {
                at: buildPosition(e, t, r),
                radix: s,
              });
              return true;
            },
            numericSeparatorInEscapeSequence: this.errorBuilder(
              u.NumericSeparatorInEscapeSequence,
            ),
            unexpectedNumericSeparator: this.errorBuilder(
              u.UnexpectedNumericSeparator,
            ),
          };
          this.errorHandlers_readCodePoint = Object.assign(
            {},
            this.errorHandlers_readInt,
            {
              invalidEscapeSequence: this.errorBuilder(u.InvalidEscapeSequence),
              invalidCodePoint: this.errorBuilder(u.InvalidCodePoint),
            },
          );
          this.errorHandlers_readStringContents_string = Object.assign(
            {},
            this.errorHandlers_readCodePoint,
            {
              strictNumericEscape: (e, t, r) => {
                this.recordStrictModeErrors(u.StrictNumericEscape, {
                  at: buildPosition(e, t, r),
                });
              },
              unterminated: (e, t, r) => {
                throw this.raise(u.UnterminatedString, {
                  at: buildPosition(e - 1, t, r),
                });
              },
            },
          );
          this.errorHandlers_readStringContents_template = Object.assign(
            {},
            this.errorHandlers_readCodePoint,
            {
              strictNumericEscape: this.errorBuilder(u.StrictNumericEscape),
              unterminated: (e, t, r) => {
                throw this.raise(u.UnterminatedTemplate, {
                  at: buildPosition(e, t, r),
                });
              },
            },
          );
          this.state = new State();
          this.state.init(e);
          this.input = t;
          this.length = t.length;
          this.isLookahead = false;
        }
        pushToken(e) {
          this.tokens.length = this.state.tokensLength;
          this.tokens.push(e);
          ++this.state.tokensLength;
        }
        next() {
          this.checkKeywordEscapes();
          if (this.options.tokens) {
            this.pushToken(new Token(this.state));
          }
          this.state.lastTokStart = this.state.start;
          this.state.lastTokEndLoc = this.state.endLoc;
          this.state.lastTokStartLoc = this.state.startLoc;
          this.nextToken();
        }
        eat(e) {
          if (this.match(e)) {
            this.next();
            return true;
          } else {
            return false;
          }
        }
        match(e) {
          return this.state.type === e;
        }
        createLookaheadState(e) {
          return {
            pos: e.pos,
            value: null,
            type: e.type,
            start: e.start,
            end: e.end,
            context: [this.curContext()],
            inType: e.inType,
            startLoc: e.startLoc,
            lastTokEndLoc: e.lastTokEndLoc,
            curLine: e.curLine,
            lineStart: e.lineStart,
            curPosition: e.curPosition,
          };
        }
        lookahead() {
          const e = this.state;
          this.state = this.createLookaheadState(e);
          this.isLookahead = true;
          this.nextToken();
          this.isLookahead = false;
          const t = this.state;
          this.state = e;
          return t;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(e) {
          V.lastIndex = e;
          return V.test(this.input) ? V.lastIndex : e;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        nextTokenInLineStart() {
          return this.nextTokenInLineStartSince(this.state.pos);
        }
        nextTokenInLineStartSince(e) {
          X.lastIndex = e;
          return X.test(this.input) ? X.lastIndex : e;
        }
        lookaheadInLineCharCode() {
          return this.input.charCodeAt(this.nextTokenInLineStart());
        }
        codePointAtPos(e) {
          let t = this.input.charCodeAt(e);
          if ((t & 64512) === 55296 && ++e < this.input.length) {
            const r = this.input.charCodeAt(e);
            if ((r & 64512) === 56320) {
              t = 65536 + ((t & 1023) << 10) + (r & 1023);
            }
          }
          return t;
        }
        setStrict(e) {
          this.state.strict = e;
          if (e) {
            this.state.strictErrors.forEach(([e, t]) =>
              this.raise(e, { at: t }),
            );
            this.state.strictErrors.clear();
          }
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          this.skipSpace();
          this.state.start = this.state.pos;
          if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
          if (this.state.pos >= this.length) {
            this.finishToken(139);
            return;
          }
          this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment(e) {
          let t;
          if (!this.isLookahead) t = this.state.curPosition();
          const r = this.state.pos;
          const s = this.input.indexOf(e, r + 2);
          if (s === -1) {
            throw this.raise(u.UnterminatedComment, {
              at: this.state.curPosition(),
            });
          }
          this.state.pos = s + e.length;
          U.lastIndex = r + 2;
          while (U.test(this.input) && U.lastIndex <= s) {
            ++this.state.curLine;
            this.state.lineStart = U.lastIndex;
          }
          if (this.isLookahead) return;
          const i = {
            type: 'CommentBlock',
            value: this.input.slice(r + 2, s),
            start: r,
            end: s + e.length,
            loc: new SourceLocation(t, this.state.curPosition()),
          };
          if (this.options.tokens) this.pushToken(i);
          return i;
        }
        skipLineComment(e) {
          const t = this.state.pos;
          let r;
          if (!this.isLookahead) r = this.state.curPosition();
          let s = this.input.charCodeAt((this.state.pos += e));
          if (this.state.pos < this.length) {
            while (!isNewLine(s) && ++this.state.pos < this.length) {
              s = this.input.charCodeAt(this.state.pos);
            }
          }
          if (this.isLookahead) return;
          const i = this.state.pos;
          const n = this.input.slice(t + e, i);
          const a = {
            type: 'CommentLine',
            value: n,
            start: t,
            end: i,
            loc: new SourceLocation(r, this.state.curPosition()),
          };
          if (this.options.tokens) this.pushToken(a);
          return a;
        }
        skipSpace() {
          const e = this.state.pos;
          const t = [];
          e: while (this.state.pos < this.length) {
            const r = this.input.charCodeAt(this.state.pos);
            switch (r) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                  ++this.state.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    const e = this.skipBlockComment('*/');
                    if (e !== undefined) {
                      this.addComment(e);
                      if (this.options.attachComment) t.push(e);
                    }
                    break;
                  }
                  case 47: {
                    const e = this.skipLineComment(2);
                    if (e !== undefined) {
                      this.addComment(e);
                      if (this.options.attachComment) t.push(e);
                    }
                    break;
                  }
                  default:
                    break e;
                }
                break;
              default:
                if (isWhitespace(r)) {
                  ++this.state.pos;
                } else if (r === 45 && !this.inModule && this.options.annexB) {
                  const r = this.state.pos;
                  if (
                    this.input.charCodeAt(r + 1) === 45 &&
                    this.input.charCodeAt(r + 2) === 62 &&
                    (e === 0 || this.state.lineStart > e)
                  ) {
                    const e = this.skipLineComment(3);
                    if (e !== undefined) {
                      this.addComment(e);
                      if (this.options.attachComment) t.push(e);
                    }
                  } else {
                    break e;
                  }
                } else if (r === 60 && !this.inModule && this.options.annexB) {
                  const e = this.state.pos;
                  if (
                    this.input.charCodeAt(e + 1) === 33 &&
                    this.input.charCodeAt(e + 2) === 45 &&
                    this.input.charCodeAt(e + 3) === 45
                  ) {
                    const e = this.skipLineComment(4);
                    if (e !== undefined) {
                      this.addComment(e);
                      if (this.options.attachComment) t.push(e);
                    }
                  } else {
                    break e;
                  }
                } else {
                  break e;
                }
            }
          }
          if (t.length > 0) {
            const r = this.state.pos;
            const s = {
              start: e,
              end: r,
              comments: t,
              leadingNode: null,
              trailingNode: null,
              containingNode: null,
            };
            this.state.commentStack.push(s);
          }
        }
        finishToken(e, t) {
          this.state.end = this.state.pos;
          this.state.endLoc = this.state.curPosition();
          const r = this.state.type;
          this.state.type = e;
          this.state.value = t;
          if (!this.isLookahead) {
            this.updateContext(r);
          }
        }
        replaceToken(e) {
          this.state.type = e;
          this.updateContext();
        }
        readToken_numberSign() {
          if (this.state.pos === 0 && this.readToken_interpreter()) {
            return;
          }
          const e = this.state.pos + 1;
          const t = this.codePointAtPos(e);
          if (t >= 48 && t <= 57) {
            throw this.raise(u.UnexpectedDigitAfterHash, {
              at: this.state.curPosition(),
            });
          }
          if (t === 123 || (t === 91 && this.hasPlugin('recordAndTuple'))) {
            this.expectPlugin('recordAndTuple');
            if (
              this.getPluginOption('recordAndTuple', 'syntaxType') === 'bar'
            ) {
              throw this.raise(
                t === 123
                  ? u.RecordExpressionHashIncorrectStartSyntaxType
                  : u.TupleExpressionHashIncorrectStartSyntaxType,
                { at: this.state.curPosition() },
              );
            }
            this.state.pos += 2;
            if (t === 123) {
              this.finishToken(7);
            } else {
              this.finishToken(1);
            }
          } else if (isIdentifierStart(t)) {
            ++this.state.pos;
            this.finishToken(138, this.readWord1(t));
          } else if (t === 92) {
            ++this.state.pos;
            this.finishToken(138, this.readWord1());
          } else {
            this.finishOp(27, 1);
          }
        }
        readToken_dot() {
          const e = this.input.charCodeAt(this.state.pos + 1);
          if (e >= 48 && e <= 57) {
            this.readNumber(true);
            return;
          }
          if (e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
            this.state.pos += 3;
            this.finishToken(21);
          } else {
            ++this.state.pos;
            this.finishToken(16);
          }
        }
        readToken_slash() {
          const e = this.input.charCodeAt(this.state.pos + 1);
          if (e === 61) {
            this.finishOp(31, 2);
          } else {
            this.finishOp(56, 1);
          }
        }
        readToken_interpreter() {
          if (this.state.pos !== 0 || this.length < 2) return false;
          let e = this.input.charCodeAt(this.state.pos + 1);
          if (e !== 33) return false;
          const t = this.state.pos;
          this.state.pos += 1;
          while (!isNewLine(e) && ++this.state.pos < this.length) {
            e = this.input.charCodeAt(this.state.pos);
          }
          const r = this.input.slice(t + 2, this.state.pos);
          this.finishToken(28, r);
          return true;
        }
        readToken_mult_modulo(e) {
          let t = e === 42 ? 55 : 54;
          let r = 1;
          let s = this.input.charCodeAt(this.state.pos + 1);
          if (e === 42 && s === 42) {
            r++;
            s = this.input.charCodeAt(this.state.pos + 2);
            t = 57;
          }
          if (s === 61 && !this.state.inType) {
            r++;
            t = e === 37 ? 33 : 30;
          }
          this.finishOp(t, r);
        }
        readToken_pipe_amp(e) {
          const t = this.input.charCodeAt(this.state.pos + 1);
          if (t === e) {
            if (this.input.charCodeAt(this.state.pos + 2) === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(e === 124 ? 41 : 42, 2);
            }
            return;
          }
          if (e === 124) {
            if (t === 62) {
              this.finishOp(39, 2);
              return;
            }
            if (this.hasPlugin('recordAndTuple') && t === 125) {
              if (
                this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
              ) {
                throw this.raise(u.RecordExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition(),
                });
              }
              this.state.pos += 2;
              this.finishToken(9);
              return;
            }
            if (this.hasPlugin('recordAndTuple') && t === 93) {
              if (
                this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
              ) {
                throw this.raise(u.TupleExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition(),
                });
              }
              this.state.pos += 2;
              this.finishToken(4);
              return;
            }
          }
          if (t === 61) {
            this.finishOp(30, 2);
            return;
          }
          this.finishOp(e === 124 ? 43 : 45, 1);
        }
        readToken_caret() {
          const e = this.input.charCodeAt(this.state.pos + 1);
          if (e === 61 && !this.state.inType) {
            this.finishOp(32, 2);
          } else if (
            e === 94 &&
            this.hasPlugin([
              'pipelineOperator',
              { proposal: 'hack', topicToken: '^^' },
            ])
          ) {
            this.finishOp(37, 2);
            const e = this.input.codePointAt(this.state.pos);
            if (e === 94) {
              this.unexpected();
            }
          } else {
            this.finishOp(44, 1);
          }
        }
        readToken_atSign() {
          const e = this.input.charCodeAt(this.state.pos + 1);
          if (
            e === 64 &&
            this.hasPlugin([
              'pipelineOperator',
              { proposal: 'hack', topicToken: '@@' },
            ])
          ) {
            this.finishOp(38, 2);
          } else {
            this.finishOp(26, 1);
          }
        }
        readToken_plus_min(e) {
          const t = this.input.charCodeAt(this.state.pos + 1);
          if (t === e) {
            this.finishOp(34, 2);
            return;
          }
          if (t === 61) {
            this.finishOp(30, 2);
          } else {
            this.finishOp(53, 1);
          }
        }
        readToken_lt() {
          const { pos: e } = this.state;
          const t = this.input.charCodeAt(e + 1);
          if (t === 60) {
            if (this.input.charCodeAt(e + 2) === 61) {
              this.finishOp(30, 3);
              return;
            }
            this.finishOp(51, 2);
            return;
          }
          if (t === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(47, 1);
        }
        readToken_gt() {
          const { pos: e } = this.state;
          const t = this.input.charCodeAt(e + 1);
          if (t === 62) {
            const t = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(e + t) === 61) {
              this.finishOp(30, t + 1);
              return;
            }
            this.finishOp(52, t);
            return;
          }
          if (t === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(48, 1);
        }
        readToken_eq_excl(e) {
          const t = this.input.charCodeAt(this.state.pos + 1);
          if (t === 61) {
            this.finishOp(
              46,
              this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2,
            );
            return;
          }
          if (e === 61 && t === 62) {
            this.state.pos += 2;
            this.finishToken(19);
            return;
          }
          this.finishOp(e === 61 ? 29 : 35, 1);
        }
        readToken_question() {
          const e = this.input.charCodeAt(this.state.pos + 1);
          const t = this.input.charCodeAt(this.state.pos + 2);
          if (e === 63) {
            if (t === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(40, 2);
            }
          } else if (e === 46 && !(t >= 48 && t <= 57)) {
            this.state.pos += 2;
            this.finishToken(18);
          } else {
            ++this.state.pos;
            this.finishToken(17);
          }
        }
        getTokenFromCode(e) {
          switch (e) {
            case 46:
              this.readToken_dot();
              return;
            case 40:
              ++this.state.pos;
              this.finishToken(10);
              return;
            case 41:
              ++this.state.pos;
              this.finishToken(11);
              return;
            case 59:
              ++this.state.pos;
              this.finishToken(13);
              return;
            case 44:
              ++this.state.pos;
              this.finishToken(12);
              return;
            case 91:
              if (
                this.hasPlugin('recordAndTuple') &&
                this.input.charCodeAt(this.state.pos + 1) === 124
              ) {
                if (
                  this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
                ) {
                  throw this.raise(
                    u.TupleExpressionBarIncorrectStartSyntaxType,
                    { at: this.state.curPosition() },
                  );
                }
                this.state.pos += 2;
                this.finishToken(2);
              } else {
                ++this.state.pos;
                this.finishToken(0);
              }
              return;
            case 93:
              ++this.state.pos;
              this.finishToken(3);
              return;
            case 123:
              if (
                this.hasPlugin('recordAndTuple') &&
                this.input.charCodeAt(this.state.pos + 1) === 124
              ) {
                if (
                  this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
                ) {
                  throw this.raise(
                    u.RecordExpressionBarIncorrectStartSyntaxType,
                    { at: this.state.curPosition() },
                  );
                }
                this.state.pos += 2;
                this.finishToken(6);
              } else {
                ++this.state.pos;
                this.finishToken(5);
              }
              return;
            case 125:
              ++this.state.pos;
              this.finishToken(8);
              return;
            case 58:
              if (
                this.hasPlugin('functionBind') &&
                this.input.charCodeAt(this.state.pos + 1) === 58
              ) {
                this.finishOp(15, 2);
              } else {
                ++this.state.pos;
                this.finishToken(14);
              }
              return;
            case 63:
              this.readToken_question();
              return;
            case 96:
              this.readTemplateToken();
              return;
            case 48: {
              const e = this.input.charCodeAt(this.state.pos + 1);
              if (e === 120 || e === 88) {
                this.readRadixNumber(16);
                return;
              }
              if (e === 111 || e === 79) {
                this.readRadixNumber(8);
                return;
              }
              if (e === 98 || e === 66) {
                this.readRadixNumber(2);
                return;
              }
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              this.readNumber(false);
              return;
            case 34:
            case 39:
              this.readString(e);
              return;
            case 47:
              this.readToken_slash();
              return;
            case 37:
            case 42:
              this.readToken_mult_modulo(e);
              return;
            case 124:
            case 38:
              this.readToken_pipe_amp(e);
              return;
            case 94:
              this.readToken_caret();
              return;
            case 43:
            case 45:
              this.readToken_plus_min(e);
              return;
            case 60:
              this.readToken_lt();
              return;
            case 62:
              this.readToken_gt();
              return;
            case 61:
            case 33:
              this.readToken_eq_excl(e);
              return;
            case 126:
              this.finishOp(36, 1);
              return;
            case 64:
              this.readToken_atSign();
              return;
            case 35:
              this.readToken_numberSign();
              return;
            case 92:
              this.readWord();
              return;
            default:
              if (isIdentifierStart(e)) {
                this.readWord(e);
                return;
              }
          }
          throw this.raise(u.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(e),
          });
        }
        finishOp(e, t) {
          const r = this.input.slice(this.state.pos, this.state.pos + t);
          this.state.pos += t;
          this.finishToken(e, r);
        }
        readRegexp() {
          const e = this.state.startLoc;
          const t = this.state.start + 1;
          let r, s;
          let { pos: i } = this.state;
          for (; ; ++i) {
            if (i >= this.length) {
              throw this.raise(u.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(e, 1),
              });
            }
            const t = this.input.charCodeAt(i);
            if (isNewLine(t)) {
              throw this.raise(u.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(e, 1),
              });
            }
            if (r) {
              r = false;
            } else {
              if (t === 91) {
                s = true;
              } else if (t === 93 && s) {
                s = false;
              } else if (t === 47 && !s) {
                break;
              }
              r = t === 92;
            }
          }
          const n = this.input.slice(t, i);
          ++i;
          let a = '';
          const nextPos = () => createPositionWithColumnOffset(e, i + 2 - t);
          while (i < this.length) {
            const e = this.codePointAtPos(i);
            const t = String.fromCharCode(e);
            if (H.has(e)) {
              if (e === 118) {
                if (a.includes('u')) {
                  this.raise(u.IncompatibleRegExpUVFlags, { at: nextPos() });
                }
              } else if (e === 117) {
                if (a.includes('v')) {
                  this.raise(u.IncompatibleRegExpUVFlags, { at: nextPos() });
                }
              }
              if (a.includes(t)) {
                this.raise(u.DuplicateRegExpFlags, { at: nextPos() });
              }
            } else if (isIdentifierChar(e) || e === 92) {
              this.raise(u.MalformedRegExpFlags, { at: nextPos() });
            } else {
              break;
            }
            ++i;
            a += t;
          }
          this.state.pos = i;
          this.finishToken(137, { pattern: n, flags: a });
        }
        readInt(e, t, r = false, s = true) {
          const { n: i, pos: n } = readInt(
            this.input,
            this.state.pos,
            this.state.lineStart,
            this.state.curLine,
            e,
            t,
            r,
            s,
            this.errorHandlers_readInt,
            false,
          );
          this.state.pos = n;
          return i;
        }
        readRadixNumber(e) {
          const t = this.state.curPosition();
          let r = false;
          this.state.pos += 2;
          const s = this.readInt(e);
          if (s == null) {
            this.raise(u.InvalidDigit, {
              at: createPositionWithColumnOffset(t, 2),
              radix: e,
            });
          }
          const i = this.input.charCodeAt(this.state.pos);
          if (i === 110) {
            ++this.state.pos;
            r = true;
          } else if (i === 109) {
            throw this.raise(u.InvalidDecimal, { at: t });
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(u.NumberIdentifier, {
              at: this.state.curPosition(),
            });
          }
          if (r) {
            const e = this.input
              .slice(t.index, this.state.pos)
              .replace(/[_n]/g, '');
            this.finishToken(135, e);
            return;
          }
          this.finishToken(134, s);
        }
        readNumber(e) {
          const t = this.state.pos;
          const r = this.state.curPosition();
          let s = false;
          let i = false;
          let n = false;
          let a = false;
          let o = false;
          if (!e && this.readInt(10) === null) {
            this.raise(u.InvalidNumber, { at: this.state.curPosition() });
          }
          const l = this.state.pos - t >= 2 && this.input.charCodeAt(t) === 48;
          if (l) {
            const e = this.input.slice(t, this.state.pos);
            this.recordStrictModeErrors(u.StrictOctalLiteral, { at: r });
            if (!this.state.strict) {
              const t = e.indexOf('_');
              if (t > 0) {
                this.raise(u.ZeroDigitNumericSeparator, {
                  at: createPositionWithColumnOffset(r, t),
                });
              }
            }
            o = l && !/[89]/.test(e);
          }
          let c = this.input.charCodeAt(this.state.pos);
          if (c === 46 && !o) {
            ++this.state.pos;
            this.readInt(10);
            s = true;
            c = this.input.charCodeAt(this.state.pos);
          }
          if ((c === 69 || c === 101) && !o) {
            c = this.input.charCodeAt(++this.state.pos);
            if (c === 43 || c === 45) {
              ++this.state.pos;
            }
            if (this.readInt(10) === null) {
              this.raise(u.InvalidOrMissingExponent, { at: r });
            }
            s = true;
            a = true;
            c = this.input.charCodeAt(this.state.pos);
          }
          if (c === 110) {
            if (s || l) {
              this.raise(u.InvalidBigIntLiteral, { at: r });
            }
            ++this.state.pos;
            i = true;
          }
          if (c === 109) {
            this.expectPlugin('decimal', this.state.curPosition());
            if (a || l) {
              this.raise(u.InvalidDecimal, { at: r });
            }
            ++this.state.pos;
            n = true;
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(u.NumberIdentifier, {
              at: this.state.curPosition(),
            });
          }
          const p = this.input.slice(t, this.state.pos).replace(/[_mn]/g, '');
          if (i) {
            this.finishToken(135, p);
            return;
          }
          if (n) {
            this.finishToken(136, p);
            return;
          }
          const d = o ? parseInt(p, 8) : parseFloat(p);
          this.finishToken(134, d);
        }
        readCodePoint(e) {
          const { code: t, pos: r } = readCodePoint(
            this.input,
            this.state.pos,
            this.state.lineStart,
            this.state.curLine,
            e,
            this.errorHandlers_readCodePoint,
          );
          this.state.pos = r;
          return t;
        }
        readString(e) {
          const {
            str: t,
            pos: r,
            curLine: s,
            lineStart: i,
          } = readStringContents(
            e === 34 ? 'double' : 'single',
            this.input,
            this.state.pos + 1,
            this.state.lineStart,
            this.state.curLine,
            this.errorHandlers_readStringContents_string,
          );
          this.state.pos = r + 1;
          this.state.lineStart = i;
          this.state.curLine = s;
          this.finishToken(133, t);
        }
        readTemplateContinuation() {
          if (!this.match(8)) {
            this.unexpected(null, 8);
          }
          this.state.pos--;
          this.readTemplateToken();
        }
        readTemplateToken() {
          const e = this.input[this.state.pos];
          const {
            str: t,
            firstInvalidLoc: r,
            pos: s,
            curLine: i,
            lineStart: n,
          } = readStringContents(
            'template',
            this.input,
            this.state.pos + 1,
            this.state.lineStart,
            this.state.curLine,
            this.errorHandlers_readStringContents_template,
          );
          this.state.pos = s + 1;
          this.state.lineStart = n;
          this.state.curLine = i;
          if (r) {
            this.state.firstInvalidTemplateEscapePos = new Position(
              r.curLine,
              r.pos - r.lineStart,
              r.pos,
            );
          }
          if (this.input.codePointAt(s) === 96) {
            this.finishToken(24, r ? null : e + t + '`');
          } else {
            this.state.pos++;
            this.finishToken(25, r ? null : e + t + '${');
          }
        }
        recordStrictModeErrors(e, { at: t }) {
          const r = t.index;
          if (this.state.strict && !this.state.strictErrors.has(r)) {
            this.raise(e, { at: t });
          } else {
            this.state.strictErrors.set(r, [e, t]);
          }
        }
        readWord1(e) {
          this.state.containsEsc = false;
          let t = '';
          const r = this.state.pos;
          let s = this.state.pos;
          if (e !== undefined) {
            this.state.pos += e <= 65535 ? 1 : 2;
          }
          while (this.state.pos < this.length) {
            const e = this.codePointAtPos(this.state.pos);
            if (isIdentifierChar(e)) {
              this.state.pos += e <= 65535 ? 1 : 2;
            } else if (e === 92) {
              this.state.containsEsc = true;
              t += this.input.slice(s, this.state.pos);
              const e = this.state.curPosition();
              const i =
                this.state.pos === r ? isIdentifierStart : isIdentifierChar;
              if (this.input.charCodeAt(++this.state.pos) !== 117) {
                this.raise(u.MissingUnicodeEscape, {
                  at: this.state.curPosition(),
                });
                s = this.state.pos - 1;
                continue;
              }
              ++this.state.pos;
              const n = this.readCodePoint(true);
              if (n !== null) {
                if (!i(n)) {
                  this.raise(u.EscapedCharNotAnIdentifier, { at: e });
                }
                t += String.fromCodePoint(n);
              }
              s = this.state.pos;
            } else {
              break;
            }
          }
          return t + this.input.slice(s, this.state.pos);
        }
        readWord(e) {
          const t = this.readWord1(e);
          const r = b.get(t);
          if (r !== undefined) {
            this.finishToken(r, tokenLabelName(r));
          } else {
            this.finishToken(132, t);
          }
        }
        checkKeywordEscapes() {
          const { type: e } = this.state;
          if (tokenIsKeyword(e) && this.state.containsEsc) {
            this.raise(u.InvalidEscapedReservedWord, {
              at: this.state.startLoc,
              reservedWord: tokenLabelName(e),
            });
          }
        }
        raise(e, t) {
          const { at: r } = t,
            s = _objectWithoutPropertiesLoose(t, $);
          const i = r instanceof Position ? r : r.loc.start;
          const n = e({ loc: i, details: s });
          if (!this.options.errorRecovery) throw n;
          if (!this.isLookahead) this.state.errors.push(n);
          return n;
        }
        raiseOverwrite(e, t) {
          const { at: r } = t,
            s = _objectWithoutPropertiesLoose(t, z);
          const i = r instanceof Position ? r : r.loc.start;
          const n = i.index;
          const a = this.state.errors;
          for (let t = a.length - 1; t >= 0; t--) {
            const r = a[t];
            if (r.loc.index === n) {
              return (a[t] = e({ loc: i, details: s }));
            }
            if (r.loc.index < n) break;
          }
          return this.raise(e, t);
        }
        updateContext(e) {}
        unexpected(e, t) {
          throw this.raise(u.UnexpectedToken, {
            expected: t ? tokenLabelName(t) : null,
            at: e != null ? e : this.state.startLoc,
          });
        }
        expectPlugin(e, t) {
          if (this.hasPlugin(e)) {
            return true;
          }
          throw this.raise(u.MissingPlugin, {
            at: t != null ? t : this.state.startLoc,
            missingPlugin: [e],
          });
        }
        expectOnePlugin(e) {
          if (!e.some((e) => this.hasPlugin(e))) {
            throw this.raise(u.MissingOneOfPlugins, {
              at: this.state.startLoc,
              missingPlugin: e,
            });
          }
        }
        errorBuilder(e) {
          return (t, r, s) => {
            this.raise(e, { at: buildPosition(t, r, s) });
          };
        }
      }
      class ClassScope {
        constructor() {
          this.privateNames = new Set();
          this.loneAccessors = new Map();
          this.undefinedPrivateNames = new Map();
        }
      }
      class ClassScopeHandler {
        constructor(e) {
          this.parser = void 0;
          this.stack = [];
          this.undefinedPrivateNames = new Map();
          this.parser = e;
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new ClassScope());
        }
        exit() {
          const e = this.stack.pop();
          const t = this.current();
          for (const [r, s] of Array.from(e.undefinedPrivateNames)) {
            if (t) {
              if (!t.undefinedPrivateNames.has(r)) {
                t.undefinedPrivateNames.set(r, s);
              }
            } else {
              this.parser.raise(u.InvalidPrivateFieldResolution, {
                at: s,
                identifierName: r,
              });
            }
          }
        }
        declarePrivateName(e, t, r) {
          const {
            privateNames: s,
            loneAccessors: i,
            undefinedPrivateNames: n,
          } = this.current();
          let a = s.has(e);
          if (t & 3) {
            const r = a && i.get(e);
            if (r) {
              const s = r & 4;
              const n = t & 4;
              const o = r & 3;
              const l = t & 3;
              a = o === l || s !== n;
              if (!a) i.delete(e);
            } else if (!a) {
              i.set(e, t);
            }
          }
          if (a) {
            this.parser.raise(u.PrivateNameRedeclaration, {
              at: r,
              identifierName: e,
            });
          }
          s.add(e);
          n.delete(e);
        }
        usePrivateName(e, t) {
          let r;
          for (r of this.stack) {
            if (r.privateNames.has(e)) return;
          }
          if (r) {
            r.undefinedPrivateNames.set(e, t);
          } else {
            this.parser.raise(u.InvalidPrivateFieldResolution, {
              at: t,
              identifierName: e,
            });
          }
        }
      }
      class ExpressionScope {
        constructor(e = 0) {
          this.type = e;
        }
        canBeArrowParameterDeclaration() {
          return this.type === 2 || this.type === 1;
        }
        isCertainlyParameterDeclaration() {
          return this.type === 3;
        }
      }
      class ArrowHeadParsingScope extends ExpressionScope {
        constructor(e) {
          super(e);
          this.declarationErrors = new Map();
        }
        recordDeclarationError(e, { at: t }) {
          const r = t.index;
          this.declarationErrors.set(r, [e, t]);
        }
        clearDeclarationError(e) {
          this.declarationErrors.delete(e);
        }
        iterateErrors(e) {
          this.declarationErrors.forEach(e);
        }
      }
      class ExpressionScopeHandler {
        constructor(e) {
          this.parser = void 0;
          this.stack = [new ExpressionScope()];
          this.parser = e;
        }
        enter(e) {
          this.stack.push(e);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(e, { at: t }) {
          const r = { at: t.loc.start };
          const { stack: s } = this;
          let i = s.length - 1;
          let n = s[i];
          while (!n.isCertainlyParameterDeclaration()) {
            if (n.canBeArrowParameterDeclaration()) {
              n.recordDeclarationError(e, r);
            } else {
              return;
            }
            n = s[--i];
          }
          this.parser.raise(e, r);
        }
        recordArrowParameterBindingError(e, { at: t }) {
          const { stack: r } = this;
          const s = r[r.length - 1];
          const i = { at: t.loc.start };
          if (s.isCertainlyParameterDeclaration()) {
            this.parser.raise(e, i);
          } else if (s.canBeArrowParameterDeclaration()) {
            s.recordDeclarationError(e, i);
          } else {
            return;
          }
        }
        recordAsyncArrowParametersError({ at: e }) {
          const { stack: t } = this;
          let r = t.length - 1;
          let s = t[r];
          while (s.canBeArrowParameterDeclaration()) {
            if (s.type === 2) {
              s.recordDeclarationError(u.AwaitBindingIdentifier, { at: e });
            }
            s = t[--r];
          }
        }
        validateAsPattern() {
          const { stack: e } = this;
          const t = e[e.length - 1];
          if (!t.canBeArrowParameterDeclaration()) return;
          t.iterateErrors(([t, r]) => {
            this.parser.raise(t, { at: r });
            let s = e.length - 2;
            let i = e[s];
            while (i.canBeArrowParameterDeclaration()) {
              i.clearDeclarationError(r.index);
              i = e[--s];
            }
          });
        }
      }
      function newParameterDeclarationScope() {
        return new ExpressionScope(3);
      }
      function newArrowHeadScope() {
        return new ArrowHeadParsingScope(1);
      }
      function newAsyncArrowScope() {
        return new ArrowHeadParsingScope(2);
      }
      function newExpressionScope() {
        return new ExpressionScope();
      }
      class ProductionParameterHandler {
        constructor() {
          this.stacks = [];
        }
        enter(e) {
          this.stacks.push(e);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (this.currentFlags() & 2) > 0;
        }
        get hasYield() {
          return (this.currentFlags() & 1) > 0;
        }
        get hasReturn() {
          return (this.currentFlags() & 4) > 0;
        }
        get hasIn() {
          return (this.currentFlags() & 8) > 0;
        }
      }
      function functionFlags(e, t) {
        return (e ? 2 : 0) | (t ? 1 : 0);
      }
      class UtilParser extends Tokenizer {
        addExtra(e, t, r, s = true) {
          if (!e) return;
          const i = (e.extra = e.extra || {});
          if (s) {
            i[t] = r;
          } else {
            Object.defineProperty(i, t, { enumerable: s, value: r });
          }
        }
        isContextual(e) {
          return this.state.type === e && !this.state.containsEsc;
        }
        isUnparsedContextual(e, t) {
          const r = e + t.length;
          if (this.input.slice(e, r) === t) {
            const e = this.input.charCodeAt(r);
            return !(isIdentifierChar(e) || (e & 64512) === 55296);
          }
          return false;
        }
        isLookaheadContextual(e) {
          const t = this.nextTokenStart();
          return this.isUnparsedContextual(t, e);
        }
        eatContextual(e) {
          if (this.isContextual(e)) {
            this.next();
            return true;
          }
          return false;
        }
        expectContextual(e, t) {
          if (!this.eatContextual(e)) {
            if (t != null) {
              throw this.raise(t, { at: this.state.startLoc });
            }
            this.unexpected(null, e);
          }
        }
        canInsertSemicolon() {
          return (
            this.match(139) || this.match(8) || this.hasPrecedingLineBreak()
          );
        }
        hasPrecedingLineBreak() {
          return K.test(
            this.input.slice(this.state.lastTokEndLoc.index, this.state.start),
          );
        }
        hasFollowingLineBreak() {
          J.lastIndex = this.state.end;
          return J.test(this.input);
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(e = true) {
          if (e ? this.isLineTerminator() : this.eat(13)) return;
          this.raise(u.MissingSemicolon, { at: this.state.lastTokEndLoc });
        }
        expect(e, t) {
          this.eat(e) || this.unexpected(t, e);
        }
        tryParse(e, t = this.state.clone()) {
          const r = { node: null };
          try {
            const s = e((e = null) => {
              r.node = e;
              throw r;
            });
            if (this.state.errors.length > t.errors.length) {
              const e = this.state;
              this.state = t;
              this.state.tokensLength = e.tokensLength;
              return {
                node: s,
                error: e.errors[t.errors.length],
                thrown: false,
                aborted: false,
                failState: e,
              };
            }
            return {
              node: s,
              error: null,
              thrown: false,
              aborted: false,
              failState: null,
            };
          } catch (e) {
            const s = this.state;
            this.state = t;
            if (e instanceof SyntaxError) {
              return {
                node: null,
                error: e,
                thrown: true,
                aborted: false,
                failState: s,
              };
            }
            if (e === r) {
              return {
                node: r.node,
                error: null,
                thrown: false,
                aborted: true,
                failState: s,
              };
            }
            throw e;
          }
        }
        checkExpressionErrors(e, t) {
          if (!e) return false;
          const {
            shorthandAssignLoc: r,
            doubleProtoLoc: s,
            privateKeyLoc: i,
            optionalParametersLoc: n,
          } = e;
          const a = !!r || !!s || !!n || !!i;
          if (!t) {
            return a;
          }
          if (r != null) {
            this.raise(u.InvalidCoverInitializedName, { at: r });
          }
          if (s != null) {
            this.raise(u.DuplicateProto, { at: s });
          }
          if (i != null) {
            this.raise(u.UnexpectedPrivateField, { at: i });
          }
          if (n != null) {
            this.unexpected(n);
          }
        }
        isLiteralPropertyName() {
          return tokenIsLiteralPropertyName(this.state.type);
        }
        isPrivateName(e) {
          return e.type === 'PrivateName';
        }
        getPrivateNameSV(e) {
          return e.id.name;
        }
        hasPropertyAsPrivateName(e) {
          return (
            (e.type === 'MemberExpression' ||
              e.type === 'OptionalMemberExpression') &&
            this.isPrivateName(e.property)
          );
        }
        isObjectProperty(e) {
          return e.type === 'ObjectProperty';
        }
        isObjectMethod(e) {
          return e.type === 'ObjectMethod';
        }
        initializeScopes(e = this.options.sourceType === 'module') {
          const t = this.state.labels;
          this.state.labels = [];
          const r = this.exportedIdentifiers;
          this.exportedIdentifiers = new Set();
          const s = this.inModule;
          this.inModule = e;
          const i = this.scope;
          const n = this.getScopeHandler();
          this.scope = new n(this, e);
          const a = this.prodParam;
          this.prodParam = new ProductionParameterHandler();
          const o = this.classScope;
          this.classScope = new ClassScopeHandler(this);
          const l = this.expressionScope;
          this.expressionScope = new ExpressionScopeHandler(this);
          return () => {
            this.state.labels = t;
            this.exportedIdentifiers = r;
            this.inModule = s;
            this.scope = i;
            this.prodParam = a;
            this.classScope = o;
            this.expressionScope = l;
          };
        }
        enterInitialScopes() {
          let e = 0;
          if (this.inModule) {
            e |= 2;
          }
          this.scope.enter(1);
          this.prodParam.enter(e);
        }
        checkDestructuringPrivate(e) {
          const { privateKeyLoc: t } = e;
          if (t !== null) {
            this.expectPlugin('destructuringPrivate', t);
          }
        }
      }
      class ExpressionErrors {
        constructor() {
          this.shorthandAssignLoc = null;
          this.doubleProtoLoc = null;
          this.privateKeyLoc = null;
          this.optionalParametersLoc = null;
        }
      }
      class Node {
        constructor(e, t, r) {
          this.type = '';
          this.start = t;
          this.end = 0;
          this.loc = new SourceLocation(r);
          if (e != null && e.options.ranges) this.range = [t, 0];
          if (e != null && e.filename) this.loc.filename = e.filename;
        }
      }
      const G = Node.prototype;
      {
        G.__clone = function () {
          const e = new Node(undefined, this.start, this.loc.start);
          const t = Object.keys(this);
          for (let r = 0, s = t.length; r < s; r++) {
            const s = t[r];
            if (
              s !== 'leadingComments' &&
              s !== 'trailingComments' &&
              s !== 'innerComments'
            ) {
              e[s] = this[s];
            }
          }
          return e;
        };
      }
      function clonePlaceholder(e) {
        return cloneIdentifier(e);
      }
      function cloneIdentifier(e) {
        const {
          type: t,
          start: r,
          end: s,
          loc: i,
          range: n,
          extra: a,
          name: o,
        } = e;
        const l = Object.create(G);
        l.type = t;
        l.start = r;
        l.end = s;
        l.loc = i;
        l.range = n;
        l.extra = a;
        l.name = o;
        if (t === 'Placeholder') {
          l.expectedNode = e.expectedNode;
        }
        return l;
      }
      function cloneStringLiteral(e) {
        const { type: t, start: r, end: s, loc: i, range: n, extra: a } = e;
        if (t === 'Placeholder') {
          return clonePlaceholder(e);
        }
        const o = Object.create(G);
        o.type = t;
        o.start = r;
        o.end = s;
        o.loc = i;
        o.range = n;
        if (e.raw !== undefined) {
          o.raw = e.raw;
        } else {
          o.extra = a;
        }
        o.value = e.value;
        return o;
      }
      class NodeUtils extends UtilParser {
        startNode() {
          return new Node(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(e) {
          return new Node(this, e.index, e);
        }
        startNodeAtNode(e) {
          return this.startNodeAt(e.loc.start);
        }
        finishNode(e, t) {
          return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
        }
        finishNodeAt(e, t, r) {
          e.type = t;
          e.end = r.index;
          e.loc.end = r;
          if (this.options.ranges) e.range[1] = r.index;
          if (this.options.attachComment) this.processComment(e);
          return e;
        }
        resetStartLocation(e, t) {
          e.start = t.index;
          e.loc.start = t;
          if (this.options.ranges) e.range[0] = t.index;
        }
        resetEndLocation(e, t = this.state.lastTokEndLoc) {
          e.end = t.index;
          e.loc.end = t;
          if (this.options.ranges) e.range[1] = t.index;
        }
        resetStartLocationFromNode(e, t) {
          this.resetStartLocation(e, t.loc.start);
        }
      }
      const Q = new Set([
        '_',
        'any',
        'bool',
        'boolean',
        'empty',
        'extends',
        'false',
        'interface',
        'mixed',
        'null',
        'number',
        'static',
        'string',
        'true',
        'typeof',
        'void',
      ]);
      const Z = ParseErrorEnum`flow`({
        AmbiguousConditionalArrow:
          'Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.',
        AmbiguousDeclareModuleKind:
          'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.',
        AssignReservedType: ({ reservedType: e }) =>
          `Cannot overwrite reserved type ${e}.`,
        DeclareClassElement:
          'The `declare` modifier can only appear on class fields.',
        DeclareClassFieldInitializer:
          'Initializers are not allowed in fields with the `declare` modifier.',
        DuplicateDeclareModuleExports:
          'Duplicate `declare module.exports` statement.',
        EnumBooleanMemberNotInitialized: ({ memberName: e, enumName: t }) =>
          `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`,
        EnumDuplicateMemberName: ({ memberName: e, enumName: t }) =>
          `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`,
        EnumInconsistentMemberValues: ({ enumName: e }) =>
          `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
        EnumInvalidExplicitType: ({ invalidEnumType: e, enumName: t }) =>
          `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`,
        EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: e }) =>
          `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`,
        EnumInvalidMemberInitializerPrimaryType: ({
          enumName: e,
          memberName: t,
          explicitType: r,
        }) =>
          `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`,
        EnumInvalidMemberInitializerSymbolType: ({
          enumName: e,
          memberName: t,
        }) =>
          `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`,
        EnumInvalidMemberInitializerUnknownType: ({
          enumName: e,
          memberName: t,
        }) =>
          `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`,
        EnumInvalidMemberName: ({
          enumName: e,
          memberName: t,
          suggestion: r,
        }) =>
          `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`,
        EnumNumberMemberNotInitialized: ({ enumName: e, memberName: t }) =>
          `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`,
        EnumStringMemberInconsistentlyInitialized: ({ enumName: e }) =>
          `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`,
        GetterMayNotHaveThisParam: 'A getter cannot have a `this` parameter.',
        ImportReflectionHasImportType:
          'An `import module` declaration can not use `type` or `typeof` keyword.',
        ImportTypeShorthandOnlyInPureImport:
          'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.',
        InexactInsideExact:
          'Explicit inexact syntax cannot appear inside an explicit exact object type.',
        InexactInsideNonObject:
          'Explicit inexact syntax cannot appear in class or interface definitions.',
        InexactVariance: 'Explicit inexact syntax cannot have variance.',
        InvalidNonTypeImportInDeclareModule:
          'Imports within a `declare module` body must always be `import type` or `import typeof`.',
        MissingTypeParamDefault:
          'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.',
        NestedDeclareModule:
          '`declare module` cannot be used inside another `declare module`.',
        NestedFlowComment:
          'Cannot have a flow comment inside another flow comment.',
        PatternIsOptional: Object.assign(
          {
            message:
              'A binding pattern parameter cannot be optional in an implementation signature.',
          },
          { reasonCode: 'OptionalBindingPattern' },
        ),
        SetterMayNotHaveThisParam: 'A setter cannot have a `this` parameter.',
        SpreadVariance: 'Spread properties cannot have variance.',
        ThisParamAnnotationRequired:
          'A type annotation is required for the `this` parameter.',
        ThisParamBannedInConstructor:
          "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
        ThisParamMayNotBeOptional: 'The `this` parameter cannot be optional.',
        ThisParamMustBeFirst:
          'The `this` parameter must be the first function parameter.',
        ThisParamNoDefault:
          'The `this` parameter may not have a default value.',
        TypeBeforeInitializer:
          'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
        TypeCastInPattern:
          'The type cast expression is expected to be wrapped with parenthesis.',
        UnexpectedExplicitInexactInObject:
          'Explicit inexact syntax must appear at the end of an inexact object.',
        UnexpectedReservedType: ({ reservedType: e }) =>
          `Unexpected reserved type ${e}.`,
        UnexpectedReservedUnderscore:
          '`_` is only allowed as a type argument to call or new.',
        UnexpectedSpaceBetweenModuloChecks:
          'Spaces between `%` and `checks` are not allowed here.',
        UnexpectedSpreadType:
          'Spread operator cannot appear in class or interface definitions.',
        UnexpectedSubtractionOperand:
          'Unexpected token, expected "number" or "bigint".',
        UnexpectedTokenAfterTypeParameter:
          'Expected an arrow function after this type parameter declaration.',
        UnexpectedTypeParameterBeforeAsyncArrowFunction:
          'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.',
        UnsupportedDeclareExportKind: ({
          unsupportedExportKind: e,
          suggestion: t,
        }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`,
        UnsupportedStatementInDeclareModule:
          'Only declares and type imports are allowed inside declare module.',
        UnterminatedFlowComment: 'Unterminated flow-comment.',
      });
      function isEsModuleType(e) {
        return (
          e.type === 'DeclareExportAllDeclaration' ||
          (e.type === 'DeclareExportDeclaration' &&
            (!e.declaration ||
              (e.declaration.type !== 'TypeAlias' &&
                e.declaration.type !== 'InterfaceDeclaration')))
        );
      }
      function hasTypeImportKind(e) {
        return e.importKind === 'type' || e.importKind === 'typeof';
      }
      const ee = {
        const: 'declare export var',
        let: 'declare export var',
        type: 'export type',
        interface: 'export interface',
      };
      function partition(e, t) {
        const r = [];
        const s = [];
        for (let i = 0; i < e.length; i++) {
          (t(e[i], i, e) ? r : s).push(e[i]);
        }
        return [r, s];
      }
      const te = /\*?\s*@((?:no)?flow)\b/;
      var flow = (e) =>
        class FlowParserMixin extends e {
          constructor(...e) {
            super(...e);
            this.flowPragma = undefined;
          }
          getScopeHandler() {
            return FlowScopeHandler;
          }
          shouldParseTypes() {
            return (
              this.getPluginOption('flow', 'all') || this.flowPragma === 'flow'
            );
          }
          shouldParseEnums() {
            return !!this.getPluginOption('flow', 'enums');
          }
          finishToken(e, t) {
            if (e !== 133 && e !== 13 && e !== 28) {
              if (this.flowPragma === undefined) {
                this.flowPragma = null;
              }
            }
            super.finishToken(e, t);
          }
          addComment(e) {
            if (this.flowPragma === undefined) {
              const t = te.exec(e.value);
              if (!t);
              else if (t[1] === 'flow') {
                this.flowPragma = 'flow';
              } else if (t[1] === 'noflow') {
                this.flowPragma = 'noflow';
              } else {
                throw new Error('Unexpected flow pragma');
              }
            }
            super.addComment(e);
          }
          flowParseTypeInitialiser(e) {
            const t = this.state.inType;
            this.state.inType = true;
            this.expect(e || 14);
            const r = this.flowParseType();
            this.state.inType = t;
            return r;
          }
          flowParsePredicate() {
            const e = this.startNode();
            const t = this.state.startLoc;
            this.next();
            this.expectContextual(110);
            if (this.state.lastTokStart > t.index + 1) {
              this.raise(Z.UnexpectedSpaceBetweenModuloChecks, { at: t });
            }
            if (this.eat(10)) {
              e.value = super.parseExpression();
              this.expect(11);
              return this.finishNode(e, 'DeclaredPredicate');
            } else {
              return this.finishNode(e, 'InferredPredicate');
            }
          }
          flowParseTypeAndPredicateInitialiser() {
            const e = this.state.inType;
            this.state.inType = true;
            this.expect(14);
            let t = null;
            let r = null;
            if (this.match(54)) {
              this.state.inType = e;
              r = this.flowParsePredicate();
            } else {
              t = this.flowParseType();
              this.state.inType = e;
              if (this.match(54)) {
                r = this.flowParsePredicate();
              }
            }
            return [t, r];
          }
          flowParseDeclareClass(e) {
            this.next();
            this.flowParseInterfaceish(e, true);
            return this.finishNode(e, 'DeclareClass');
          }
          flowParseDeclareFunction(e) {
            this.next();
            const t = (e.id = this.parseIdentifier());
            const r = this.startNode();
            const s = this.startNode();
            if (this.match(47)) {
              r.typeParameters = this.flowParseTypeParameterDeclaration();
            } else {
              r.typeParameters = null;
            }
            this.expect(10);
            const i = this.flowParseFunctionTypeParams();
            r.params = i.params;
            r.rest = i.rest;
            r.this = i._this;
            this.expect(11);
            [r.returnType, e.predicate] =
              this.flowParseTypeAndPredicateInitialiser();
            s.typeAnnotation = this.finishNode(r, 'FunctionTypeAnnotation');
            t.typeAnnotation = this.finishNode(s, 'TypeAnnotation');
            this.resetEndLocation(t);
            this.semicolon();
            this.scope.declareName(e.id.name, 2048, e.id.loc.start);
            return this.finishNode(e, 'DeclareFunction');
          }
          flowParseDeclare(e, t) {
            if (this.match(80)) {
              return this.flowParseDeclareClass(e);
            } else if (this.match(68)) {
              return this.flowParseDeclareFunction(e);
            } else if (this.match(74)) {
              return this.flowParseDeclareVariable(e);
            } else if (this.eatContextual(127)) {
              if (this.match(16)) {
                return this.flowParseDeclareModuleExports(e);
              } else {
                if (t) {
                  this.raise(Z.NestedDeclareModule, {
                    at: this.state.lastTokStartLoc,
                  });
                }
                return this.flowParseDeclareModule(e);
              }
            } else if (this.isContextual(130)) {
              return this.flowParseDeclareTypeAlias(e);
            } else if (this.isContextual(131)) {
              return this.flowParseDeclareOpaqueType(e);
            } else if (this.isContextual(129)) {
              return this.flowParseDeclareInterface(e);
            } else if (this.match(82)) {
              return this.flowParseDeclareExportDeclaration(e, t);
            } else {
              this.unexpected();
            }
          }
          flowParseDeclareVariable(e) {
            this.next();
            e.id = this.flowParseTypeAnnotatableIdentifier(true);
            this.scope.declareName(e.id.name, 5, e.id.loc.start);
            this.semicolon();
            return this.finishNode(e, 'DeclareVariable');
          }
          flowParseDeclareModule(e) {
            this.scope.enter(0);
            if (this.match(133)) {
              e.id = super.parseExprAtom();
            } else {
              e.id = this.parseIdentifier();
            }
            const t = (e.body = this.startNode());
            const r = (t.body = []);
            this.expect(5);
            while (!this.match(8)) {
              let e = this.startNode();
              if (this.match(83)) {
                this.next();
                if (!this.isContextual(130) && !this.match(87)) {
                  this.raise(Z.InvalidNonTypeImportInDeclareModule, {
                    at: this.state.lastTokStartLoc,
                  });
                }
                super.parseImport(e);
              } else {
                this.expectContextual(
                  125,
                  Z.UnsupportedStatementInDeclareModule,
                );
                e = this.flowParseDeclare(e, true);
              }
              r.push(e);
            }
            this.scope.exit();
            this.expect(8);
            this.finishNode(t, 'BlockStatement');
            let s = null;
            let i = false;
            r.forEach((e) => {
              if (isEsModuleType(e)) {
                if (s === 'CommonJS') {
                  this.raise(Z.AmbiguousDeclareModuleKind, { at: e });
                }
                s = 'ES';
              } else if (e.type === 'DeclareModuleExports') {
                if (i) {
                  this.raise(Z.DuplicateDeclareModuleExports, { at: e });
                }
                if (s === 'ES') {
                  this.raise(Z.AmbiguousDeclareModuleKind, { at: e });
                }
                s = 'CommonJS';
                i = true;
              }
            });
            e.kind = s || 'CommonJS';
            return this.finishNode(e, 'DeclareModule');
          }
          flowParseDeclareExportDeclaration(e, t) {
            this.expect(82);
            if (this.eat(65)) {
              if (this.match(68) || this.match(80)) {
                e.declaration = this.flowParseDeclare(this.startNode());
              } else {
                e.declaration = this.flowParseType();
                this.semicolon();
              }
              e.default = true;
              return this.finishNode(e, 'DeclareExportDeclaration');
            } else {
              if (
                this.match(75) ||
                this.isLet() ||
                ((this.isContextual(130) || this.isContextual(129)) && !t)
              ) {
                const e = this.state.value;
                throw this.raise(Z.UnsupportedDeclareExportKind, {
                  at: this.state.startLoc,
                  unsupportedExportKind: e,
                  suggestion: ee[e],
                });
              }
              if (
                this.match(74) ||
                this.match(68) ||
                this.match(80) ||
                this.isContextual(131)
              ) {
                e.declaration = this.flowParseDeclare(this.startNode());
                e.default = false;
                return this.finishNode(e, 'DeclareExportDeclaration');
              } else if (
                this.match(55) ||
                this.match(5) ||
                this.isContextual(129) ||
                this.isContextual(130) ||
                this.isContextual(131)
              ) {
                e = this.parseExport(e, null);
                if (e.type === 'ExportNamedDeclaration') {
                  e.type = 'ExportDeclaration';
                  e.default = false;
                  delete e.exportKind;
                }
                e.type = 'Declare' + e.type;
                return e;
              }
            }
            this.unexpected();
          }
          flowParseDeclareModuleExports(e) {
            this.next();
            this.expectContextual(111);
            e.typeAnnotation = this.flowParseTypeAnnotation();
            this.semicolon();
            return this.finishNode(e, 'DeclareModuleExports');
          }
          flowParseDeclareTypeAlias(e) {
            this.next();
            const t = this.flowParseTypeAlias(e);
            t.type = 'DeclareTypeAlias';
            return t;
          }
          flowParseDeclareOpaqueType(e) {
            this.next();
            const t = this.flowParseOpaqueType(e, true);
            t.type = 'DeclareOpaqueType';
            return t;
          }
          flowParseDeclareInterface(e) {
            this.next();
            this.flowParseInterfaceish(e, false);
            return this.finishNode(e, 'DeclareInterface');
          }
          flowParseInterfaceish(e, t) {
            e.id = this.flowParseRestrictedIdentifier(!t, true);
            this.scope.declareName(e.id.name, t ? 17 : 8201, e.id.loc.start);
            if (this.match(47)) {
              e.typeParameters = this.flowParseTypeParameterDeclaration();
            } else {
              e.typeParameters = null;
            }
            e.extends = [];
            if (this.eat(81)) {
              do {
                e.extends.push(this.flowParseInterfaceExtends());
              } while (!t && this.eat(12));
            }
            if (t) {
              e.implements = [];
              e.mixins = [];
              if (this.eatContextual(117)) {
                do {
                  e.mixins.push(this.flowParseInterfaceExtends());
                } while (this.eat(12));
              }
              if (this.eatContextual(113)) {
                do {
                  e.implements.push(this.flowParseInterfaceExtends());
                } while (this.eat(12));
              }
            }
            e.body = this.flowParseObjectType({
              allowStatic: t,
              allowExact: false,
              allowSpread: false,
              allowProto: t,
              allowInexact: false,
            });
          }
          flowParseInterfaceExtends() {
            const e = this.startNode();
            e.id = this.flowParseQualifiedTypeIdentifier();
            if (this.match(47)) {
              e.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              e.typeParameters = null;
            }
            return this.finishNode(e, 'InterfaceExtends');
          }
          flowParseInterface(e) {
            this.flowParseInterfaceish(e, false);
            return this.finishNode(e, 'InterfaceDeclaration');
          }
          checkNotUnderscore(e) {
            if (e === '_') {
              this.raise(Z.UnexpectedReservedUnderscore, {
                at: this.state.startLoc,
              });
            }
          }
          checkReservedType(e, t, r) {
            if (!Q.has(e)) return;
            this.raise(r ? Z.AssignReservedType : Z.UnexpectedReservedType, {
              at: t,
              reservedType: e,
            });
          }
          flowParseRestrictedIdentifier(e, t) {
            this.checkReservedType(this.state.value, this.state.startLoc, t);
            return this.parseIdentifier(e);
          }
          flowParseTypeAlias(e) {
            e.id = this.flowParseRestrictedIdentifier(false, true);
            this.scope.declareName(e.id.name, 8201, e.id.loc.start);
            if (this.match(47)) {
              e.typeParameters = this.flowParseTypeParameterDeclaration();
            } else {
              e.typeParameters = null;
            }
            e.right = this.flowParseTypeInitialiser(29);
            this.semicolon();
            return this.finishNode(e, 'TypeAlias');
          }
          flowParseOpaqueType(e, t) {
            this.expectContextual(130);
            e.id = this.flowParseRestrictedIdentifier(true, true);
            this.scope.declareName(e.id.name, 8201, e.id.loc.start);
            if (this.match(47)) {
              e.typeParameters = this.flowParseTypeParameterDeclaration();
            } else {
              e.typeParameters = null;
            }
            e.supertype = null;
            if (this.match(14)) {
              e.supertype = this.flowParseTypeInitialiser(14);
            }
            e.impltype = null;
            if (!t) {
              e.impltype = this.flowParseTypeInitialiser(29);
            }
            this.semicolon();
            return this.finishNode(e, 'OpaqueType');
          }
          flowParseTypeParameter(e = false) {
            const t = this.state.startLoc;
            const r = this.startNode();
            const s = this.flowParseVariance();
            const i = this.flowParseTypeAnnotatableIdentifier();
            r.name = i.name;
            r.variance = s;
            r.bound = i.typeAnnotation;
            if (this.match(29)) {
              this.eat(29);
              r.default = this.flowParseType();
            } else {
              if (e) {
                this.raise(Z.MissingTypeParamDefault, { at: t });
              }
            }
            return this.finishNode(r, 'TypeParameter');
          }
          flowParseTypeParameterDeclaration() {
            const e = this.state.inType;
            const t = this.startNode();
            t.params = [];
            this.state.inType = true;
            if (this.match(47) || this.match(142)) {
              this.next();
            } else {
              this.unexpected();
            }
            let r = false;
            do {
              const e = this.flowParseTypeParameter(r);
              t.params.push(e);
              if (e.default) {
                r = true;
              }
              if (!this.match(48)) {
                this.expect(12);
              }
            } while (!this.match(48));
            this.expect(48);
            this.state.inType = e;
            return this.finishNode(t, 'TypeParameterDeclaration');
          }
          flowParseTypeParameterInstantiation() {
            const e = this.startNode();
            const t = this.state.inType;
            e.params = [];
            this.state.inType = true;
            this.expect(47);
            const r = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = false;
            while (!this.match(48)) {
              e.params.push(this.flowParseType());
              if (!this.match(48)) {
                this.expect(12);
              }
            }
            this.state.noAnonFunctionType = r;
            this.expect(48);
            this.state.inType = t;
            return this.finishNode(e, 'TypeParameterInstantiation');
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const e = this.startNode();
            const t = this.state.inType;
            e.params = [];
            this.state.inType = true;
            this.expect(47);
            while (!this.match(48)) {
              e.params.push(this.flowParseTypeOrImplicitInstantiation());
              if (!this.match(48)) {
                this.expect(12);
              }
            }
            this.expect(48);
            this.state.inType = t;
            return this.finishNode(e, 'TypeParameterInstantiation');
          }
          flowParseInterfaceType() {
            const e = this.startNode();
            this.expectContextual(129);
            e.extends = [];
            if (this.eat(81)) {
              do {
                e.extends.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            }
            e.body = this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: false,
              allowProto: false,
              allowInexact: false,
            });
            return this.finishNode(e, 'InterfaceTypeAnnotation');
          }
          flowParseObjectPropertyKey() {
            return this.match(134) || this.match(133)
              ? super.parseExprAtom()
              : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(e, t, r) {
            e.static = t;
            if (this.lookahead().type === 14) {
              e.id = this.flowParseObjectPropertyKey();
              e.key = this.flowParseTypeInitialiser();
            } else {
              e.id = null;
              e.key = this.flowParseType();
            }
            this.expect(3);
            e.value = this.flowParseTypeInitialiser();
            e.variance = r;
            return this.finishNode(e, 'ObjectTypeIndexer');
          }
          flowParseObjectTypeInternalSlot(e, t) {
            e.static = t;
            e.id = this.flowParseObjectPropertyKey();
            this.expect(3);
            this.expect(3);
            if (this.match(47) || this.match(10)) {
              e.method = true;
              e.optional = false;
              e.value = this.flowParseObjectTypeMethodish(
                this.startNodeAt(e.loc.start),
              );
            } else {
              e.method = false;
              if (this.eat(17)) {
                e.optional = true;
              }
              e.value = this.flowParseTypeInitialiser();
            }
            return this.finishNode(e, 'ObjectTypeInternalSlot');
          }
          flowParseObjectTypeMethodish(e) {
            e.params = [];
            e.rest = null;
            e.typeParameters = null;
            e.this = null;
            if (this.match(47)) {
              e.typeParameters = this.flowParseTypeParameterDeclaration();
            }
            this.expect(10);
            if (this.match(78)) {
              e.this = this.flowParseFunctionTypeParam(true);
              e.this.name = null;
              if (!this.match(11)) {
                this.expect(12);
              }
            }
            while (!this.match(11) && !this.match(21)) {
              e.params.push(this.flowParseFunctionTypeParam(false));
              if (!this.match(11)) {
                this.expect(12);
              }
            }
            if (this.eat(21)) {
              e.rest = this.flowParseFunctionTypeParam(false);
            }
            this.expect(11);
            e.returnType = this.flowParseTypeInitialiser();
            return this.finishNode(e, 'FunctionTypeAnnotation');
          }
          flowParseObjectTypeCallProperty(e, t) {
            const r = this.startNode();
            e.static = t;
            e.value = this.flowParseObjectTypeMethodish(r);
            return this.finishNode(e, 'ObjectTypeCallProperty');
          }
          flowParseObjectType({
            allowStatic: e,
            allowExact: t,
            allowSpread: r,
            allowProto: s,
            allowInexact: i,
          }) {
            const n = this.state.inType;
            this.state.inType = true;
            const a = this.startNode();
            a.callProperties = [];
            a.properties = [];
            a.indexers = [];
            a.internalSlots = [];
            let o;
            let l;
            let c = false;
            if (t && this.match(6)) {
              this.expect(6);
              o = 9;
              l = true;
            } else {
              this.expect(5);
              o = 8;
              l = false;
            }
            a.exact = l;
            while (!this.match(o)) {
              let t = false;
              let n = null;
              let o = null;
              const p = this.startNode();
              if (s && this.isContextual(118)) {
                const t = this.lookahead();
                if (t.type !== 14 && t.type !== 17) {
                  this.next();
                  n = this.state.startLoc;
                  e = false;
                }
              }
              if (e && this.isContextual(106)) {
                const e = this.lookahead();
                if (e.type !== 14 && e.type !== 17) {
                  this.next();
                  t = true;
                }
              }
              const u = this.flowParseVariance();
              if (this.eat(0)) {
                if (n != null) {
                  this.unexpected(n);
                }
                if (this.eat(0)) {
                  if (u) {
                    this.unexpected(u.loc.start);
                  }
                  a.internalSlots.push(
                    this.flowParseObjectTypeInternalSlot(p, t),
                  );
                } else {
                  a.indexers.push(this.flowParseObjectTypeIndexer(p, t, u));
                }
              } else if (this.match(10) || this.match(47)) {
                if (n != null) {
                  this.unexpected(n);
                }
                if (u) {
                  this.unexpected(u.loc.start);
                }
                a.callProperties.push(
                  this.flowParseObjectTypeCallProperty(p, t),
                );
              } else {
                let e = 'init';
                if (this.isContextual(99) || this.isContextual(104)) {
                  const t = this.lookahead();
                  if (tokenIsLiteralPropertyName(t.type)) {
                    e = this.state.value;
                    this.next();
                  }
                }
                const s = this.flowParseObjectTypeProperty(
                  p,
                  t,
                  n,
                  u,
                  e,
                  r,
                  i != null ? i : !l,
                );
                if (s === null) {
                  c = true;
                  o = this.state.lastTokStartLoc;
                } else {
                  a.properties.push(s);
                }
              }
              this.flowObjectTypeSemicolon();
              if (o && !this.match(8) && !this.match(9)) {
                this.raise(Z.UnexpectedExplicitInexactInObject, { at: o });
              }
            }
            this.expect(o);
            if (r) {
              a.inexact = c;
            }
            const p = this.finishNode(a, 'ObjectTypeAnnotation');
            this.state.inType = n;
            return p;
          }
          flowParseObjectTypeProperty(e, t, r, s, i, n, a) {
            if (this.eat(21)) {
              const t =
                this.match(12) ||
                this.match(13) ||
                this.match(8) ||
                this.match(9);
              if (t) {
                if (!n) {
                  this.raise(Z.InexactInsideNonObject, {
                    at: this.state.lastTokStartLoc,
                  });
                } else if (!a) {
                  this.raise(Z.InexactInsideExact, {
                    at: this.state.lastTokStartLoc,
                  });
                }
                if (s) {
                  this.raise(Z.InexactVariance, { at: s });
                }
                return null;
              }
              if (!n) {
                this.raise(Z.UnexpectedSpreadType, {
                  at: this.state.lastTokStartLoc,
                });
              }
              if (r != null) {
                this.unexpected(r);
              }
              if (s) {
                this.raise(Z.SpreadVariance, { at: s });
              }
              e.argument = this.flowParseType();
              return this.finishNode(e, 'ObjectTypeSpreadProperty');
            } else {
              e.key = this.flowParseObjectPropertyKey();
              e.static = t;
              e.proto = r != null;
              e.kind = i;
              let a = false;
              if (this.match(47) || this.match(10)) {
                e.method = true;
                if (r != null) {
                  this.unexpected(r);
                }
                if (s) {
                  this.unexpected(s.loc.start);
                }
                e.value = this.flowParseObjectTypeMethodish(
                  this.startNodeAt(e.loc.start),
                );
                if (i === 'get' || i === 'set') {
                  this.flowCheckGetterSetterParams(e);
                }
                if (!n && e.key.name === 'constructor' && e.value.this) {
                  this.raise(Z.ThisParamBannedInConstructor, {
                    at: e.value.this,
                  });
                }
              } else {
                if (i !== 'init') this.unexpected();
                e.method = false;
                if (this.eat(17)) {
                  a = true;
                }
                e.value = this.flowParseTypeInitialiser();
                e.variance = s;
              }
              e.optional = a;
              return this.finishNode(e, 'ObjectTypeProperty');
            }
          }
          flowCheckGetterSetterParams(e) {
            const t = e.kind === 'get' ? 0 : 1;
            const r = e.value.params.length + (e.value.rest ? 1 : 0);
            if (e.value.this) {
              this.raise(
                e.kind === 'get'
                  ? Z.GetterMayNotHaveThisParam
                  : Z.SetterMayNotHaveThisParam,
                { at: e.value.this },
              );
            }
            if (r !== t) {
              this.raise(
                e.kind === 'get' ? u.BadGetterArity : u.BadSetterArity,
                { at: e },
              );
            }
            if (e.kind === 'set' && e.value.rest) {
              this.raise(u.BadSetterRestParameter, { at: e });
            }
          }
          flowObjectTypeSemicolon() {
            if (
              !this.eat(13) &&
              !this.eat(12) &&
              !this.match(8) &&
              !this.match(9)
            ) {
              this.unexpected();
            }
          }
          flowParseQualifiedTypeIdentifier(e, t) {
            var r;
            (r = e) != null ? r : (e = this.state.startLoc);
            let s = t || this.flowParseRestrictedIdentifier(true);
            while (this.eat(16)) {
              const t = this.startNodeAt(e);
              t.qualification = s;
              t.id = this.flowParseRestrictedIdentifier(true);
              s = this.finishNode(t, 'QualifiedTypeIdentifier');
            }
            return s;
          }
          flowParseGenericType(e, t) {
            const r = this.startNodeAt(e);
            r.typeParameters = null;
            r.id = this.flowParseQualifiedTypeIdentifier(e, t);
            if (this.match(47)) {
              r.typeParameters = this.flowParseTypeParameterInstantiation();
            }
            return this.finishNode(r, 'GenericTypeAnnotation');
          }
          flowParseTypeofType() {
            const e = this.startNode();
            this.expect(87);
            e.argument = this.flowParsePrimaryType();
            return this.finishNode(e, 'TypeofTypeAnnotation');
          }
          flowParseTupleType() {
            const e = this.startNode();
            e.types = [];
            this.expect(0);
            while (this.state.pos < this.length && !this.match(3)) {
              e.types.push(this.flowParseType());
              if (this.match(3)) break;
              this.expect(12);
            }
            this.expect(3);
            return this.finishNode(e, 'TupleTypeAnnotation');
          }
          flowParseFunctionTypeParam(e) {
            let t = null;
            let r = false;
            let s = null;
            const i = this.startNode();
            const n = this.lookahead();
            const a = this.state.type === 78;
            if (n.type === 14 || n.type === 17) {
              if (a && !e) {
                this.raise(Z.ThisParamMustBeFirst, { at: i });
              }
              t = this.parseIdentifier(a);
              if (this.eat(17)) {
                r = true;
                if (a) {
                  this.raise(Z.ThisParamMayNotBeOptional, { at: i });
                }
              }
              s = this.flowParseTypeInitialiser();
            } else {
              s = this.flowParseType();
            }
            i.name = t;
            i.optional = r;
            i.typeAnnotation = s;
            return this.finishNode(i, 'FunctionTypeParam');
          }
          reinterpretTypeAsFunctionTypeParam(e) {
            const t = this.startNodeAt(e.loc.start);
            t.name = null;
            t.optional = false;
            t.typeAnnotation = e;
            return this.finishNode(t, 'FunctionTypeParam');
          }
          flowParseFunctionTypeParams(e = []) {
            let t = null;
            let r = null;
            if (this.match(78)) {
              r = this.flowParseFunctionTypeParam(true);
              r.name = null;
              if (!this.match(11)) {
                this.expect(12);
              }
            }
            while (!this.match(11) && !this.match(21)) {
              e.push(this.flowParseFunctionTypeParam(false));
              if (!this.match(11)) {
                this.expect(12);
              }
            }
            if (this.eat(21)) {
              t = this.flowParseFunctionTypeParam(false);
            }
            return { params: e, rest: t, _this: r };
          }
          flowIdentToTypeAnnotation(e, t, r) {
            switch (r.name) {
              case 'any':
                return this.finishNode(t, 'AnyTypeAnnotation');
              case 'bool':
              case 'boolean':
                return this.finishNode(t, 'BooleanTypeAnnotation');
              case 'mixed':
                return this.finishNode(t, 'MixedTypeAnnotation');
              case 'empty':
                return this.finishNode(t, 'EmptyTypeAnnotation');
              case 'number':
                return this.finishNode(t, 'NumberTypeAnnotation');
              case 'string':
                return this.finishNode(t, 'StringTypeAnnotation');
              case 'symbol':
                return this.finishNode(t, 'SymbolTypeAnnotation');
              default:
                this.checkNotUnderscore(r.name);
                return this.flowParseGenericType(e, r);
            }
          }
          flowParsePrimaryType() {
            const e = this.state.startLoc;
            const t = this.startNode();
            let r;
            let s;
            let i = false;
            const n = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({
                  allowStatic: false,
                  allowExact: false,
                  allowSpread: true,
                  allowProto: false,
                  allowInexact: true,
                });
              case 6:
                return this.flowParseObjectType({
                  allowStatic: false,
                  allowExact: true,
                  allowSpread: true,
                  allowProto: false,
                  allowInexact: false,
                });
              case 0:
                this.state.noAnonFunctionType = false;
                s = this.flowParseTupleType();
                this.state.noAnonFunctionType = n;
                return s;
              case 47:
                t.typeParameters = this.flowParseTypeParameterDeclaration();
                this.expect(10);
                r = this.flowParseFunctionTypeParams();
                t.params = r.params;
                t.rest = r.rest;
                t.this = r._this;
                this.expect(11);
                this.expect(19);
                t.returnType = this.flowParseType();
                return this.finishNode(t, 'FunctionTypeAnnotation');
              case 10:
                this.next();
                if (!this.match(11) && !this.match(21)) {
                  if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                    const e = this.lookahead().type;
                    i = e !== 17 && e !== 14;
                  } else {
                    i = true;
                  }
                }
                if (i) {
                  this.state.noAnonFunctionType = false;
                  s = this.flowParseType();
                  this.state.noAnonFunctionType = n;
                  if (
                    this.state.noAnonFunctionType ||
                    !(
                      this.match(12) ||
                      (this.match(11) && this.lookahead().type === 19)
                    )
                  ) {
                    this.expect(11);
                    return s;
                  } else {
                    this.eat(12);
                  }
                }
                if (s) {
                  r = this.flowParseFunctionTypeParams([
                    this.reinterpretTypeAsFunctionTypeParam(s),
                  ]);
                } else {
                  r = this.flowParseFunctionTypeParams();
                }
                t.params = r.params;
                t.rest = r.rest;
                t.this = r._this;
                this.expect(11);
                this.expect(19);
                t.returnType = this.flowParseType();
                t.typeParameters = null;
                return this.finishNode(t, 'FunctionTypeAnnotation');
              case 133:
                return this.parseLiteral(
                  this.state.value,
                  'StringLiteralTypeAnnotation',
                );
              case 85:
              case 86:
                t.value = this.match(85);
                this.next();
                return this.finishNode(t, 'BooleanLiteralTypeAnnotation');
              case 53:
                if (this.state.value === '-') {
                  this.next();
                  if (this.match(134)) {
                    return this.parseLiteralAtNode(
                      -this.state.value,
                      'NumberLiteralTypeAnnotation',
                      t,
                    );
                  }
                  if (this.match(135)) {
                    return this.parseLiteralAtNode(
                      -this.state.value,
                      'BigIntLiteralTypeAnnotation',
                      t,
                    );
                  }
                  throw this.raise(Z.UnexpectedSubtractionOperand, {
                    at: this.state.startLoc,
                  });
                }
                this.unexpected();
                return;
              case 134:
                return this.parseLiteral(
                  this.state.value,
                  'NumberLiteralTypeAnnotation',
                );
              case 135:
                return this.parseLiteral(
                  this.state.value,
                  'BigIntLiteralTypeAnnotation',
                );
              case 88:
                this.next();
                return this.finishNode(t, 'VoidTypeAnnotation');
              case 84:
                this.next();
                return this.finishNode(t, 'NullLiteralTypeAnnotation');
              case 78:
                this.next();
                return this.finishNode(t, 'ThisTypeAnnotation');
              case 55:
                this.next();
                return this.finishNode(t, 'ExistsTypeAnnotation');
              case 87:
                return this.flowParseTypeofType();
              default:
                if (tokenIsKeyword(this.state.type)) {
                  const e = tokenLabelName(this.state.type);
                  this.next();
                  return super.createIdentifier(t, e);
                } else if (tokenIsIdentifier(this.state.type)) {
                  if (this.isContextual(129)) {
                    return this.flowParseInterfaceType();
                  }
                  return this.flowIdentToTypeAnnotation(
                    e,
                    t,
                    this.parseIdentifier(),
                  );
                }
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            const e = this.state.startLoc;
            let t = this.flowParsePrimaryType();
            let r = false;
            while (
              (this.match(0) || this.match(18)) &&
              !this.canInsertSemicolon()
            ) {
              const s = this.startNodeAt(e);
              const i = this.eat(18);
              r = r || i;
              this.expect(0);
              if (!i && this.match(3)) {
                s.elementType = t;
                this.next();
                t = this.finishNode(s, 'ArrayTypeAnnotation');
              } else {
                s.objectType = t;
                s.indexType = this.flowParseType();
                this.expect(3);
                if (r) {
                  s.optional = i;
                  t = this.finishNode(s, 'OptionalIndexedAccessType');
                } else {
                  t = this.finishNode(s, 'IndexedAccessType');
                }
              }
            }
            return t;
          }
          flowParsePrefixType() {
            const e = this.startNode();
            if (this.eat(17)) {
              e.typeAnnotation = this.flowParsePrefixType();
              return this.finishNode(e, 'NullableTypeAnnotation');
            } else {
              return this.flowParsePostfixType();
            }
          }
          flowParseAnonFunctionWithoutParens() {
            const e = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              const t = this.startNodeAt(e.loc.start);
              t.params = [this.reinterpretTypeAsFunctionTypeParam(e)];
              t.rest = null;
              t.this = null;
              t.returnType = this.flowParseType();
              t.typeParameters = null;
              return this.finishNode(t, 'FunctionTypeAnnotation');
            }
            return e;
          }
          flowParseIntersectionType() {
            const e = this.startNode();
            this.eat(45);
            const t = this.flowParseAnonFunctionWithoutParens();
            e.types = [t];
            while (this.eat(45)) {
              e.types.push(this.flowParseAnonFunctionWithoutParens());
            }
            return e.types.length === 1
              ? t
              : this.finishNode(e, 'IntersectionTypeAnnotation');
          }
          flowParseUnionType() {
            const e = this.startNode();
            this.eat(43);
            const t = this.flowParseIntersectionType();
            e.types = [t];
            while (this.eat(43)) {
              e.types.push(this.flowParseIntersectionType());
            }
            return e.types.length === 1
              ? t
              : this.finishNode(e, 'UnionTypeAnnotation');
          }
          flowParseType() {
            const e = this.state.inType;
            this.state.inType = true;
            const t = this.flowParseUnionType();
            this.state.inType = e;
            return t;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 132 && this.state.value === '_') {
              const e = this.state.startLoc;
              const t = this.parseIdentifier();
              return this.flowParseGenericType(e, t);
            } else {
              return this.flowParseType();
            }
          }
          flowParseTypeAnnotation() {
            const e = this.startNode();
            e.typeAnnotation = this.flowParseTypeInitialiser();
            return this.finishNode(e, 'TypeAnnotation');
          }
          flowParseTypeAnnotatableIdentifier(e) {
            const t = e
              ? this.parseIdentifier()
              : this.flowParseRestrictedIdentifier();
            if (this.match(14)) {
              t.typeAnnotation = this.flowParseTypeAnnotation();
              this.resetEndLocation(t);
            }
            return t;
          }
          typeCastToParameter(e) {
            e.expression.typeAnnotation = e.typeAnnotation;
            this.resetEndLocation(e.expression, e.typeAnnotation.loc.end);
            return e.expression;
          }
          flowParseVariance() {
            let e = null;
            if (this.match(53)) {
              e = this.startNode();
              if (this.state.value === '+') {
                e.kind = 'plus';
              } else {
                e.kind = 'minus';
              }
              this.next();
              return this.finishNode(e, 'Variance');
            }
            return e;
          }
          parseFunctionBody(e, t, r = false) {
            if (t) {
              this.forwardNoArrowParamsConversionAt(e, () =>
                super.parseFunctionBody(e, true, r),
              );
              return;
            }
            super.parseFunctionBody(e, false, r);
          }
          parseFunctionBodyAndFinish(e, t, r = false) {
            if (this.match(14)) {
              const t = this.startNode();
              [t.typeAnnotation, e.predicate] =
                this.flowParseTypeAndPredicateInitialiser();
              e.returnType = t.typeAnnotation
                ? this.finishNode(t, 'TypeAnnotation')
                : null;
            }
            return super.parseFunctionBodyAndFinish(e, t, r);
          }
          parseStatementLike(e) {
            if (this.state.strict && this.isContextual(129)) {
              const e = this.lookahead();
              if (tokenIsKeywordOrIdentifier(e.type)) {
                const e = this.startNode();
                this.next();
                return this.flowParseInterface(e);
              }
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              const e = this.startNode();
              this.next();
              return this.flowParseEnumDeclaration(e);
            }
            const t = super.parseStatementLike(e);
            if (this.flowPragma === undefined && !this.isValidDirective(t)) {
              this.flowPragma = null;
            }
            return t;
          }
          parseExpressionStatement(e, t, r) {
            if (t.type === 'Identifier') {
              if (t.name === 'declare') {
                if (
                  this.match(80) ||
                  tokenIsIdentifier(this.state.type) ||
                  this.match(68) ||
                  this.match(74) ||
                  this.match(82)
                ) {
                  return this.flowParseDeclare(e);
                }
              } else if (tokenIsIdentifier(this.state.type)) {
                if (t.name === 'interface') {
                  return this.flowParseInterface(e);
                } else if (t.name === 'type') {
                  return this.flowParseTypeAlias(e);
                } else if (t.name === 'opaque') {
                  return this.flowParseOpaqueType(e, false);
                }
              }
            }
            return super.parseExpressionStatement(e, t, r);
          }
          shouldParseExportDeclaration() {
            const { type: e } = this.state;
            if (
              tokenIsFlowInterfaceOrTypeOrOpaque(e) ||
              (this.shouldParseEnums() && e === 126)
            ) {
              return !this.state.containsEsc;
            }
            return super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            const { type: e } = this.state;
            if (
              tokenIsFlowInterfaceOrTypeOrOpaque(e) ||
              (this.shouldParseEnums() && e === 126)
            ) {
              return this.state.containsEsc;
            }
            return super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(126)) {
              const e = this.startNode();
              this.next();
              return this.flowParseEnumDeclaration(e);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(e, t, r) {
            if (!this.match(17)) return e;
            if (this.state.maybeInArrowParameters) {
              const t = this.lookaheadCharCode();
              if (t === 44 || t === 61 || t === 58 || t === 41) {
                this.setOptionalParametersError(r);
                return e;
              }
            }
            this.expect(17);
            const s = this.state.clone();
            const i = this.state.noArrowAt;
            const n = this.startNodeAt(t);
            let { consequent: a, failed: o } =
              this.tryParseConditionalConsequent();
            let [l, c] = this.getArrowLikeExpressions(a);
            if (o || c.length > 0) {
              const e = [...i];
              if (c.length > 0) {
                this.state = s;
                this.state.noArrowAt = e;
                for (let t = 0; t < c.length; t++) {
                  e.push(c[t].start);
                }
                ({ consequent: a, failed: o } =
                  this.tryParseConditionalConsequent());
                [l, c] = this.getArrowLikeExpressions(a);
              }
              if (o && l.length > 1) {
                this.raise(Z.AmbiguousConditionalArrow, { at: s.startLoc });
              }
              if (o && l.length === 1) {
                this.state = s;
                e.push(l[0].start);
                this.state.noArrowAt = e;
                ({ consequent: a, failed: o } =
                  this.tryParseConditionalConsequent());
              }
            }
            this.getArrowLikeExpressions(a, true);
            this.state.noArrowAt = i;
            this.expect(14);
            n.test = e;
            n.consequent = a;
            n.alternate = this.forwardNoArrowParamsConversionAt(n, () =>
              this.parseMaybeAssign(undefined, undefined),
            );
            return this.finishNode(n, 'ConditionalExpression');
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const e = this.parseMaybeAssignAllowIn();
            const t = !this.match(14);
            this.state.noArrowParamsConversionAt.pop();
            return { consequent: e, failed: t };
          }
          getArrowLikeExpressions(e, t) {
            const r = [e];
            const s = [];
            while (r.length !== 0) {
              const e = r.pop();
              if (e.type === 'ArrowFunctionExpression') {
                if (e.typeParameters || !e.returnType) {
                  this.finishArrowValidation(e);
                } else {
                  s.push(e);
                }
                r.push(e.body);
              } else if (e.type === 'ConditionalExpression') {
                r.push(e.consequent);
                r.push(e.alternate);
              }
            }
            if (t) {
              s.forEach((e) => this.finishArrowValidation(e));
              return [s, []];
            }
            return partition(s, (e) =>
              e.params.every((e) => this.isAssignable(e, true)),
            );
          }
          finishArrowValidation(e) {
            var t;
            this.toAssignableList(
              e.params,
              (t = e.extra) == null ? void 0 : t.trailingCommaLoc,
              false,
            );
            this.scope.enter(2 | 4);
            super.checkParams(e, false, true);
            this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(e, t) {
            let r;
            if (this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1) {
              this.state.noArrowParamsConversionAt.push(this.state.start);
              r = t();
              this.state.noArrowParamsConversionAt.pop();
            } else {
              r = t();
            }
            return r;
          }
          parseParenItem(e, t) {
            e = super.parseParenItem(e, t);
            if (this.eat(17)) {
              e.optional = true;
              this.resetEndLocation(e);
            }
            if (this.match(14)) {
              const r = this.startNodeAt(t);
              r.expression = e;
              r.typeAnnotation = this.flowParseTypeAnnotation();
              return this.finishNode(r, 'TypeCastExpression');
            }
            return e;
          }
          assertModuleNodeAllowed(e) {
            if (
              (e.type === 'ImportDeclaration' &&
                (e.importKind === 'type' || e.importKind === 'typeof')) ||
              (e.type === 'ExportNamedDeclaration' &&
                e.exportKind === 'type') ||
              (e.type === 'ExportAllDeclaration' && e.exportKind === 'type')
            ) {
              return;
            }
            super.assertModuleNodeAllowed(e);
          }
          parseExportDeclaration(e) {
            if (this.isContextual(130)) {
              e.exportKind = 'type';
              const t = this.startNode();
              this.next();
              if (this.match(5)) {
                e.specifiers = this.parseExportSpecifiers(true);
                super.parseExportFrom(e);
                return null;
              } else {
                return this.flowParseTypeAlias(t);
              }
            } else if (this.isContextual(131)) {
              e.exportKind = 'type';
              const t = this.startNode();
              this.next();
              return this.flowParseOpaqueType(t, false);
            } else if (this.isContextual(129)) {
              e.exportKind = 'type';
              const t = this.startNode();
              this.next();
              return this.flowParseInterface(t);
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              e.exportKind = 'value';
              const t = this.startNode();
              this.next();
              return this.flowParseEnumDeclaration(t);
            } else {
              return super.parseExportDeclaration(e);
            }
          }
          eatExportStar(e) {
            if (super.eatExportStar(e)) return true;
            if (this.isContextual(130) && this.lookahead().type === 55) {
              e.exportKind = 'type';
              this.next();
              this.next();
              return true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(e) {
            const { startLoc: t } = this.state;
            const r = super.maybeParseExportNamespaceSpecifier(e);
            if (r && e.exportKind === 'type') {
              this.unexpected(t);
            }
            return r;
          }
          parseClassId(e, t, r) {
            super.parseClassId(e, t, r);
            if (this.match(47)) {
              e.typeParameters = this.flowParseTypeParameterDeclaration();
            }
          }
          parseClassMember(e, t, r) {
            const { startLoc: s } = this.state;
            if (this.isContextual(125)) {
              if (super.parseClassMemberFromModifier(e, t)) {
                return;
              }
              t.declare = true;
            }
            super.parseClassMember(e, t, r);
            if (t.declare) {
              if (
                t.type !== 'ClassProperty' &&
                t.type !== 'ClassPrivateProperty' &&
                t.type !== 'PropertyDefinition'
              ) {
                this.raise(Z.DeclareClassElement, { at: s });
              } else if (t.value) {
                this.raise(Z.DeclareClassFieldInitializer, { at: t.value });
              }
            }
          }
          isIterator(e) {
            return e === 'iterator' || e === 'asyncIterator';
          }
          readIterator() {
            const e = super.readWord1();
            const t = '@@' + e;
            if (!this.isIterator(e) || !this.state.inType) {
              this.raise(u.InvalidIdentifier, {
                at: this.state.curPosition(),
                identifierName: t,
              });
            }
            this.finishToken(132, t);
          }
          getTokenFromCode(e) {
            const t = this.input.charCodeAt(this.state.pos + 1);
            if (e === 123 && t === 124) {
              this.finishOp(6, 2);
            } else if (this.state.inType && (e === 62 || e === 60)) {
              this.finishOp(e === 62 ? 48 : 47, 1);
            } else if (this.state.inType && e === 63) {
              if (t === 46) {
                this.finishOp(18, 2);
              } else {
                this.finishOp(17, 1);
              }
            } else if (
              isIteratorStart(e, t, this.input.charCodeAt(this.state.pos + 2))
            ) {
              this.state.pos += 2;
              this.readIterator();
            } else {
              super.getTokenFromCode(e);
            }
          }
          isAssignable(e, t) {
            if (e.type === 'TypeCastExpression') {
              return this.isAssignable(e.expression, t);
            } else {
              return super.isAssignable(e, t);
            }
          }
          toAssignable(e, t = false) {
            if (
              !t &&
              e.type === 'AssignmentExpression' &&
              e.left.type === 'TypeCastExpression'
            ) {
              e.left = this.typeCastToParameter(e.left);
            }
            super.toAssignable(e, t);
          }
          toAssignableList(e, t, r) {
            for (let t = 0; t < e.length; t++) {
              const r = e[t];
              if ((r == null ? void 0 : r.type) === 'TypeCastExpression') {
                e[t] = this.typeCastToParameter(r);
              }
            }
            super.toAssignableList(e, t, r);
          }
          toReferencedList(e, t) {
            for (let s = 0; s < e.length; s++) {
              var r;
              const i = e[s];
              if (
                i &&
                i.type === 'TypeCastExpression' &&
                !((r = i.extra) != null && r.parenthesized) &&
                (e.length > 1 || !t)
              ) {
                this.raise(Z.TypeCastInPattern, { at: i.typeAnnotation });
              }
            }
            return e;
          }
          parseArrayLike(e, t, r, s) {
            const i = super.parseArrayLike(e, t, r, s);
            if (t && !this.state.maybeInArrowParameters) {
              this.toReferencedList(i.elements);
            }
            return i;
          }
          isValidLVal(e, t, r) {
            return e === 'TypeCastExpression' || super.isValidLVal(e, t, r);
          }
          parseClassProperty(e) {
            if (this.match(14)) {
              e.typeAnnotation = this.flowParseTypeAnnotation();
            }
            return super.parseClassProperty(e);
          }
          parseClassPrivateProperty(e) {
            if (this.match(14)) {
              e.typeAnnotation = this.flowParseTypeAnnotation();
            }
            return super.parseClassPrivateProperty(e);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(e) {
            return !this.match(14) && super.isNonstaticConstructor(e);
          }
          pushClassMethod(e, t, r, s, i, n) {
            if (t.variance) {
              this.unexpected(t.variance.loc.start);
            }
            delete t.variance;
            if (this.match(47)) {
              t.typeParameters = this.flowParseTypeParameterDeclaration();
            }
            super.pushClassMethod(e, t, r, s, i, n);
            if (t.params && i) {
              const e = t.params;
              if (e.length > 0 && this.isThisParam(e[0])) {
                this.raise(Z.ThisParamBannedInConstructor, { at: t });
              }
            } else if (t.type === 'MethodDefinition' && i && t.value.params) {
              const e = t.value.params;
              if (e.length > 0 && this.isThisParam(e[0])) {
                this.raise(Z.ThisParamBannedInConstructor, { at: t });
              }
            }
          }
          pushClassPrivateMethod(e, t, r, s) {
            if (t.variance) {
              this.unexpected(t.variance.loc.start);
            }
            delete t.variance;
            if (this.match(47)) {
              t.typeParameters = this.flowParseTypeParameterDeclaration();
            }
            super.pushClassPrivateMethod(e, t, r, s);
          }
          parseClassSuper(e) {
            super.parseClassSuper(e);
            if (e.superClass && this.match(47)) {
              e.superTypeParameters =
                this.flowParseTypeParameterInstantiation();
            }
            if (this.isContextual(113)) {
              this.next();
              const t = (e.implements = []);
              do {
                const e = this.startNode();
                e.id = this.flowParseRestrictedIdentifier(true);
                if (this.match(47)) {
                  e.typeParameters = this.flowParseTypeParameterInstantiation();
                } else {
                  e.typeParameters = null;
                }
                t.push(this.finishNode(e, 'ClassImplements'));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(e) {
            super.checkGetterSetterParams(e);
            const t = this.getObjectOrClassMethodParams(e);
            if (t.length > 0) {
              const r = t[0];
              if (this.isThisParam(r) && e.kind === 'get') {
                this.raise(Z.GetterMayNotHaveThisParam, { at: r });
              } else if (this.isThisParam(r)) {
                this.raise(Z.SetterMayNotHaveThisParam, { at: r });
              }
            }
          }
          parsePropertyNamePrefixOperator(e) {
            e.variance = this.flowParseVariance();
          }
          parseObjPropValue(e, t, r, s, i, n, a) {
            if (e.variance) {
              this.unexpected(e.variance.loc.start);
            }
            delete e.variance;
            let o;
            if (this.match(47) && !n) {
              o = this.flowParseTypeParameterDeclaration();
              if (!this.match(10)) this.unexpected();
            }
            const l = super.parseObjPropValue(e, t, r, s, i, n, a);
            if (o) {
              (l.value || l).typeParameters = o;
            }
            return l;
          }
          parseAssignableListItemTypes(e) {
            if (this.eat(17)) {
              if (e.type !== 'Identifier') {
                this.raise(Z.PatternIsOptional, { at: e });
              }
              if (this.isThisParam(e)) {
                this.raise(Z.ThisParamMayNotBeOptional, { at: e });
              }
              e.optional = true;
            }
            if (this.match(14)) {
              e.typeAnnotation = this.flowParseTypeAnnotation();
            } else if (this.isThisParam(e)) {
              this.raise(Z.ThisParamAnnotationRequired, { at: e });
            }
            if (this.match(29) && this.isThisParam(e)) {
              this.raise(Z.ThisParamNoDefault, { at: e });
            }
            this.resetEndLocation(e);
            return e;
          }
          parseMaybeDefault(e, t) {
            const r = super.parseMaybeDefault(e, t);
            if (
              r.type === 'AssignmentPattern' &&
              r.typeAnnotation &&
              r.right.start < r.typeAnnotation.start
            ) {
              this.raise(Z.TypeBeforeInitializer, { at: r.typeAnnotation });
            }
            return r;
          }
          checkImportReflection(e) {
            super.checkImportReflection(e);
            if (e.module && e.importKind !== 'value') {
              this.raise(Z.ImportReflectionHasImportType, {
                at: e.specifiers[0].loc.start,
              });
            }
          }
          parseImportSpecifierLocal(e, t, r) {
            t.local = hasTypeImportKind(e)
              ? this.flowParseRestrictedIdentifier(true, true)
              : this.parseIdentifier();
            e.specifiers.push(this.finishImportSpecifier(t, r));
          }
          isPotentialImportPhase(e) {
            if (super.isPotentialImportPhase(e)) return true;
            if (this.isContextual(130)) {
              if (!e) return true;
              const t = this.lookaheadCharCode();
              return t === 123 || t === 42;
            }
            return !e && this.isContextual(87);
          }
          applyImportPhase(e, t, r, s) {
            super.applyImportPhase(e, t, r, s);
            if (t) {
              if (!r && this.match(65)) {
                return;
              }
              e.exportKind = r === 'type' ? r : 'value';
            } else {
              if (r === 'type' && this.match(55)) this.unexpected();
              e.importKind = r === 'type' || r === 'typeof' ? r : 'value';
            }
          }
          parseImportSpecifier(e, t, r, s, i) {
            const n = e.imported;
            let a = null;
            if (n.type === 'Identifier') {
              if (n.name === 'type') {
                a = 'type';
              } else if (n.name === 'typeof') {
                a = 'typeof';
              }
            }
            let o = false;
            if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
              const t = this.parseIdentifier(true);
              if (a !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
                e.imported = t;
                e.importKind = a;
                e.local = cloneIdentifier(t);
              } else {
                e.imported = n;
                e.importKind = null;
                e.local = this.parseIdentifier();
              }
            } else {
              if (a !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
                e.imported = this.parseIdentifier(true);
                e.importKind = a;
              } else {
                if (t) {
                  throw this.raise(u.ImportBindingIsString, {
                    at: e,
                    importName: n.value,
                  });
                }
                e.imported = n;
                e.importKind = null;
              }
              if (this.eatContextual(93)) {
                e.local = this.parseIdentifier();
              } else {
                o = true;
                e.local = cloneIdentifier(e.imported);
              }
            }
            const l = hasTypeImportKind(e);
            if (r && l) {
              this.raise(Z.ImportTypeShorthandOnlyInPureImport, { at: e });
            }
            if (r || l) {
              this.checkReservedType(e.local.name, e.local.loc.start, true);
            }
            if (o && !r && !l) {
              this.checkReservedWord(e.local.name, e.loc.start, true, true);
            }
            return this.finishImportSpecifier(e, 'ImportSpecifier');
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 78:
                return this.parseIdentifier(true);
              default:
                return super.parseBindingAtom();
            }
          }
          parseFunctionParams(e, t) {
            const r = e.kind;
            if (r !== 'get' && r !== 'set' && this.match(47)) {
              e.typeParameters = this.flowParseTypeParameterDeclaration();
            }
            super.parseFunctionParams(e, t);
          }
          parseVarId(e, t) {
            super.parseVarId(e, t);
            if (this.match(14)) {
              e.id.typeAnnotation = this.flowParseTypeAnnotation();
              this.resetEndLocation(e.id);
            }
          }
          parseAsyncArrowFromCallExpression(e, t) {
            if (this.match(14)) {
              const t = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true;
              e.returnType = this.flowParseTypeAnnotation();
              this.state.noAnonFunctionType = t;
            }
            return super.parseAsyncArrowFromCallExpression(e, t);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(e, t) {
            var r;
            let s = null;
            let i;
            if (this.hasPlugin('jsx') && (this.match(142) || this.match(47))) {
              s = this.state.clone();
              i = this.tryParse(() => super.parseMaybeAssign(e, t), s);
              if (!i.error) return i.node;
              const { context: r } = this.state;
              const n = r[r.length - 1];
              if (n === f.j_oTag || n === f.j_expr) {
                r.pop();
              }
            }
            if (((r = i) != null && r.error) || this.match(47)) {
              var n, a;
              s = s || this.state.clone();
              let r;
              const o = this.tryParse((s) => {
                var i;
                r = this.flowParseTypeParameterDeclaration();
                const n = this.forwardNoArrowParamsConversionAt(r, () => {
                  const s = super.parseMaybeAssign(e, t);
                  this.resetStartLocationFromNode(s, r);
                  return s;
                });
                if ((i = n.extra) != null && i.parenthesized) s();
                const a = this.maybeUnwrapTypeCastExpression(n);
                if (a.type !== 'ArrowFunctionExpression') s();
                a.typeParameters = r;
                this.resetStartLocationFromNode(a, r);
                return n;
              }, s);
              let l = null;
              if (
                o.node &&
                this.maybeUnwrapTypeCastExpression(o.node).type ===
                  'ArrowFunctionExpression'
              ) {
                if (!o.error && !o.aborted) {
                  if (o.node.async) {
                    this.raise(
                      Z.UnexpectedTypeParameterBeforeAsyncArrowFunction,
                      { at: r },
                    );
                  }
                  return o.node;
                }
                l = o.node;
              }
              if ((n = i) != null && n.node) {
                this.state = i.failState;
                return i.node;
              }
              if (l) {
                this.state = o.failState;
                return l;
              }
              if ((a = i) != null && a.thrown) throw i.error;
              if (o.thrown) throw o.error;
              throw this.raise(Z.UnexpectedTokenAfterTypeParameter, { at: r });
            }
            return super.parseMaybeAssign(e, t);
          }
          parseArrow(e) {
            if (this.match(14)) {
              const t = this.tryParse(() => {
                const t = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                const r = this.startNode();
                [r.typeAnnotation, e.predicate] =
                  this.flowParseTypeAndPredicateInitialiser();
                this.state.noAnonFunctionType = t;
                if (this.canInsertSemicolon()) this.unexpected();
                if (!this.match(19)) this.unexpected();
                return r;
              });
              if (t.thrown) return null;
              if (t.error) this.state = t.failState;
              e.returnType = t.node.typeAnnotation
                ? this.finishNode(t.node, 'TypeAnnotation')
                : null;
            }
            return super.parseArrow(e);
          }
          shouldParseArrow(e) {
            return this.match(14) || super.shouldParseArrow(e);
          }
          setArrowFunctionParameters(e, t) {
            if (this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1) {
              e.params = t;
            } else {
              super.setArrowFunctionParameters(e, t);
            }
          }
          checkParams(e, t, r, s = true) {
            if (
              r &&
              this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1
            ) {
              return;
            }
            for (let t = 0; t < e.params.length; t++) {
              if (this.isThisParam(e.params[t]) && t > 0) {
                this.raise(Z.ThisParamMustBeFirst, { at: e.params[t] });
              }
            }
            super.checkParams(e, t, r, s);
          }
          parseParenAndDistinguishExpression(e) {
            return super.parseParenAndDistinguishExpression(
              e && this.state.noArrowAt.indexOf(this.state.start) === -1,
            );
          }
          parseSubscripts(e, t, r) {
            if (
              e.type === 'Identifier' &&
              e.name === 'async' &&
              this.state.noArrowAt.indexOf(t.index) !== -1
            ) {
              this.next();
              const r = this.startNodeAt(t);
              r.callee = e;
              r.arguments = super.parseCallExpressionArguments(11, false);
              e = this.finishNode(r, 'CallExpression');
            } else if (
              e.type === 'Identifier' &&
              e.name === 'async' &&
              this.match(47)
            ) {
              const s = this.state.clone();
              const i = this.tryParse(
                (e) => this.parseAsyncArrowWithTypeParameters(t) || e(),
                s,
              );
              if (!i.error && !i.aborted) return i.node;
              const n = this.tryParse(() => super.parseSubscripts(e, t, r), s);
              if (n.node && !n.error) return n.node;
              if (i.node) {
                this.state = i.failState;
                return i.node;
              }
              if (n.node) {
                this.state = n.failState;
                return n.node;
              }
              throw i.error || n.error;
            }
            return super.parseSubscripts(e, t, r);
          }
          parseSubscript(e, t, r, s) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              s.optionalChainMember = true;
              if (r) {
                s.stop = true;
                return e;
              }
              this.next();
              const i = this.startNodeAt(t);
              i.callee = e;
              i.typeArguments = this.flowParseTypeParameterInstantiation();
              this.expect(10);
              i.arguments = this.parseCallExpressionArguments(11, false);
              i.optional = true;
              return this.finishCallExpression(i, true);
            } else if (!r && this.shouldParseTypes() && this.match(47)) {
              const r = this.startNodeAt(t);
              r.callee = e;
              const i = this.tryParse(() => {
                r.typeArguments =
                  this.flowParseTypeParameterInstantiationCallOrNew();
                this.expect(10);
                r.arguments = super.parseCallExpressionArguments(11, false);
                if (s.optionalChainMember) {
                  r.optional = false;
                }
                return this.finishCallExpression(r, s.optionalChainMember);
              });
              if (i.node) {
                if (i.error) this.state = i.failState;
                return i.node;
              }
            }
            return super.parseSubscript(e, t, r, s);
          }
          parseNewCallee(e) {
            super.parseNewCallee(e);
            let t = null;
            if (this.shouldParseTypes() && this.match(47)) {
              t = this.tryParse(() =>
                this.flowParseTypeParameterInstantiationCallOrNew(),
              ).node;
            }
            e.typeArguments = t;
          }
          parseAsyncArrowWithTypeParameters(e) {
            const t = this.startNodeAt(e);
            this.parseFunctionParams(t, false);
            if (!this.parseArrow(t)) return;
            return super.parseArrowExpression(t, undefined, true);
          }
          readToken_mult_modulo(e) {
            const t = this.input.charCodeAt(this.state.pos + 1);
            if (e === 42 && t === 47 && this.state.hasFlowComment) {
              this.state.hasFlowComment = false;
              this.state.pos += 2;
              this.nextToken();
              return;
            }
            super.readToken_mult_modulo(e);
          }
          readToken_pipe_amp(e) {
            const t = this.input.charCodeAt(this.state.pos + 1);
            if (e === 124 && t === 125) {
              this.finishOp(9, 2);
              return;
            }
            super.readToken_pipe_amp(e);
          }
          parseTopLevel(e, t) {
            const r = super.parseTopLevel(e, t);
            if (this.state.hasFlowComment) {
              this.raise(Z.UnterminatedFlowComment, {
                at: this.state.curPosition(),
              });
            }
            return r;
          }
          skipBlockComment() {
            if (this.hasPlugin('flowComments') && this.skipFlowComment()) {
              if (this.state.hasFlowComment) {
                throw this.raise(Z.NestedFlowComment, {
                  at: this.state.startLoc,
                });
              }
              this.hasFlowCommentCompletion();
              const e = this.skipFlowComment();
              if (e) {
                this.state.pos += e;
                this.state.hasFlowComment = true;
              }
              return;
            }
            return super.skipBlockComment(
              this.state.hasFlowComment ? '*-/' : '*/',
            );
          }
          skipFlowComment() {
            const { pos: e } = this.state;
            let t = 2;
            while ([32, 9].includes(this.input.charCodeAt(e + t))) {
              t++;
            }
            const r = this.input.charCodeAt(t + e);
            const s = this.input.charCodeAt(t + e + 1);
            if (r === 58 && s === 58) {
              return t + 2;
            }
            if (this.input.slice(t + e, t + e + 12) === 'flow-include') {
              return t + 12;
            }
            if (r === 58 && s !== 58) {
              return t;
            }
            return false;
          }
          hasFlowCommentCompletion() {
            const e = this.input.indexOf('*/', this.state.pos);
            if (e === -1) {
              throw this.raise(u.UnterminatedComment, {
                at: this.state.curPosition(),
              });
            }
          }
          flowEnumErrorBooleanMemberNotInitialized(
            e,
            { enumName: t, memberName: r },
          ) {
            this.raise(Z.EnumBooleanMemberNotInitialized, {
              at: e,
              memberName: r,
              enumName: t,
            });
          }
          flowEnumErrorInvalidMemberInitializer(e, t) {
            return this.raise(
              !t.explicitType
                ? Z.EnumInvalidMemberInitializerUnknownType
                : t.explicitType === 'symbol'
                ? Z.EnumInvalidMemberInitializerSymbolType
                : Z.EnumInvalidMemberInitializerPrimaryType,
              Object.assign({ at: e }, t),
            );
          }
          flowEnumErrorNumberMemberNotInitialized(
            e,
            { enumName: t, memberName: r },
          ) {
            this.raise(Z.EnumNumberMemberNotInitialized, {
              at: e,
              enumName: t,
              memberName: r,
            });
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(
            e,
            { enumName: t },
          ) {
            this.raise(Z.EnumStringMemberInconsistentlyInitialized, {
              at: e,
              enumName: t,
            });
          }
          flowEnumMemberInit() {
            const e = this.state.startLoc;
            const endOfInit = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 134: {
                const t = this.parseNumericLiteral(this.state.value);
                if (endOfInit()) {
                  return { type: 'number', loc: t.loc.start, value: t };
                }
                return { type: 'invalid', loc: e };
              }
              case 133: {
                const t = this.parseStringLiteral(this.state.value);
                if (endOfInit()) {
                  return { type: 'string', loc: t.loc.start, value: t };
                }
                return { type: 'invalid', loc: e };
              }
              case 85:
              case 86: {
                const t = this.parseBooleanLiteral(this.match(85));
                if (endOfInit()) {
                  return { type: 'boolean', loc: t.loc.start, value: t };
                }
                return { type: 'invalid', loc: e };
              }
              default:
                return { type: 'invalid', loc: e };
            }
          }
          flowEnumMemberRaw() {
            const e = this.state.startLoc;
            const t = this.parseIdentifier(true);
            const r = this.eat(29)
              ? this.flowEnumMemberInit()
              : { type: 'none', loc: e };
            return { id: t, init: r };
          }
          flowEnumCheckExplicitTypeMismatch(e, t, r) {
            const { explicitType: s } = t;
            if (s === null) {
              return;
            }
            if (s !== r) {
              this.flowEnumErrorInvalidMemberInitializer(e, t);
            }
          }
          flowEnumMembers({ enumName: e, explicitType: t }) {
            const r = new Set();
            const s = {
              booleanMembers: [],
              numberMembers: [],
              stringMembers: [],
              defaultedMembers: [],
            };
            let i = false;
            while (!this.match(8)) {
              if (this.eat(21)) {
                i = true;
                break;
              }
              const n = this.startNode();
              const { id: a, init: o } = this.flowEnumMemberRaw();
              const l = a.name;
              if (l === '') {
                continue;
              }
              if (/^[a-z]/.test(l)) {
                this.raise(Z.EnumInvalidMemberName, {
                  at: a,
                  memberName: l,
                  suggestion: l[0].toUpperCase() + l.slice(1),
                  enumName: e,
                });
              }
              if (r.has(l)) {
                this.raise(Z.EnumDuplicateMemberName, {
                  at: a,
                  memberName: l,
                  enumName: e,
                });
              }
              r.add(l);
              const c = { enumName: e, explicitType: t, memberName: l };
              n.id = a;
              switch (o.type) {
                case 'boolean': {
                  this.flowEnumCheckExplicitTypeMismatch(o.loc, c, 'boolean');
                  n.init = o.value;
                  s.booleanMembers.push(
                    this.finishNode(n, 'EnumBooleanMember'),
                  );
                  break;
                }
                case 'number': {
                  this.flowEnumCheckExplicitTypeMismatch(o.loc, c, 'number');
                  n.init = o.value;
                  s.numberMembers.push(this.finishNode(n, 'EnumNumberMember'));
                  break;
                }
                case 'string': {
                  this.flowEnumCheckExplicitTypeMismatch(o.loc, c, 'string');
                  n.init = o.value;
                  s.stringMembers.push(this.finishNode(n, 'EnumStringMember'));
                  break;
                }
                case 'invalid': {
                  throw this.flowEnumErrorInvalidMemberInitializer(o.loc, c);
                }
                case 'none': {
                  switch (t) {
                    case 'boolean':
                      this.flowEnumErrorBooleanMemberNotInitialized(o.loc, c);
                      break;
                    case 'number':
                      this.flowEnumErrorNumberMemberNotInitialized(o.loc, c);
                      break;
                    default:
                      s.defaultedMembers.push(
                        this.finishNode(n, 'EnumDefaultedMember'),
                      );
                  }
                }
              }
              if (!this.match(8)) {
                this.expect(12);
              }
            }
            return { members: s, hasUnknownMembers: i };
          }
          flowEnumStringMembers(e, t, { enumName: r }) {
            if (e.length === 0) {
              return t;
            } else if (t.length === 0) {
              return e;
            } else if (t.length > e.length) {
              for (const t of e) {
                this.flowEnumErrorStringMemberInconsistentlyInitialized(t, {
                  enumName: r,
                });
              }
              return t;
            } else {
              for (const e of t) {
                this.flowEnumErrorStringMemberInconsistentlyInitialized(e, {
                  enumName: r,
                });
              }
              return e;
            }
          }
          flowEnumParseExplicitType({ enumName: e }) {
            if (!this.eatContextual(102)) return null;
            if (!tokenIsIdentifier(this.state.type)) {
              throw this.raise(Z.EnumInvalidExplicitTypeUnknownSupplied, {
                at: this.state.startLoc,
                enumName: e,
              });
            }
            const { value: t } = this.state;
            this.next();
            if (
              t !== 'boolean' &&
              t !== 'number' &&
              t !== 'string' &&
              t !== 'symbol'
            ) {
              this.raise(Z.EnumInvalidExplicitType, {
                at: this.state.startLoc,
                enumName: e,
                invalidEnumType: t,
              });
            }
            return t;
          }
          flowEnumBody(e, t) {
            const r = t.name;
            const s = t.loc.start;
            const i = this.flowEnumParseExplicitType({ enumName: r });
            this.expect(5);
            const { members: n, hasUnknownMembers: a } = this.flowEnumMembers({
              enumName: r,
              explicitType: i,
            });
            e.hasUnknownMembers = a;
            switch (i) {
              case 'boolean':
                e.explicitType = true;
                e.members = n.booleanMembers;
                this.expect(8);
                return this.finishNode(e, 'EnumBooleanBody');
              case 'number':
                e.explicitType = true;
                e.members = n.numberMembers;
                this.expect(8);
                return this.finishNode(e, 'EnumNumberBody');
              case 'string':
                e.explicitType = true;
                e.members = this.flowEnumStringMembers(
                  n.stringMembers,
                  n.defaultedMembers,
                  { enumName: r },
                );
                this.expect(8);
                return this.finishNode(e, 'EnumStringBody');
              case 'symbol':
                e.members = n.defaultedMembers;
                this.expect(8);
                return this.finishNode(e, 'EnumSymbolBody');
              default: {
                const empty = () => {
                  e.members = [];
                  this.expect(8);
                  return this.finishNode(e, 'EnumStringBody');
                };
                e.explicitType = false;
                const t = n.booleanMembers.length;
                const i = n.numberMembers.length;
                const a = n.stringMembers.length;
                const o = n.defaultedMembers.length;
                if (!t && !i && !a && !o) {
                  return empty();
                } else if (!t && !i) {
                  e.members = this.flowEnumStringMembers(
                    n.stringMembers,
                    n.defaultedMembers,
                    { enumName: r },
                  );
                  this.expect(8);
                  return this.finishNode(e, 'EnumStringBody');
                } else if (!i && !a && t >= o) {
                  for (const e of n.defaultedMembers) {
                    this.flowEnumErrorBooleanMemberNotInitialized(e.loc.start, {
                      enumName: r,
                      memberName: e.id.name,
                    });
                  }
                  e.members = n.booleanMembers;
                  this.expect(8);
                  return this.finishNode(e, 'EnumBooleanBody');
                } else if (!t && !a && i >= o) {
                  for (const e of n.defaultedMembers) {
                    this.flowEnumErrorNumberMemberNotInitialized(e.loc.start, {
                      enumName: r,
                      memberName: e.id.name,
                    });
                  }
                  e.members = n.numberMembers;
                  this.expect(8);
                  return this.finishNode(e, 'EnumNumberBody');
                } else {
                  this.raise(Z.EnumInconsistentMemberValues, {
                    at: s,
                    enumName: r,
                  });
                  return empty();
                }
              }
            }
          }
          flowParseEnumDeclaration(e) {
            const t = this.parseIdentifier();
            e.id = t;
            e.body = this.flowEnumBody(this.startNode(), t);
            return this.finishNode(e, 'EnumDeclaration');
          }
          isLookaheadToken_lt() {
            const e = this.nextTokenStart();
            if (this.input.charCodeAt(e) === 60) {
              const t = this.input.charCodeAt(e + 1);
              return t !== 60 && t !== 61;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(e) {
            return e.type === 'TypeCastExpression' ? e.expression : e;
          }
        };
      const re = {
        __proto__: null,
        quot: '"',
        amp: '&',
        apos: "'",
        lt: '<',
        gt: '>',
        nbsp: ' ',
        iexcl: '¡',
        cent: '¢',
        pound: '£',
        curren: '¤',
        yen: '¥',
        brvbar: '¦',
        sect: '§',
        uml: '¨',
        copy: '©',
        ordf: 'ª',
        laquo: '«',
        not: '¬',
        shy: '­',
        reg: '®',
        macr: '¯',
        deg: '°',
        plusmn: '±',
        sup2: '²',
        sup3: '³',
        acute: '´',
        micro: 'µ',
        para: '¶',
        middot: '·',
        cedil: '¸',
        sup1: '¹',
        ordm: 'º',
        raquo: '»',
        frac14: '¼',
        frac12: '½',
        frac34: '¾',
        iquest: '¿',
        Agrave: 'À',
        Aacute: 'Á',
        Acirc: 'Â',
        Atilde: 'Ã',
        Auml: 'Ä',
        Aring: 'Å',
        AElig: 'Æ',
        Ccedil: 'Ç',
        Egrave: 'È',
        Eacute: 'É',
        Ecirc: 'Ê',
        Euml: 'Ë',
        Igrave: 'Ì',
        Iacute: 'Í',
        Icirc: 'Î',
        Iuml: 'Ï',
        ETH: 'Ð',
        Ntilde: 'Ñ',
        Ograve: 'Ò',
        Oacute: 'Ó',
        Ocirc: 'Ô',
        Otilde: 'Õ',
        Ouml: 'Ö',
        times: '×',
        Oslash: 'Ø',
        Ugrave: 'Ù',
        Uacute: 'Ú',
        Ucirc: 'Û',
        Uuml: 'Ü',
        Yacute: 'Ý',
        THORN: 'Þ',
        szlig: 'ß',
        agrave: 'à',
        aacute: 'á',
        acirc: 'â',
        atilde: 'ã',
        auml: 'ä',
        aring: 'å',
        aelig: 'æ',
        ccedil: 'ç',
        egrave: 'è',
        eacute: 'é',
        ecirc: 'ê',
        euml: 'ë',
        igrave: 'ì',
        iacute: 'í',
        icirc: 'î',
        iuml: 'ï',
        eth: 'ð',
        ntilde: 'ñ',
        ograve: 'ò',
        oacute: 'ó',
        ocirc: 'ô',
        otilde: 'õ',
        ouml: 'ö',
        divide: '÷',
        oslash: 'ø',
        ugrave: 'ù',
        uacute: 'ú',
        ucirc: 'û',
        uuml: 'ü',
        yacute: 'ý',
        thorn: 'þ',
        yuml: 'ÿ',
        OElig: 'Œ',
        oelig: 'œ',
        Scaron: 'Š',
        scaron: 'š',
        Yuml: 'Ÿ',
        fnof: 'ƒ',
        circ: 'ˆ',
        tilde: '˜',
        Alpha: 'Α',
        Beta: 'Β',
        Gamma: 'Γ',
        Delta: 'Δ',
        Epsilon: 'Ε',
        Zeta: 'Ζ',
        Eta: 'Η',
        Theta: 'Θ',
        Iota: 'Ι',
        Kappa: 'Κ',
        Lambda: 'Λ',
        Mu: 'Μ',
        Nu: 'Ν',
        Xi: 'Ξ',
        Omicron: 'Ο',
        Pi: 'Π',
        Rho: 'Ρ',
        Sigma: 'Σ',
        Tau: 'Τ',
        Upsilon: 'Υ',
        Phi: 'Φ',
        Chi: 'Χ',
        Psi: 'Ψ',
        Omega: 'Ω',
        alpha: 'α',
        beta: 'β',
        gamma: 'γ',
        delta: 'δ',
        epsilon: 'ε',
        zeta: 'ζ',
        eta: 'η',
        theta: 'θ',
        iota: 'ι',
        kappa: 'κ',
        lambda: 'λ',
        mu: 'μ',
        nu: 'ν',
        xi: 'ξ',
        omicron: 'ο',
        pi: 'π',
        rho: 'ρ',
        sigmaf: 'ς',
        sigma: 'σ',
        tau: 'τ',
        upsilon: 'υ',
        phi: 'φ',
        chi: 'χ',
        psi: 'ψ',
        omega: 'ω',
        thetasym: 'ϑ',
        upsih: 'ϒ',
        piv: 'ϖ',
        ensp: ' ',
        emsp: ' ',
        thinsp: ' ',
        zwnj: '‌',
        zwj: '‍',
        lrm: '‎',
        rlm: '‏',
        ndash: '–',
        mdash: '—',
        lsquo: '‘',
        rsquo: '’',
        sbquo: '‚',
        ldquo: '“',
        rdquo: '”',
        bdquo: '„',
        dagger: '†',
        Dagger: '‡',
        bull: '•',
        hellip: '…',
        permil: '‰',
        prime: '′',
        Prime: '″',
        lsaquo: '‹',
        rsaquo: '›',
        oline: '‾',
        frasl: '⁄',
        euro: '€',
        image: 'ℑ',
        weierp: '℘',
        real: 'ℜ',
        trade: '™',
        alefsym: 'ℵ',
        larr: '←',
        uarr: '↑',
        rarr: '→',
        darr: '↓',
        harr: '↔',
        crarr: '↵',
        lArr: '⇐',
        uArr: '⇑',
        rArr: '⇒',
        dArr: '⇓',
        hArr: '⇔',
        forall: '∀',
        part: '∂',
        exist: '∃',
        empty: '∅',
        nabla: '∇',
        isin: '∈',
        notin: '∉',
        ni: '∋',
        prod: '∏',
        sum: '∑',
        minus: '−',
        lowast: '∗',
        radic: '√',
        prop: '∝',
        infin: '∞',
        ang: '∠',
        and: '∧',
        or: '∨',
        cap: '∩',
        cup: '∪',
        int: '∫',
        there4: '∴',
        sim: '∼',
        cong: '≅',
        asymp: '≈',
        ne: '≠',
        equiv: '≡',
        le: '≤',
        ge: '≥',
        sub: '⊂',
        sup: '⊃',
        nsub: '⊄',
        sube: '⊆',
        supe: '⊇',
        oplus: '⊕',
        otimes: '⊗',
        perp: '⊥',
        sdot: '⋅',
        lceil: '⌈',
        rceil: '⌉',
        lfloor: '⌊',
        rfloor: '⌋',
        lang: '〈',
        rang: '〉',
        loz: '◊',
        spades: '♠',
        clubs: '♣',
        hearts: '♥',
        diams: '♦',
      };
      const se = ParseErrorEnum`jsx`({
        AttributeIsEmpty:
          'JSX attributes must only be assigned a non-empty expression.',
        MissingClosingTagElement: ({ openingTagName: e }) =>
          `Expected corresponding JSX closing tag for <${e}>.`,
        MissingClosingTagFragment:
          'Expected corresponding JSX closing tag for <>.',
        UnexpectedSequenceExpression:
          'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?',
        UnexpectedToken: ({ unexpected: e, HTMLEntity: t }) =>
          `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`,
        UnsupportedJsxValue:
          'JSX value should be either an expression or a quoted JSX text.',
        UnterminatedJsxContent: 'Unterminated JSX contents.',
        UnwrappedAdjacentJSXElements:
          'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?',
      });
      function isFragment(e) {
        return e
          ? e.type === 'JSXOpeningFragment' || e.type === 'JSXClosingFragment'
          : false;
      }
      function getQualifiedJSXName(e) {
        if (e.type === 'JSXIdentifier') {
          return e.name;
        }
        if (e.type === 'JSXNamespacedName') {
          return e.namespace.name + ':' + e.name.name;
        }
        if (e.type === 'JSXMemberExpression') {
          return (
            getQualifiedJSXName(e.object) +
            '.' +
            getQualifiedJSXName(e.property)
          );
        }
        throw new Error('Node had unexpected type: ' + e.type);
      }
      var jsx = (e) =>
        class JSXParserMixin extends e {
          jsxReadToken() {
            let e = '';
            let t = this.state.pos;
            for (;;) {
              if (this.state.pos >= this.length) {
                throw this.raise(se.UnterminatedJsxContent, {
                  at: this.state.startLoc,
                });
              }
              const r = this.input.charCodeAt(this.state.pos);
              switch (r) {
                case 60:
                case 123:
                  if (this.state.pos === this.state.start) {
                    if (r === 60 && this.state.canStartJSXElement) {
                      ++this.state.pos;
                      this.finishToken(142);
                    } else {
                      super.getTokenFromCode(r);
                    }
                    return;
                  }
                  e += this.input.slice(t, this.state.pos);
                  this.finishToken(141, e);
                  return;
                case 38:
                  e += this.input.slice(t, this.state.pos);
                  e += this.jsxReadEntity();
                  t = this.state.pos;
                  break;
                case 62:
                case 125:
                default:
                  if (isNewLine(r)) {
                    e += this.input.slice(t, this.state.pos);
                    e += this.jsxReadNewLine(true);
                    t = this.state.pos;
                  } else {
                    ++this.state.pos;
                  }
              }
            }
          }
          jsxReadNewLine(e) {
            const t = this.input.charCodeAt(this.state.pos);
            let r;
            ++this.state.pos;
            if (t === 13 && this.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos;
              r = e ? '\n' : '\r\n';
            } else {
              r = String.fromCharCode(t);
            }
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            return r;
          }
          jsxReadString(e) {
            let t = '';
            let r = ++this.state.pos;
            for (;;) {
              if (this.state.pos >= this.length) {
                throw this.raise(u.UnterminatedString, {
                  at: this.state.startLoc,
                });
              }
              const s = this.input.charCodeAt(this.state.pos);
              if (s === e) break;
              if (s === 38) {
                t += this.input.slice(r, this.state.pos);
                t += this.jsxReadEntity();
                r = this.state.pos;
              } else if (isNewLine(s)) {
                t += this.input.slice(r, this.state.pos);
                t += this.jsxReadNewLine(false);
                r = this.state.pos;
              } else {
                ++this.state.pos;
              }
            }
            t += this.input.slice(r, this.state.pos++);
            this.finishToken(133, t);
          }
          jsxReadEntity() {
            const e = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos;
              let e = 10;
              if (this.codePointAtPos(this.state.pos) === 120) {
                e = 16;
                ++this.state.pos;
              }
              const t = this.readInt(e, undefined, false, 'bail');
              if (t !== null && this.codePointAtPos(this.state.pos) === 59) {
                ++this.state.pos;
                return String.fromCodePoint(t);
              }
            } else {
              let t = 0;
              let r = false;
              while (
                t++ < 10 &&
                this.state.pos < this.length &&
                !(r = this.codePointAtPos(this.state.pos) == 59)
              ) {
                ++this.state.pos;
              }
              if (r) {
                const t = this.input.slice(e, this.state.pos);
                const r = re[t];
                ++this.state.pos;
                if (r) {
                  return r;
                }
              }
            }
            this.state.pos = e;
            return '&';
          }
          jsxReadWord() {
            let e;
            const t = this.state.pos;
            do {
              e = this.input.charCodeAt(++this.state.pos);
            } while (isIdentifierChar(e) || e === 45);
            this.finishToken(140, this.input.slice(t, this.state.pos));
          }
          jsxParseIdentifier() {
            const e = this.startNode();
            if (this.match(140)) {
              e.name = this.state.value;
            } else if (tokenIsKeyword(this.state.type)) {
              e.name = tokenLabelName(this.state.type);
            } else {
              this.unexpected();
            }
            this.next();
            return this.finishNode(e, 'JSXIdentifier');
          }
          jsxParseNamespacedName() {
            const e = this.state.startLoc;
            const t = this.jsxParseIdentifier();
            if (!this.eat(14)) return t;
            const r = this.startNodeAt(e);
            r.namespace = t;
            r.name = this.jsxParseIdentifier();
            return this.finishNode(r, 'JSXNamespacedName');
          }
          jsxParseElementName() {
            const e = this.state.startLoc;
            let t = this.jsxParseNamespacedName();
            if (t.type === 'JSXNamespacedName') {
              return t;
            }
            while (this.eat(16)) {
              const r = this.startNodeAt(e);
              r.object = t;
              r.property = this.jsxParseIdentifier();
              t = this.finishNode(r, 'JSXMemberExpression');
            }
            return t;
          }
          jsxParseAttributeValue() {
            let e;
            switch (this.state.type) {
              case 5:
                e = this.startNode();
                this.setContext(f.brace);
                this.next();
                e = this.jsxParseExpressionContainer(e, f.j_oTag);
                if (e.expression.type === 'JSXEmptyExpression') {
                  this.raise(se.AttributeIsEmpty, { at: e });
                }
                return e;
              case 142:
              case 133:
                return this.parseExprAtom();
              default:
                throw this.raise(se.UnsupportedJsxValue, {
                  at: this.state.startLoc,
                });
            }
          }
          jsxParseEmptyExpression() {
            const e = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(
              e,
              'JSXEmptyExpression',
              this.state.startLoc,
            );
          }
          jsxParseSpreadChild(e) {
            this.next();
            e.expression = this.parseExpression();
            this.setContext(f.j_expr);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(e, 'JSXSpreadChild');
          }
          jsxParseExpressionContainer(e, t) {
            if (this.match(8)) {
              e.expression = this.jsxParseEmptyExpression();
            } else {
              const t = this.parseExpression();
              e.expression = t;
            }
            this.setContext(t);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(e, 'JSXExpressionContainer');
          }
          jsxParseAttribute() {
            const e = this.startNode();
            if (this.match(5)) {
              this.setContext(f.brace);
              this.next();
              this.expect(21);
              e.argument = this.parseMaybeAssignAllowIn();
              this.setContext(f.j_oTag);
              this.state.canStartJSXElement = true;
              this.expect(8);
              return this.finishNode(e, 'JSXSpreadAttribute');
            }
            e.name = this.jsxParseNamespacedName();
            e.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
            return this.finishNode(e, 'JSXAttribute');
          }
          jsxParseOpeningElementAt(e) {
            const t = this.startNodeAt(e);
            if (this.eat(143)) {
              return this.finishNode(t, 'JSXOpeningFragment');
            }
            t.name = this.jsxParseElementName();
            return this.jsxParseOpeningElementAfterName(t);
          }
          jsxParseOpeningElementAfterName(e) {
            const t = [];
            while (!this.match(56) && !this.match(143)) {
              t.push(this.jsxParseAttribute());
            }
            e.attributes = t;
            e.selfClosing = this.eat(56);
            this.expect(143);
            return this.finishNode(e, 'JSXOpeningElement');
          }
          jsxParseClosingElementAt(e) {
            const t = this.startNodeAt(e);
            if (this.eat(143)) {
              return this.finishNode(t, 'JSXClosingFragment');
            }
            t.name = this.jsxParseElementName();
            this.expect(143);
            return this.finishNode(t, 'JSXClosingElement');
          }
          jsxParseElementAt(e) {
            const t = this.startNodeAt(e);
            const r = [];
            const s = this.jsxParseOpeningElementAt(e);
            let i = null;
            if (!s.selfClosing) {
              e: for (;;) {
                switch (this.state.type) {
                  case 142:
                    e = this.state.startLoc;
                    this.next();
                    if (this.eat(56)) {
                      i = this.jsxParseClosingElementAt(e);
                      break e;
                    }
                    r.push(this.jsxParseElementAt(e));
                    break;
                  case 141:
                    r.push(this.parseExprAtom());
                    break;
                  case 5: {
                    const e = this.startNode();
                    this.setContext(f.brace);
                    this.next();
                    if (this.match(21)) {
                      r.push(this.jsxParseSpreadChild(e));
                    } else {
                      r.push(this.jsxParseExpressionContainer(e, f.j_expr));
                    }
                    break;
                  }
                  default:
                    this.unexpected();
                }
              }
              if (isFragment(s) && !isFragment(i) && i !== null) {
                this.raise(se.MissingClosingTagFragment, { at: i });
              } else if (!isFragment(s) && isFragment(i)) {
                this.raise(se.MissingClosingTagElement, {
                  at: i,
                  openingTagName: getQualifiedJSXName(s.name),
                });
              } else if (!isFragment(s) && !isFragment(i)) {
                if (
                  getQualifiedJSXName(i.name) !== getQualifiedJSXName(s.name)
                ) {
                  this.raise(se.MissingClosingTagElement, {
                    at: i,
                    openingTagName: getQualifiedJSXName(s.name),
                  });
                }
              }
            }
            if (isFragment(s)) {
              t.openingFragment = s;
              t.closingFragment = i;
            } else {
              t.openingElement = s;
              t.closingElement = i;
            }
            t.children = r;
            if (this.match(47)) {
              throw this.raise(se.UnwrappedAdjacentJSXElements, {
                at: this.state.startLoc,
              });
            }
            return isFragment(s)
              ? this.finishNode(t, 'JSXFragment')
              : this.finishNode(t, 'JSXElement');
          }
          jsxParseElement() {
            const e = this.state.startLoc;
            this.next();
            return this.jsxParseElementAt(e);
          }
          setContext(e) {
            const { context: t } = this.state;
            t[t.length - 1] = e;
          }
          parseExprAtom(e) {
            if (this.match(141)) {
              return this.parseLiteral(this.state.value, 'JSXText');
            } else if (this.match(142)) {
              return this.jsxParseElement();
            } else if (
              this.match(47) &&
              this.input.charCodeAt(this.state.pos) !== 33
            ) {
              this.replaceToken(142);
              return this.jsxParseElement();
            } else {
              return super.parseExprAtom(e);
            }
          }
          skipSpace() {
            const e = this.curContext();
            if (!e.preserveSpace) super.skipSpace();
          }
          getTokenFromCode(e) {
            const t = this.curContext();
            if (t === f.j_expr) {
              this.jsxReadToken();
              return;
            }
            if (t === f.j_oTag || t === f.j_cTag) {
              if (isIdentifierStart(e)) {
                this.jsxReadWord();
                return;
              }
              if (e === 62) {
                ++this.state.pos;
                this.finishToken(143);
                return;
              }
              if ((e === 34 || e === 39) && t === f.j_oTag) {
                this.jsxReadString(e);
                return;
              }
            }
            if (
              e === 60 &&
              this.state.canStartJSXElement &&
              this.input.charCodeAt(this.state.pos + 1) !== 33
            ) {
              ++this.state.pos;
              this.finishToken(142);
              return;
            }
            super.getTokenFromCode(e);
          }
          updateContext(e) {
            const { context: t, type: r } = this.state;
            if (r === 56 && e === 142) {
              t.splice(-2, 2, f.j_cTag);
              this.state.canStartJSXElement = false;
            } else if (r === 142) {
              t.push(f.j_oTag);
            } else if (r === 143) {
              const r = t[t.length - 1];
              if ((r === f.j_oTag && e === 56) || r === f.j_cTag) {
                t.pop();
                this.state.canStartJSXElement = t[t.length - 1] === f.j_expr;
              } else {
                this.setContext(f.j_expr);
                this.state.canStartJSXElement = true;
              }
            } else {
              this.state.canStartJSXElement = tokenComesBeforeExpression(r);
            }
          }
        };
      class TypeScriptScope extends Scope {
        constructor(...e) {
          super(...e);
          this.types = new Set();
          this.enums = new Set();
          this.constEnums = new Set();
          this.classes = new Set();
          this.exportOnlyBindings = new Set();
        }
      }
      class TypeScriptScopeHandler extends ScopeHandler {
        constructor(...e) {
          super(...e);
          this.importsStack = [];
        }
        createScope(e) {
          this.importsStack.push(new Set());
          return new TypeScriptScope(e);
        }
        enter(e) {
          if (e == 256) {
            this.importsStack.push(new Set());
          }
          super.enter(e);
        }
        exit() {
          const e = super.exit();
          if (e == 256) {
            this.importsStack.pop();
          }
          return e;
        }
        hasImport(e, t) {
          const r = this.importsStack.length;
          if (this.importsStack[r - 1].has(e)) {
            return true;
          }
          if (!t && r > 1) {
            for (let t = 0; t < r - 1; t++) {
              if (this.importsStack[t].has(e)) return true;
            }
          }
          return false;
        }
        declareName(e, t, r) {
          if (t & 4096) {
            if (this.hasImport(e, true)) {
              this.parser.raise(u.VarRedeclaration, {
                at: r,
                identifierName: e,
              });
            }
            this.importsStack[this.importsStack.length - 1].add(e);
            return;
          }
          const s = this.currentScope();
          if (t & 1024) {
            this.maybeExportDefined(s, e);
            s.exportOnlyBindings.add(e);
            return;
          }
          super.declareName(e, t, r);
          if (t & 2) {
            if (!(t & 1)) {
              this.checkRedeclarationInScope(s, e, t, r);
              this.maybeExportDefined(s, e);
            }
            s.types.add(e);
          }
          if (t & 256) s.enums.add(e);
          if (t & 512) {
            s.constEnums.add(e);
          }
          if (t & 128) s.classes.add(e);
        }
        isRedeclaredInScope(e, t, r) {
          if (e.enums.has(t)) {
            if (r & 256) {
              const s = !!(r & 512);
              const i = e.constEnums.has(t);
              return s !== i;
            }
            return true;
          }
          if (r & 128 && e.classes.has(t)) {
            if (e.lexical.has(t)) {
              return !!(r & 1);
            } else {
              return false;
            }
          }
          if (r & 2 && e.types.has(t)) {
            return true;
          }
          return super.isRedeclaredInScope(e, t, r);
        }
        checkLocalExport(e) {
          const { name: t } = e;
          if (this.hasImport(t)) return;
          const r = this.scopeStack.length;
          for (let e = r - 1; e >= 0; e--) {
            const r = this.scopeStack[e];
            if (r.types.has(t) || r.exportOnlyBindings.has(t)) return;
          }
          super.checkLocalExport(e);
        }
      }
      const getOwn$1 = (e, t) => Object.hasOwnProperty.call(e, t) && e[t];
      const unwrapParenthesizedExpression = (e) =>
        e.type === 'ParenthesizedExpression'
          ? unwrapParenthesizedExpression(e.expression)
          : e;
      class LValParser extends NodeUtils {
        toAssignable(e, t = false) {
          var r, s;
          let i = undefined;
          if (
            e.type === 'ParenthesizedExpression' ||
            ((r = e.extra) != null && r.parenthesized)
          ) {
            i = unwrapParenthesizedExpression(e);
            if (t) {
              if (i.type === 'Identifier') {
                this.expressionScope.recordArrowParameterBindingError(
                  u.InvalidParenthesizedAssignment,
                  { at: e },
                );
              } else if (
                i.type !== 'MemberExpression' &&
                !this.isOptionalMemberExpression(i)
              ) {
                this.raise(u.InvalidParenthesizedAssignment, { at: e });
              }
            } else {
              this.raise(u.InvalidParenthesizedAssignment, { at: e });
            }
          }
          switch (e.type) {
            case 'Identifier':
            case 'ObjectPattern':
            case 'ArrayPattern':
            case 'AssignmentPattern':
            case 'RestElement':
              break;
            case 'ObjectExpression':
              e.type = 'ObjectPattern';
              for (let r = 0, s = e.properties.length, i = s - 1; r < s; r++) {
                var n;
                const s = e.properties[r];
                const a = r === i;
                this.toAssignableObjectExpressionProp(s, a, t);
                if (
                  a &&
                  s.type === 'RestElement' &&
                  (n = e.extra) != null &&
                  n.trailingCommaLoc
                ) {
                  this.raise(u.RestTrailingComma, {
                    at: e.extra.trailingCommaLoc,
                  });
                }
              }
              break;
            case 'ObjectProperty': {
              const { key: r, value: s } = e;
              if (this.isPrivateName(r)) {
                this.classScope.usePrivateName(
                  this.getPrivateNameSV(r),
                  r.loc.start,
                );
              }
              this.toAssignable(s, t);
              break;
            }
            case 'SpreadElement': {
              throw new Error(
                'Internal @babel/parser error (this is a bug, please report it).' +
                  " SpreadElement should be converted by .toAssignable's caller.",
              );
            }
            case 'ArrayExpression':
              e.type = 'ArrayPattern';
              this.toAssignableList(
                e.elements,
                (s = e.extra) == null ? void 0 : s.trailingCommaLoc,
                t,
              );
              break;
            case 'AssignmentExpression':
              if (e.operator !== '=') {
                this.raise(u.MissingEqInAssignment, { at: e.left.loc.end });
              }
              e.type = 'AssignmentPattern';
              delete e.operator;
              this.toAssignable(e.left, t);
              break;
            case 'ParenthesizedExpression':
              this.toAssignable(i, t);
              break;
          }
        }
        toAssignableObjectExpressionProp(e, t, r) {
          if (e.type === 'ObjectMethod') {
            this.raise(
              e.kind === 'get' || e.kind === 'set'
                ? u.PatternHasAccessor
                : u.PatternHasMethod,
              { at: e.key },
            );
          } else if (e.type === 'SpreadElement') {
            e.type = 'RestElement';
            const s = e.argument;
            this.checkToRestConversion(s, false);
            this.toAssignable(s, r);
            if (!t) {
              this.raise(u.RestTrailingComma, { at: e });
            }
          } else {
            this.toAssignable(e, r);
          }
        }
        toAssignableList(e, t, r) {
          const s = e.length - 1;
          for (let i = 0; i <= s; i++) {
            const n = e[i];
            if (!n) continue;
            if (n.type === 'SpreadElement') {
              n.type = 'RestElement';
              const e = n.argument;
              this.checkToRestConversion(e, true);
              this.toAssignable(e, r);
            } else {
              this.toAssignable(n, r);
            }
            if (n.type === 'RestElement') {
              if (i < s) {
                this.raise(u.RestTrailingComma, { at: n });
              } else if (t) {
                this.raise(u.RestTrailingComma, { at: t });
              }
            }
          }
        }
        isAssignable(e, t) {
          switch (e.type) {
            case 'Identifier':
            case 'ObjectPattern':
            case 'ArrayPattern':
            case 'AssignmentPattern':
            case 'RestElement':
              return true;
            case 'ObjectExpression': {
              const t = e.properties.length - 1;
              return e.properties.every(
                (e, r) =>
                  e.type !== 'ObjectMethod' &&
                  (r === t || e.type !== 'SpreadElement') &&
                  this.isAssignable(e),
              );
            }
            case 'ObjectProperty':
              return this.isAssignable(e.value);
            case 'SpreadElement':
              return this.isAssignable(e.argument);
            case 'ArrayExpression':
              return e.elements.every(
                (e) => e === null || this.isAssignable(e),
              );
            case 'AssignmentExpression':
              return e.operator === '=';
            case 'ParenthesizedExpression':
              return this.isAssignable(e.expression);
            case 'MemberExpression':
            case 'OptionalMemberExpression':
              return !t;
            default:
              return false;
          }
        }
        toReferencedList(e, t) {
          return e;
        }
        toReferencedListDeep(e, t) {
          this.toReferencedList(e, t);
          for (const t of e) {
            if ((t == null ? void 0 : t.type) === 'ArrayExpression') {
              this.toReferencedListDeep(t.elements);
            }
          }
        }
        parseSpread(e) {
          const t = this.startNode();
          this.next();
          t.argument = this.parseMaybeAssignAllowIn(e, undefined);
          return this.finishNode(t, 'SpreadElement');
        }
        parseRestBinding() {
          const e = this.startNode();
          this.next();
          e.argument = this.parseBindingAtom();
          return this.finishNode(e, 'RestElement');
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 0: {
              const e = this.startNode();
              this.next();
              e.elements = this.parseBindingList(3, 93, 1);
              return this.finishNode(e, 'ArrayPattern');
            }
            case 5:
              return this.parseObjectLike(8, true);
          }
          return this.parseIdentifier();
        }
        parseBindingList(e, t, r) {
          const s = r & 1;
          const i = [];
          let n = true;
          while (!this.eat(e)) {
            if (n) {
              n = false;
            } else {
              this.expect(12);
            }
            if (s && this.match(12)) {
              i.push(null);
            } else if (this.eat(e)) {
              break;
            } else if (this.match(21)) {
              i.push(
                this.parseAssignableListItemTypes(this.parseRestBinding(), r),
              );
              if (!this.checkCommaAfterRest(t)) {
                this.expect(e);
                break;
              }
            } else {
              const e = [];
              if (this.match(26) && this.hasPlugin('decorators')) {
                this.raise(u.UnsupportedParameterDecorator, {
                  at: this.state.startLoc,
                });
              }
              while (this.match(26)) {
                e.push(this.parseDecorator());
              }
              i.push(this.parseAssignableListItem(r, e));
            }
          }
          return i;
        }
        parseBindingRestProperty(e) {
          this.next();
          e.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(e, 'RestElement');
        }
        parseBindingProperty() {
          const e = this.startNode();
          const { type: t, startLoc: r } = this.state;
          if (t === 21) {
            return this.parseBindingRestProperty(e);
          } else if (t === 138) {
            this.expectPlugin('destructuringPrivate', r);
            this.classScope.usePrivateName(this.state.value, r);
            e.key = this.parsePrivateName();
          } else {
            this.parsePropertyName(e);
          }
          e.method = false;
          return this.parseObjPropValue(e, r, false, false, true, false);
        }
        parseAssignableListItem(e, t) {
          const r = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(r, e);
          const s = this.parseMaybeDefault(r.loc.start, r);
          if (t.length) {
            r.decorators = t;
          }
          return s;
        }
        parseAssignableListItemTypes(e, t) {
          return e;
        }
        parseMaybeDefault(e, t) {
          var r, s;
          (r = e) != null ? r : (e = this.state.startLoc);
          t = (s = t) != null ? s : this.parseBindingAtom();
          if (!this.eat(29)) return t;
          const i = this.startNodeAt(e);
          i.left = t;
          i.right = this.parseMaybeAssignAllowIn();
          return this.finishNode(i, 'AssignmentPattern');
        }
        isValidLVal(e, t, r) {
          return getOwn$1(
            {
              AssignmentPattern: 'left',
              RestElement: 'argument',
              ObjectProperty: 'value',
              ParenthesizedExpression: 'expression',
              ArrayPattern: 'elements',
              ObjectPattern: 'properties',
            },
            e,
          );
        }
        isOptionalMemberExpression(e) {
          return e.type === 'OptionalMemberExpression';
        }
        checkLVal(
          e,
          {
            in: t,
            binding: r = 64,
            checkClashes: s = false,
            strictModeChanged: i = false,
            hasParenthesizedAncestor: n = false,
          },
        ) {
          var a;
          const o = e.type;
          if (this.isObjectMethod(e)) return;
          const l = this.isOptionalMemberExpression(e);
          if (l || o === 'MemberExpression') {
            if (l) {
              this.expectPlugin('optionalChainingAssign', e.loc.start);
              if (t.type !== 'AssignmentExpression') {
                this.raise(u.InvalidLhsOptionalChaining, {
                  at: e,
                  ancestor: t,
                });
              }
            }
            if (r !== 64) {
              this.raise(u.InvalidPropertyBindingPattern, { at: e });
            }
            return;
          }
          if (o === 'Identifier') {
            this.checkIdentifier(e, r, i);
            const { name: t } = e;
            if (s) {
              if (s.has(t)) {
                this.raise(u.ParamDupe, { at: e });
              } else {
                s.add(t);
              }
            }
            return;
          }
          const c = this.isValidLVal(
            o,
            !(n || ((a = e.extra) != null && a.parenthesized)) &&
              t.type === 'AssignmentExpression',
            r,
          );
          if (c === true) return;
          if (c === false) {
            const s = r === 64 ? u.InvalidLhs : u.InvalidLhsBinding;
            this.raise(s, { at: e, ancestor: t });
            return;
          }
          const [p, d] = Array.isArray(c)
            ? c
            : [c, o === 'ParenthesizedExpression'];
          const f =
            o === 'ArrayPattern' || o === 'ObjectPattern' ? { type: o } : t;
          for (const t of [].concat(e[p])) {
            if (t) {
              this.checkLVal(t, {
                in: f,
                binding: r,
                checkClashes: s,
                strictModeChanged: i,
                hasParenthesizedAncestor: d,
              });
            }
          }
        }
        checkIdentifier(e, t, r = false) {
          if (
            this.state.strict &&
            (r
              ? isStrictBindReservedWord(e.name, this.inModule)
              : isStrictBindOnlyReservedWord(e.name))
          ) {
            if (t === 64) {
              this.raise(u.StrictEvalArguments, {
                at: e,
                referenceName: e.name,
              });
            } else {
              this.raise(u.StrictEvalArgumentsBinding, {
                at: e,
                bindingName: e.name,
              });
            }
          }
          if (t & 8192 && e.name === 'let') {
            this.raise(u.LetInLexicalBinding, { at: e });
          }
          if (!(t & 64)) {
            this.declareNameFromIdentifier(e, t);
          }
        }
        declareNameFromIdentifier(e, t) {
          this.scope.declareName(e.name, t, e.loc.start);
        }
        checkToRestConversion(e, t) {
          switch (e.type) {
            case 'ParenthesizedExpression':
              this.checkToRestConversion(e.expression, t);
              break;
            case 'Identifier':
            case 'MemberExpression':
              break;
            case 'ArrayExpression':
            case 'ObjectExpression':
              if (t) break;
            default:
              this.raise(u.InvalidRestAssignmentPattern, { at: e });
          }
        }
        checkCommaAfterRest(e) {
          if (!this.match(12)) {
            return false;
          }
          this.raise(
            this.lookaheadCharCode() === e
              ? u.RestTrailingComma
              : u.ElementAfterRest,
            { at: this.state.startLoc },
          );
          return true;
        }
      }
      const getOwn = (e, t) => Object.hasOwnProperty.call(e, t) && e[t];
      function nonNull(e) {
        if (e == null) {
          throw new Error(`Unexpected ${e} value.`);
        }
        return e;
      }
      function assert(e) {
        if (!e) {
          throw new Error('Assert fail');
        }
      }
      const ie = ParseErrorEnum`typescript`({
        AbstractMethodHasImplementation: ({ methodName: e }) =>
          `Method '${e}' cannot have an implementation because it is marked abstract.`,
        AbstractPropertyHasInitializer: ({ propertyName: e }) =>
          `Property '${e}' cannot have an initializer because it is marked abstract.`,
        AccesorCannotDeclareThisParameter:
          "'get' and 'set' accessors cannot declare 'this' parameters.",
        AccesorCannotHaveTypeParameters:
          'An accessor cannot have type parameters.',
        AccessorCannotBeOptional:
          "An 'accessor' property cannot be declared optional.",
        ClassMethodHasDeclare:
          "Class methods cannot have the 'declare' modifier.",
        ClassMethodHasReadonly:
          "Class methods cannot have the 'readonly' modifier.",
        ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference:
          "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
        ConstructorHasTypeParameters:
          'Type parameters cannot appear on a constructor declaration.',
        DeclareAccessor: ({ kind: e }) =>
          `'declare' is not allowed in ${e}ters.`,
        DeclareClassFieldHasInitializer:
          'Initializers are not allowed in ambient contexts.',
        DeclareFunctionHasImplementation:
          'An implementation cannot be declared in ambient contexts.',
        DuplicateAccessibilityModifier: ({ modifier: e }) =>
          `Accessibility modifier already seen.`,
        DuplicateModifier: ({ modifier: e }) => `Duplicate modifier: '${e}'.`,
        EmptyHeritageClauseType: ({ token: e }) =>
          `'${e}' list cannot be empty.`,
        EmptyTypeArguments: 'Type argument list cannot be empty.',
        EmptyTypeParameters: 'Type parameter list cannot be empty.',
        ExpectedAmbientAfterExportDeclare:
          "'export declare' must be followed by an ambient declaration.",
        ImportAliasHasImportType: "An import alias can not use 'import type'.",
        ImportReflectionHasImportType:
          'An `import module` declaration can not use `type` modifier',
        IncompatibleModifiers: ({ modifiers: e }) =>
          `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`,
        IndexSignatureHasAbstract:
          "Index signatures cannot have the 'abstract' modifier.",
        IndexSignatureHasAccessibility: ({ modifier: e }) =>
          `Index signatures cannot have an accessibility modifier ('${e}').`,
        IndexSignatureHasDeclare:
          "Index signatures cannot have the 'declare' modifier.",
        IndexSignatureHasOverride:
          "'override' modifier cannot appear on an index signature.",
        IndexSignatureHasStatic:
          "Index signatures cannot have the 'static' modifier.",
        InitializerNotAllowedInAmbientContext:
          'Initializers are not allowed in ambient contexts.',
        InvalidModifierOnTypeMember: ({ modifier: e }) =>
          `'${e}' modifier cannot appear on a type member.`,
        InvalidModifierOnTypeParameter: ({ modifier: e }) =>
          `'${e}' modifier cannot appear on a type parameter.`,
        InvalidModifierOnTypeParameterPositions: ({ modifier: e }) =>
          `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`,
        InvalidModifiersOrder: ({ orderedModifiers: e }) =>
          `'${e[0]}' modifier must precede '${e[1]}' modifier.`,
        InvalidPropertyAccessAfterInstantiationExpression:
          'Invalid property access after an instantiation expression. ' +
          'You can either wrap the instantiation expression in parentheses, or delete the type arguments.',
        InvalidTupleMemberLabel:
          'Tuple members must be labeled with a simple identifier.',
        MissingInterfaceName:
          "'interface' declarations must be followed by an identifier.",
        NonAbstractClassHasAbstractMethod:
          'Abstract methods can only appear within an abstract class.',
        NonClassMethodPropertyHasAbstractModifer:
          "'abstract' modifier can only appear on a class, method, or property declaration.",
        OptionalTypeBeforeRequired:
          'A required element cannot follow an optional element.',
        OverrideNotInSubClass:
          "This member cannot have an 'override' modifier because its containing class does not extend another class.",
        PatternIsOptional:
          'A binding pattern parameter cannot be optional in an implementation signature.',
        PrivateElementHasAbstract:
          "Private elements cannot have the 'abstract' modifier.",
        PrivateElementHasAccessibility: ({ modifier: e }) =>
          `Private elements cannot have an accessibility modifier ('${e}').`,
        ReadonlyForMethodSignature:
          "'readonly' modifier can only appear on a property declaration or index signature.",
        ReservedArrowTypeParam:
          'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.',
        ReservedTypeAssertion:
          'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.',
        SetAccesorCannotHaveOptionalParameter:
          "A 'set' accessor cannot have an optional parameter.",
        SetAccesorCannotHaveRestParameter:
          "A 'set' accessor cannot have rest parameter.",
        SetAccesorCannotHaveReturnType:
          "A 'set' accessor cannot have a return type annotation.",
        SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: e }) =>
          `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`,
        StaticBlockCannotHaveModifier:
          'Static class blocks cannot have any modifier.',
        TupleOptionalAfterType:
          'A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).',
        TypeAnnotationAfterAssign:
          'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
        TypeImportCannotSpecifyDefaultAndNamed:
          'A type-only import can specify a default import or named bindings, but not both.',
        TypeModifierIsUsedInTypeExports:
          "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
        TypeModifierIsUsedInTypeImports:
          "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
        UnexpectedParameterModifier:
          'A parameter property is only allowed in a constructor implementation.',
        UnexpectedReadonly:
          "'readonly' type modifier is only permitted on array and tuple literal types.",
        UnexpectedTypeAnnotation: 'Did not expect a type annotation here.',
        UnexpectedTypeCastInParameter:
          'Unexpected type cast in parameter position.',
        UnsupportedImportTypeArgument:
          'Argument in a type import must be a string literal.',
        UnsupportedParameterPropertyKind:
          'A parameter property may not be declared using a binding pattern.',
        UnsupportedSignatureParameterKind: ({ type: e }) =>
          `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`,
      });
      function keywordTypeFromName(e) {
        switch (e) {
          case 'any':
            return 'TSAnyKeyword';
          case 'boolean':
            return 'TSBooleanKeyword';
          case 'bigint':
            return 'TSBigIntKeyword';
          case 'never':
            return 'TSNeverKeyword';
          case 'number':
            return 'TSNumberKeyword';
          case 'object':
            return 'TSObjectKeyword';
          case 'string':
            return 'TSStringKeyword';
          case 'symbol':
            return 'TSSymbolKeyword';
          case 'undefined':
            return 'TSUndefinedKeyword';
          case 'unknown':
            return 'TSUnknownKeyword';
          default:
            return undefined;
        }
      }
      function tsIsAccessModifier(e) {
        return e === 'private' || e === 'public' || e === 'protected';
      }
      function tsIsVarianceAnnotations(e) {
        return e === 'in' || e === 'out';
      }
      var typescript = (e) =>
        class TypeScriptParserMixin extends e {
          constructor(...e) {
            super(...e);
            this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
              allowedModifiers: ['in', 'out'],
              disallowedModifiers: [
                'const',
                'public',
                'private',
                'protected',
                'readonly',
                'declare',
                'abstract',
                'override',
              ],
              errorTemplate: ie.InvalidModifierOnTypeParameter,
            });
            this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
              allowedModifiers: ['const'],
              disallowedModifiers: ['in', 'out'],
              errorTemplate: ie.InvalidModifierOnTypeParameterPositions,
            });
            this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
              allowedModifiers: ['in', 'out', 'const'],
              disallowedModifiers: [
                'public',
                'private',
                'protected',
                'readonly',
                'declare',
                'abstract',
                'override',
              ],
              errorTemplate: ie.InvalidModifierOnTypeParameter,
            });
          }
          getScopeHandler() {
            return TypeScriptScopeHandler;
          }
          tsIsIdentifier() {
            return tokenIsIdentifier(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (
              (this.match(0) ||
                this.match(5) ||
                this.match(55) ||
                this.match(21) ||
                this.match(138) ||
                this.isLiteralPropertyName()) &&
              !this.hasPrecedingLineBreak()
            );
          }
          tsNextTokenCanFollowModifier() {
            this.next();
            return this.tsTokenCanFollowModifier();
          }
          tsParseModifier(e, t) {
            if (
              !tokenIsIdentifier(this.state.type) &&
              this.state.type !== 58 &&
              this.state.type !== 75
            ) {
              return undefined;
            }
            const r = this.state.value;
            if (e.indexOf(r) !== -1) {
              if (t && this.tsIsStartOfStaticBlocks()) {
                return undefined;
              }
              if (
                this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))
              ) {
                return r;
              }
            }
            return undefined;
          }
          tsParseModifiers(
            {
              allowedModifiers: e,
              disallowedModifiers: t,
              stopOnStartOfClassStaticBlock: r,
              errorTemplate: s = ie.InvalidModifierOnTypeMember,
            },
            i,
          ) {
            const enforceOrder = (e, t, r, s) => {
              if (t === r && i[s]) {
                this.raise(ie.InvalidModifiersOrder, {
                  at: e,
                  orderedModifiers: [r, s],
                });
              }
            };
            const incompatible = (e, t, r, s) => {
              if ((i[r] && t === s) || (i[s] && t === r)) {
                this.raise(ie.IncompatibleModifiers, {
                  at: e,
                  modifiers: [r, s],
                });
              }
            };
            for (;;) {
              const { startLoc: n } = this.state;
              const a = this.tsParseModifier(e.concat(t != null ? t : []), r);
              if (!a) break;
              if (tsIsAccessModifier(a)) {
                if (i.accessibility) {
                  this.raise(ie.DuplicateAccessibilityModifier, {
                    at: n,
                    modifier: a,
                  });
                } else {
                  enforceOrder(n, a, a, 'override');
                  enforceOrder(n, a, a, 'static');
                  enforceOrder(n, a, a, 'readonly');
                  i.accessibility = a;
                }
              } else if (tsIsVarianceAnnotations(a)) {
                if (i[a]) {
                  this.raise(ie.DuplicateModifier, { at: n, modifier: a });
                }
                i[a] = true;
                enforceOrder(n, a, 'in', 'out');
              } else {
                if (Object.hasOwnProperty.call(i, a)) {
                  this.raise(ie.DuplicateModifier, { at: n, modifier: a });
                } else {
                  enforceOrder(n, a, 'static', 'readonly');
                  enforceOrder(n, a, 'static', 'override');
                  enforceOrder(n, a, 'override', 'readonly');
                  enforceOrder(n, a, 'abstract', 'override');
                  incompatible(n, a, 'declare', 'override');
                  incompatible(n, a, 'static', 'abstract');
                }
                i[a] = true;
              }
              if (t != null && t.includes(a)) {
                this.raise(s, { at: n, modifier: a });
              }
            }
          }
          tsIsListTerminator(e) {
            switch (e) {
              case 'EnumMembers':
              case 'TypeMembers':
                return this.match(8);
              case 'HeritageClauseElement':
                return this.match(5);
              case 'TupleElementTypes':
                return this.match(3);
              case 'TypeParametersOrArguments':
                return this.match(48);
            }
          }
          tsParseList(e, t) {
            const r = [];
            while (!this.tsIsListTerminator(e)) {
              r.push(t());
            }
            return r;
          }
          tsParseDelimitedList(e, t, r) {
            return nonNull(this.tsParseDelimitedListWorker(e, t, true, r));
          }
          tsParseDelimitedListWorker(e, t, r, s) {
            const i = [];
            let n = -1;
            for (;;) {
              if (this.tsIsListTerminator(e)) {
                break;
              }
              n = -1;
              const s = t();
              if (s == null) {
                return undefined;
              }
              i.push(s);
              if (this.eat(12)) {
                n = this.state.lastTokStart;
                continue;
              }
              if (this.tsIsListTerminator(e)) {
                break;
              }
              if (r) {
                this.expect(12);
              }
              return undefined;
            }
            if (s) {
              s.value = n;
            }
            return i;
          }
          tsParseBracketedList(e, t, r, s, i) {
            if (!s) {
              if (r) {
                this.expect(0);
              } else {
                this.expect(47);
              }
            }
            const n = this.tsParseDelimitedList(e, t, i);
            if (r) {
              this.expect(3);
            } else {
              this.expect(48);
            }
            return n;
          }
          tsParseImportType() {
            const e = this.startNode();
            this.expect(83);
            this.expect(10);
            if (!this.match(133)) {
              this.raise(ie.UnsupportedImportTypeArgument, {
                at: this.state.startLoc,
              });
            }
            e.argument = super.parseExprAtom();
            this.expect(11);
            if (this.eat(16)) {
              e.qualifier = this.tsParseEntityName();
            }
            if (this.match(47)) {
              e.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(e, 'TSImportType');
          }
          tsParseEntityName(e = true) {
            let t = this.parseIdentifier(e);
            while (this.eat(16)) {
              const r = this.startNodeAtNode(t);
              r.left = t;
              r.right = this.parseIdentifier(e);
              t = this.finishNode(r, 'TSQualifiedName');
            }
            return t;
          }
          tsParseTypeReference() {
            const e = this.startNode();
            e.typeName = this.tsParseEntityName();
            if (!this.hasPrecedingLineBreak() && this.match(47)) {
              e.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(e, 'TSTypeReference');
          }
          tsParseThisTypePredicate(e) {
            this.next();
            const t = this.startNodeAtNode(e);
            t.parameterName = e;
            t.typeAnnotation = this.tsParseTypeAnnotation(false);
            t.asserts = false;
            return this.finishNode(t, 'TSTypePredicate');
          }
          tsParseThisTypeNode() {
            const e = this.startNode();
            this.next();
            return this.finishNode(e, 'TSThisType');
          }
          tsParseTypeQuery() {
            const e = this.startNode();
            this.expect(87);
            if (this.match(83)) {
              e.exprName = this.tsParseImportType();
            } else {
              e.exprName = this.tsParseEntityName();
            }
            if (!this.hasPrecedingLineBreak() && this.match(47)) {
              e.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(e, 'TSTypeQuery');
          }
          tsParseTypeParameter(e) {
            const t = this.startNode();
            e(t);
            t.name = this.tsParseTypeParameterName();
            t.constraint = this.tsEatThenParseType(81);
            t.default = this.tsEatThenParseType(29);
            return this.finishNode(t, 'TSTypeParameter');
          }
          tsTryParseTypeParameters(e) {
            if (this.match(47)) {
              return this.tsParseTypeParameters(e);
            }
          }
          tsParseTypeParameters(e) {
            const t = this.startNode();
            if (this.match(47) || this.match(142)) {
              this.next();
            } else {
              this.unexpected();
            }
            const r = { value: -1 };
            t.params = this.tsParseBracketedList(
              'TypeParametersOrArguments',
              this.tsParseTypeParameter.bind(this, e),
              false,
              true,
              r,
            );
            if (t.params.length === 0) {
              this.raise(ie.EmptyTypeParameters, { at: t });
            }
            if (r.value !== -1) {
              this.addExtra(t, 'trailingComma', r.value);
            }
            return this.finishNode(t, 'TSTypeParameterDeclaration');
          }
          tsFillSignature(e, t) {
            const r = e === 19;
            const s = 'parameters';
            const i = 'typeAnnotation';
            t.typeParameters = this.tsTryParseTypeParameters(
              this.tsParseConstModifier,
            );
            this.expect(10);
            t[s] = this.tsParseBindingListForSignature();
            if (r) {
              t[i] = this.tsParseTypeOrTypePredicateAnnotation(e);
            } else if (this.match(e)) {
              t[i] = this.tsParseTypeOrTypePredicateAnnotation(e);
            }
          }
          tsParseBindingListForSignature() {
            const e = super.parseBindingList(11, 41, 2);
            for (const t of e) {
              const { type: e } = t;
              if (e === 'AssignmentPattern' || e === 'TSParameterProperty') {
                this.raise(ie.UnsupportedSignatureParameterKind, {
                  at: t,
                  type: e,
                });
              }
            }
            return e;
          }
          tsParseTypeMemberSemicolon() {
            if (!this.eat(12) && !this.isLineTerminator()) {
              this.expect(13);
            }
          }
          tsParseSignatureMember(e, t) {
            this.tsFillSignature(14, t);
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(t, e);
          }
          tsIsUnambiguouslyIndexSignature() {
            this.next();
            if (tokenIsIdentifier(this.state.type)) {
              this.next();
              return this.match(14);
            }
            return false;
          }
          tsTryParseIndexSignature(e) {
            if (
              !(
                this.match(0) &&
                this.tsLookAhead(
                  this.tsIsUnambiguouslyIndexSignature.bind(this),
                )
              )
            ) {
              return;
            }
            this.expect(0);
            const t = this.parseIdentifier();
            t.typeAnnotation = this.tsParseTypeAnnotation();
            this.resetEndLocation(t);
            this.expect(3);
            e.parameters = [t];
            const r = this.tsTryParseTypeAnnotation();
            if (r) e.typeAnnotation = r;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(e, 'TSIndexSignature');
          }
          tsParsePropertyOrMethodSignature(e, t) {
            if (this.eat(17)) e.optional = true;
            const r = e;
            if (this.match(10) || this.match(47)) {
              if (t) {
                this.raise(ie.ReadonlyForMethodSignature, { at: e });
              }
              const s = r;
              if (s.kind && this.match(47)) {
                this.raise(ie.AccesorCannotHaveTypeParameters, {
                  at: this.state.curPosition(),
                });
              }
              this.tsFillSignature(14, s);
              this.tsParseTypeMemberSemicolon();
              const i = 'parameters';
              const n = 'typeAnnotation';
              if (s.kind === 'get') {
                if (s[i].length > 0) {
                  this.raise(u.BadGetterArity, {
                    at: this.state.curPosition(),
                  });
                  if (this.isThisParam(s[i][0])) {
                    this.raise(ie.AccesorCannotDeclareThisParameter, {
                      at: this.state.curPosition(),
                    });
                  }
                }
              } else if (s.kind === 'set') {
                if (s[i].length !== 1) {
                  this.raise(u.BadSetterArity, {
                    at: this.state.curPosition(),
                  });
                } else {
                  const e = s[i][0];
                  if (this.isThisParam(e)) {
                    this.raise(ie.AccesorCannotDeclareThisParameter, {
                      at: this.state.curPosition(),
                    });
                  }
                  if (e.type === 'Identifier' && e.optional) {
                    this.raise(ie.SetAccesorCannotHaveOptionalParameter, {
                      at: this.state.curPosition(),
                    });
                  }
                  if (e.type === 'RestElement') {
                    this.raise(ie.SetAccesorCannotHaveRestParameter, {
                      at: this.state.curPosition(),
                    });
                  }
                }
                if (s[n]) {
                  this.raise(ie.SetAccesorCannotHaveReturnType, { at: s[n] });
                }
              } else {
                s.kind = 'method';
              }
              return this.finishNode(s, 'TSMethodSignature');
            } else {
              const e = r;
              if (t) e.readonly = true;
              const s = this.tsTryParseTypeAnnotation();
              if (s) e.typeAnnotation = s;
              this.tsParseTypeMemberSemicolon();
              return this.finishNode(e, 'TSPropertySignature');
            }
          }
          tsParseTypeMember() {
            const e = this.startNode();
            if (this.match(10) || this.match(47)) {
              return this.tsParseSignatureMember(
                'TSCallSignatureDeclaration',
                e,
              );
            }
            if (this.match(77)) {
              const t = this.startNode();
              this.next();
              if (this.match(10) || this.match(47)) {
                return this.tsParseSignatureMember(
                  'TSConstructSignatureDeclaration',
                  e,
                );
              } else {
                e.key = this.createIdentifier(t, 'new');
                return this.tsParsePropertyOrMethodSignature(e, false);
              }
            }
            this.tsParseModifiers(
              {
                allowedModifiers: ['readonly'],
                disallowedModifiers: [
                  'declare',
                  'abstract',
                  'private',
                  'protected',
                  'public',
                  'static',
                  'override',
                ],
              },
              e,
            );
            const t = this.tsTryParseIndexSignature(e);
            if (t) {
              return t;
            }
            super.parsePropertyName(e);
            if (
              !e.computed &&
              e.key.type === 'Identifier' &&
              (e.key.name === 'get' || e.key.name === 'set') &&
              this.tsTokenCanFollowModifier()
            ) {
              e.kind = e.key.name;
              super.parsePropertyName(e);
            }
            return this.tsParsePropertyOrMethodSignature(e, !!e.readonly);
          }
          tsParseTypeLiteral() {
            const e = this.startNode();
            e.members = this.tsParseObjectTypeMembers();
            return this.finishNode(e, 'TSTypeLiteral');
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            const e = this.tsParseList(
              'TypeMembers',
              this.tsParseTypeMember.bind(this),
            );
            this.expect(8);
            return e;
          }
          tsIsStartOfMappedType() {
            this.next();
            if (this.eat(53)) {
              return this.isContextual(122);
            }
            if (this.isContextual(122)) {
              this.next();
            }
            if (!this.match(0)) {
              return false;
            }
            this.next();
            if (!this.tsIsIdentifier()) {
              return false;
            }
            this.next();
            return this.match(58);
          }
          tsParseMappedTypeParameter() {
            const e = this.startNode();
            e.name = this.tsParseTypeParameterName();
            e.constraint = this.tsExpectThenParseType(58);
            return this.finishNode(e, 'TSTypeParameter');
          }
          tsParseMappedType() {
            const e = this.startNode();
            this.expect(5);
            if (this.match(53)) {
              e.readonly = this.state.value;
              this.next();
              this.expectContextual(122);
            } else if (this.eatContextual(122)) {
              e.readonly = true;
            }
            this.expect(0);
            e.typeParameter = this.tsParseMappedTypeParameter();
            e.nameType = this.eatContextual(93) ? this.tsParseType() : null;
            this.expect(3);
            if (this.match(53)) {
              e.optional = this.state.value;
              this.next();
              this.expect(17);
            } else if (this.eat(17)) {
              e.optional = true;
            }
            e.typeAnnotation = this.tsTryParseType();
            this.semicolon();
            this.expect(8);
            return this.finishNode(e, 'TSMappedType');
          }
          tsParseTupleType() {
            const e = this.startNode();
            e.elementTypes = this.tsParseBracketedList(
              'TupleElementTypes',
              this.tsParseTupleElementType.bind(this),
              true,
              false,
            );
            let t = false;
            e.elementTypes.forEach((e) => {
              const { type: r } = e;
              if (
                t &&
                r !== 'TSRestType' &&
                r !== 'TSOptionalType' &&
                !(r === 'TSNamedTupleMember' && e.optional)
              ) {
                this.raise(ie.OptionalTypeBeforeRequired, { at: e });
              }
              t ||
                (t =
                  (r === 'TSNamedTupleMember' && e.optional) ||
                  r === 'TSOptionalType');
            });
            return this.finishNode(e, 'TSTupleType');
          }
          tsParseTupleElementType() {
            const { startLoc: e } = this.state;
            const t = this.eat(21);
            let r;
            let s;
            let i;
            let n;
            const a = tokenIsKeywordOrIdentifier(this.state.type);
            const o = a ? this.lookaheadCharCode() : null;
            if (o === 58) {
              r = true;
              i = false;
              s = this.parseIdentifier(true);
              this.expect(14);
              n = this.tsParseType();
            } else if (o === 63) {
              i = true;
              const e = this.state.startLoc;
              const t = this.state.value;
              const a = this.tsParseNonArrayType();
              if (this.lookaheadCharCode() === 58) {
                r = true;
                s = this.createIdentifier(this.startNodeAt(e), t);
                this.expect(17);
                this.expect(14);
                n = this.tsParseType();
              } else {
                r = false;
                n = a;
                this.expect(17);
              }
            } else {
              n = this.tsParseType();
              i = this.eat(17);
              r = this.eat(14);
            }
            if (r) {
              let e;
              if (s) {
                e = this.startNodeAtNode(s);
                e.optional = i;
                e.label = s;
                e.elementType = n;
                if (this.eat(17)) {
                  e.optional = true;
                  this.raise(ie.TupleOptionalAfterType, {
                    at: this.state.lastTokStartLoc,
                  });
                }
              } else {
                e = this.startNodeAtNode(n);
                e.optional = i;
                this.raise(ie.InvalidTupleMemberLabel, { at: n });
                e.label = n;
                e.elementType = this.tsParseType();
              }
              n = this.finishNode(e, 'TSNamedTupleMember');
            } else if (i) {
              const e = this.startNodeAtNode(n);
              e.typeAnnotation = n;
              n = this.finishNode(e, 'TSOptionalType');
            }
            if (t) {
              const t = this.startNodeAt(e);
              t.typeAnnotation = n;
              n = this.finishNode(t, 'TSRestType');
            }
            return n;
          }
          tsParseParenthesizedType() {
            const e = this.startNode();
            this.expect(10);
            e.typeAnnotation = this.tsParseType();
            this.expect(11);
            return this.finishNode(e, 'TSParenthesizedType');
          }
          tsParseFunctionOrConstructorType(e, t) {
            const r = this.startNode();
            if (e === 'TSConstructorType') {
              r.abstract = !!t;
              if (t) this.next();
              this.next();
            }
            this.tsInAllowConditionalTypesContext(() =>
              this.tsFillSignature(19, r),
            );
            return this.finishNode(r, e);
          }
          tsParseLiteralTypeNode() {
            const e = this.startNode();
            switch (this.state.type) {
              case 134:
              case 135:
              case 133:
              case 85:
              case 86:
                e.literal = super.parseExprAtom();
                break;
              default:
                this.unexpected();
            }
            return this.finishNode(e, 'TSLiteralType');
          }
          tsParseTemplateLiteralType() {
            const e = this.startNode();
            e.literal = super.parseTemplate(false);
            return this.finishNode(e, 'TSLiteralType');
          }
          parseTemplateSubstitution() {
            if (this.state.inType) return this.tsParseType();
            return super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const e = this.tsParseThisTypeNode();
            if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
              return this.tsParseThisTypePredicate(e);
            } else {
              return e;
            }
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 133:
              case 134:
              case 135:
              case 85:
              case 86:
                return this.tsParseLiteralTypeNode();
              case 53:
                if (this.state.value === '-') {
                  const e = this.startNode();
                  const t = this.lookahead();
                  if (t.type !== 134 && t.type !== 135) {
                    this.unexpected();
                  }
                  e.literal = this.parseMaybeUnary();
                  return this.finishNode(e, 'TSLiteralType');
                }
                break;
              case 78:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 87:
                return this.tsParseTypeQuery();
              case 83:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
                  ? this.tsParseMappedType()
                  : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                const { type: e } = this.state;
                if (tokenIsIdentifier(e) || e === 88 || e === 84) {
                  const t =
                    e === 88
                      ? 'TSVoidKeyword'
                      : e === 84
                      ? 'TSNullKeyword'
                      : keywordTypeFromName(this.state.value);
                  if (t !== undefined && this.lookaheadCharCode() !== 46) {
                    const e = this.startNode();
                    this.next();
                    return this.finishNode(e, t);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let e = this.tsParseNonArrayType();
            while (!this.hasPrecedingLineBreak() && this.eat(0)) {
              if (this.match(3)) {
                const t = this.startNodeAtNode(e);
                t.elementType = e;
                this.expect(3);
                e = this.finishNode(t, 'TSArrayType');
              } else {
                const t = this.startNodeAtNode(e);
                t.objectType = e;
                t.indexType = this.tsParseType();
                this.expect(3);
                e = this.finishNode(t, 'TSIndexedAccessType');
              }
            }
            return e;
          }
          tsParseTypeOperator() {
            const e = this.startNode();
            const t = this.state.value;
            this.next();
            e.operator = t;
            e.typeAnnotation = this.tsParseTypeOperatorOrHigher();
            if (t === 'readonly') {
              this.tsCheckTypeAnnotationForReadOnly(e);
            }
            return this.finishNode(e, 'TSTypeOperator');
          }
          tsCheckTypeAnnotationForReadOnly(e) {
            switch (e.typeAnnotation.type) {
              case 'TSTupleType':
              case 'TSArrayType':
                return;
              default:
                this.raise(ie.UnexpectedReadonly, { at: e });
            }
          }
          tsParseInferType() {
            const e = this.startNode();
            this.expectContextual(115);
            const t = this.startNode();
            t.name = this.tsParseTypeParameterName();
            t.constraint = this.tsTryParse(() =>
              this.tsParseConstraintForInferType(),
            );
            e.typeParameter = this.finishNode(t, 'TSTypeParameter');
            return this.finishNode(e, 'TSInferType');
          }
          tsParseConstraintForInferType() {
            if (this.eat(81)) {
              const e = this.tsInDisallowConditionalTypesContext(() =>
                this.tsParseType(),
              );
              if (
                this.state.inDisallowConditionalTypesContext ||
                !this.match(17)
              ) {
                return e;
              }
            }
          }
          tsParseTypeOperatorOrHigher() {
            const e =
              tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
            return e
              ? this.tsParseTypeOperator()
              : this.isContextual(115)
              ? this.tsParseInferType()
              : this.tsInAllowConditionalTypesContext(() =>
                  this.tsParseArrayTypeOrHigher(),
                );
          }
          tsParseUnionOrIntersectionType(e, t, r) {
            const s = this.startNode();
            const i = this.eat(r);
            const n = [];
            do {
              n.push(t());
            } while (this.eat(r));
            if (n.length === 1 && !i) {
              return n[0];
            }
            s.types = n;
            return this.finishNode(s, e);
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType(
              'TSIntersectionType',
              this.tsParseTypeOperatorOrHigher.bind(this),
              45,
            );
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType(
              'TSUnionType',
              this.tsParseIntersectionTypeOrHigher.bind(this),
              43,
            );
          }
          tsIsStartOfFunctionType() {
            if (this.match(47)) {
              return true;
            }
            return (
              this.match(10) &&
              this.tsLookAhead(
                this.tsIsUnambiguouslyStartOfFunctionType.bind(this),
              )
            );
          }
          tsSkipParameterStart() {
            if (tokenIsIdentifier(this.state.type) || this.match(78)) {
              this.next();
              return true;
            }
            if (this.match(5)) {
              const { errors: e } = this.state;
              const t = e.length;
              try {
                this.parseObjectLike(8, true);
                return e.length === t;
              } catch (e) {
                return false;
              }
            }
            if (this.match(0)) {
              this.next();
              const { errors: e } = this.state;
              const t = e.length;
              try {
                super.parseBindingList(3, 93, 1);
                return e.length === t;
              } catch (e) {
                return false;
              }
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            this.next();
            if (this.match(11) || this.match(21)) {
              return true;
            }
            if (this.tsSkipParameterStart()) {
              if (
                this.match(14) ||
                this.match(12) ||
                this.match(17) ||
                this.match(29)
              ) {
                return true;
              }
              if (this.match(11)) {
                this.next();
                if (this.match(19)) {
                  return true;
                }
              }
            }
            return false;
          }
          tsParseTypeOrTypePredicateAnnotation(e) {
            return this.tsInType(() => {
              const t = this.startNode();
              this.expect(e);
              const r = this.startNode();
              const s = !!this.tsTryParse(
                this.tsParseTypePredicateAsserts.bind(this),
              );
              if (s && this.match(78)) {
                let e = this.tsParseThisTypeOrThisTypePredicate();
                if (e.type === 'TSThisType') {
                  r.parameterName = e;
                  r.asserts = true;
                  r.typeAnnotation = null;
                  e = this.finishNode(r, 'TSTypePredicate');
                } else {
                  this.resetStartLocationFromNode(e, r);
                  e.asserts = true;
                }
                t.typeAnnotation = e;
                return this.finishNode(t, 'TSTypeAnnotation');
              }
              const i =
                this.tsIsIdentifier() &&
                this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!i) {
                if (!s) {
                  return this.tsParseTypeAnnotation(false, t);
                }
                r.parameterName = this.parseIdentifier();
                r.asserts = s;
                r.typeAnnotation = null;
                t.typeAnnotation = this.finishNode(r, 'TSTypePredicate');
                return this.finishNode(t, 'TSTypeAnnotation');
              }
              const n = this.tsParseTypeAnnotation(false);
              r.parameterName = i;
              r.typeAnnotation = n;
              r.asserts = s;
              t.typeAnnotation = this.finishNode(r, 'TSTypePredicate');
              return this.finishNode(t, 'TSTypeAnnotation');
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14)) {
              return this.tsParseTypeOrTypePredicateAnnotation(14);
            }
          }
          tsTryParseTypeAnnotation() {
            if (this.match(14)) {
              return this.tsParseTypeAnnotation();
            }
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            const e = this.parseIdentifier();
            if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
              this.next();
              return e;
            }
          }
          tsParseTypePredicateAsserts() {
            if (this.state.type !== 109) {
              return false;
            }
            const e = this.state.containsEsc;
            this.next();
            if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
              return false;
            }
            if (e) {
              this.raise(u.InvalidEscapedReservedWord, {
                at: this.state.lastTokStartLoc,
                reservedWord: 'asserts',
              });
            }
            return true;
          }
          tsParseTypeAnnotation(e = true, t = this.startNode()) {
            this.tsInType(() => {
              if (e) this.expect(14);
              t.typeAnnotation = this.tsParseType();
            });
            return this.finishNode(t, 'TSTypeAnnotation');
          }
          tsParseType() {
            assert(this.state.inType);
            const e = this.tsParseNonConditionalType();
            if (
              this.state.inDisallowConditionalTypesContext ||
              this.hasPrecedingLineBreak() ||
              !this.eat(81)
            ) {
              return e;
            }
            const t = this.startNodeAtNode(e);
            t.checkType = e;
            t.extendsType = this.tsInDisallowConditionalTypesContext(() =>
              this.tsParseNonConditionalType(),
            );
            this.expect(17);
            t.trueType = this.tsInAllowConditionalTypesContext(() =>
              this.tsParseType(),
            );
            this.expect(14);
            t.falseType = this.tsInAllowConditionalTypesContext(() =>
              this.tsParseType(),
            );
            return this.finishNode(t, 'TSConditionalType');
          }
          isAbstractConstructorSignature() {
            return this.isContextual(124) && this.lookahead().type === 77;
          }
          tsParseNonConditionalType() {
            if (this.tsIsStartOfFunctionType()) {
              return this.tsParseFunctionOrConstructorType('TSFunctionType');
            }
            if (this.match(77)) {
              return this.tsParseFunctionOrConstructorType('TSConstructorType');
            } else if (this.isAbstractConstructorSignature()) {
              return this.tsParseFunctionOrConstructorType(
                'TSConstructorType',
                true,
              );
            }
            return this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            if (
              this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')
            ) {
              this.raise(ie.ReservedTypeAssertion, { at: this.state.startLoc });
            }
            const e = this.startNode();
            e.typeAnnotation = this.tsInType(() => {
              this.next();
              return this.match(75)
                ? this.tsParseTypeReference()
                : this.tsParseType();
            });
            this.expect(48);
            e.expression = this.parseMaybeUnary();
            return this.finishNode(e, 'TSTypeAssertion');
          }
          tsParseHeritageClause(e) {
            const t = this.state.startLoc;
            const r = this.tsParseDelimitedList('HeritageClauseElement', () => {
              const e = this.startNode();
              e.expression = this.tsParseEntityName();
              if (this.match(47)) {
                e.typeParameters = this.tsParseTypeArguments();
              }
              return this.finishNode(e, 'TSExpressionWithTypeArguments');
            });
            if (!r.length) {
              this.raise(ie.EmptyHeritageClauseType, { at: t, token: e });
            }
            return r;
          }
          tsParseInterfaceDeclaration(e, t = {}) {
            if (this.hasFollowingLineBreak()) return null;
            this.expectContextual(129);
            if (t.declare) e.declare = true;
            if (tokenIsIdentifier(this.state.type)) {
              e.id = this.parseIdentifier();
              this.checkIdentifier(e.id, 130);
            } else {
              e.id = null;
              this.raise(ie.MissingInterfaceName, { at: this.state.startLoc });
            }
            e.typeParameters = this.tsTryParseTypeParameters(
              this.tsParseInOutConstModifiers,
            );
            if (this.eat(81)) {
              e.extends = this.tsParseHeritageClause('extends');
            }
            const r = this.startNode();
            r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
            e.body = this.finishNode(r, 'TSInterfaceBody');
            return this.finishNode(e, 'TSInterfaceDeclaration');
          }
          tsParseTypeAliasDeclaration(e) {
            e.id = this.parseIdentifier();
            this.checkIdentifier(e.id, 2);
            e.typeAnnotation = this.tsInType(() => {
              e.typeParameters = this.tsTryParseTypeParameters(
                this.tsParseInOutModifiers,
              );
              this.expect(29);
              if (this.isContextual(114) && this.lookahead().type !== 16) {
                const e = this.startNode();
                this.next();
                return this.finishNode(e, 'TSIntrinsicKeyword');
              }
              return this.tsParseType();
            });
            this.semicolon();
            return this.finishNode(e, 'TSTypeAliasDeclaration');
          }
          tsInNoContext(e) {
            const t = this.state.context;
            this.state.context = [t[0]];
            try {
              return e();
            } finally {
              this.state.context = t;
            }
          }
          tsInType(e) {
            const t = this.state.inType;
            this.state.inType = true;
            try {
              return e();
            } finally {
              this.state.inType = t;
            }
          }
          tsInDisallowConditionalTypesContext(e) {
            const t = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = true;
            try {
              return e();
            } finally {
              this.state.inDisallowConditionalTypesContext = t;
            }
          }
          tsInAllowConditionalTypesContext(e) {
            const t = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = false;
            try {
              return e();
            } finally {
              this.state.inDisallowConditionalTypesContext = t;
            }
          }
          tsEatThenParseType(e) {
            if (this.match(e)) {
              return this.tsNextThenParseType();
            }
          }
          tsExpectThenParseType(e) {
            return this.tsInType(() => {
              this.expect(e);
              return this.tsParseType();
            });
          }
          tsNextThenParseType() {
            return this.tsInType(() => {
              this.next();
              return this.tsParseType();
            });
          }
          tsParseEnumMember() {
            const e = this.startNode();
            e.id = this.match(133)
              ? super.parseStringLiteral(this.state.value)
              : this.parseIdentifier(true);
            if (this.eat(29)) {
              e.initializer = super.parseMaybeAssignAllowIn();
            }
            return this.finishNode(e, 'TSEnumMember');
          }
          tsParseEnumDeclaration(e, t = {}) {
            if (t.const) e.const = true;
            if (t.declare) e.declare = true;
            this.expectContextual(126);
            e.id = this.parseIdentifier();
            this.checkIdentifier(e.id, e.const ? 8971 : 8459);
            this.expect(5);
            e.members = this.tsParseDelimitedList(
              'EnumMembers',
              this.tsParseEnumMember.bind(this),
            );
            this.expect(8);
            return this.finishNode(e, 'TSEnumDeclaration');
          }
          tsParseModuleBlock() {
            const e = this.startNode();
            this.scope.enter(0);
            this.expect(5);
            super.parseBlockOrModuleBlockBody(
              (e.body = []),
              undefined,
              true,
              8,
            );
            this.scope.exit();
            return this.finishNode(e, 'TSModuleBlock');
          }
          tsParseModuleOrNamespaceDeclaration(e, t = false) {
            e.id = this.parseIdentifier();
            if (!t) {
              this.checkIdentifier(e.id, 1024);
            }
            if (this.eat(16)) {
              const t = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(t, true);
              e.body = t;
            } else {
              this.scope.enter(256);
              this.prodParam.enter(0);
              e.body = this.tsParseModuleBlock();
              this.prodParam.exit();
              this.scope.exit();
            }
            return this.finishNode(e, 'TSModuleDeclaration');
          }
          tsParseAmbientExternalModuleDeclaration(e) {
            if (this.isContextual(112)) {
              e.global = true;
              e.id = this.parseIdentifier();
            } else if (this.match(133)) {
              e.id = super.parseStringLiteral(this.state.value);
            } else {
              this.unexpected();
            }
            if (this.match(5)) {
              this.scope.enter(256);
              this.prodParam.enter(0);
              e.body = this.tsParseModuleBlock();
              this.prodParam.exit();
              this.scope.exit();
            } else {
              this.semicolon();
            }
            return this.finishNode(e, 'TSModuleDeclaration');
          }
          tsParseImportEqualsDeclaration(e, t, r) {
            e.isExport = r || false;
            e.id = t || this.parseIdentifier();
            this.checkIdentifier(e.id, 4096);
            this.expect(29);
            const s = this.tsParseModuleReference();
            if (
              e.importKind === 'type' &&
              s.type !== 'TSExternalModuleReference'
            ) {
              this.raise(ie.ImportAliasHasImportType, { at: s });
            }
            e.moduleReference = s;
            this.semicolon();
            return this.finishNode(e, 'TSImportEqualsDeclaration');
          }
          tsIsExternalModuleReference() {
            return this.isContextual(119) && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference()
              ? this.tsParseExternalModuleReference()
              : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            const e = this.startNode();
            this.expectContextual(119);
            this.expect(10);
            if (!this.match(133)) {
              this.unexpected();
            }
            e.expression = super.parseExprAtom();
            this.expect(11);
            this.sawUnambiguousESM = true;
            return this.finishNode(e, 'TSExternalModuleReference');
          }
          tsLookAhead(e) {
            const t = this.state.clone();
            const r = e();
            this.state = t;
            return r;
          }
          tsTryParseAndCatch(e) {
            const t = this.tryParse((t) => e() || t());
            if (t.aborted || !t.node) return;
            if (t.error) this.state = t.failState;
            return t.node;
          }
          tsTryParse(e) {
            const t = this.state.clone();
            const r = e();
            if (r !== undefined && r !== false) {
              return r;
            }
            this.state = t;
          }
          tsTryParseDeclare(e) {
            if (this.isLineTerminator()) {
              return;
            }
            let t = this.state.type;
            let r;
            if (this.isContextual(100)) {
              t = 74;
              r = 'let';
            }
            return this.tsInAmbientContext(() => {
              switch (t) {
                case 68:
                  e.declare = true;
                  return super.parseFunctionStatement(e, false, false);
                case 80:
                  e.declare = true;
                  return this.parseClass(e, true, false);
                case 126:
                  return this.tsParseEnumDeclaration(e, { declare: true });
                case 112:
                  return this.tsParseAmbientExternalModuleDeclaration(e);
                case 75:
                case 74:
                  if (!this.match(75) || !this.isLookaheadContextual('enum')) {
                    e.declare = true;
                    return this.parseVarStatement(
                      e,
                      r || this.state.value,
                      true,
                    );
                  }
                  this.expect(75);
                  return this.tsParseEnumDeclaration(e, {
                    const: true,
                    declare: true,
                  });
                case 129: {
                  const t = this.tsParseInterfaceDeclaration(e, {
                    declare: true,
                  });
                  if (t) return t;
                }
                default:
                  if (tokenIsIdentifier(t)) {
                    return this.tsParseDeclaration(
                      e,
                      this.state.value,
                      true,
                      null,
                    );
                  }
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(
              this.startNode(),
              this.state.value,
              true,
              null,
            );
          }
          tsParseExpressionStatement(e, t, r) {
            switch (t.name) {
              case 'declare': {
                const t = this.tsTryParseDeclare(e);
                if (t) {
                  t.declare = true;
                }
                return t;
              }
              case 'global':
                if (this.match(5)) {
                  this.scope.enter(256);
                  this.prodParam.enter(0);
                  const r = e;
                  r.global = true;
                  r.id = t;
                  r.body = this.tsParseModuleBlock();
                  this.scope.exit();
                  this.prodParam.exit();
                  return this.finishNode(r, 'TSModuleDeclaration');
                }
                break;
              default:
                return this.tsParseDeclaration(e, t.name, false, r);
            }
          }
          tsParseDeclaration(e, t, r, s) {
            switch (t) {
              case 'abstract':
                if (
                  this.tsCheckLineTerminator(r) &&
                  (this.match(80) || tokenIsIdentifier(this.state.type))
                ) {
                  return this.tsParseAbstractDeclaration(e, s);
                }
                break;
              case 'module':
                if (this.tsCheckLineTerminator(r)) {
                  if (this.match(133)) {
                    return this.tsParseAmbientExternalModuleDeclaration(e);
                  } else if (tokenIsIdentifier(this.state.type)) {
                    return this.tsParseModuleOrNamespaceDeclaration(e);
                  }
                }
                break;
              case 'namespace':
                if (
                  this.tsCheckLineTerminator(r) &&
                  tokenIsIdentifier(this.state.type)
                ) {
                  return this.tsParseModuleOrNamespaceDeclaration(e);
                }
                break;
              case 'type':
                if (
                  this.tsCheckLineTerminator(r) &&
                  tokenIsIdentifier(this.state.type)
                ) {
                  return this.tsParseTypeAliasDeclaration(e);
                }
                break;
            }
          }
          tsCheckLineTerminator(e) {
            if (e) {
              if (this.hasFollowingLineBreak()) return false;
              this.next();
              return true;
            }
            return !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(e) {
            if (!this.match(47)) return;
            const t = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            const r = this.tsTryParseAndCatch(() => {
              const t = this.startNodeAt(e);
              t.typeParameters = this.tsParseTypeParameters(
                this.tsParseConstModifier,
              );
              super.parseFunctionParams(t);
              t.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
              this.expect(19);
              return t;
            });
            this.state.maybeInArrowParameters = t;
            if (!r) return;
            return super.parseArrowExpression(r, null, true);
          }
          tsParseTypeArgumentsInExpression() {
            if (this.reScan_lt() !== 47) return;
            return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            const e = this.startNode();
            e.params = this.tsInType(() =>
              this.tsInNoContext(() => {
                this.expect(47);
                return this.tsParseDelimitedList(
                  'TypeParametersOrArguments',
                  this.tsParseType.bind(this),
                );
              }),
            );
            if (e.params.length === 0) {
              this.raise(ie.EmptyTypeArguments, { at: e });
            } else if (!this.state.inType && this.curContext() === f.brace) {
              this.reScan_lt_gt();
            }
            this.expect(48);
            return this.finishNode(e, 'TSTypeParameterInstantiation');
          }
          tsIsDeclarationStart() {
            return tokenIsTSDeclarationStart(this.state.type);
          }
          isExportDefaultSpecifier() {
            if (this.tsIsDeclarationStart()) return false;
            return super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(e, t) {
            const r = this.state.startLoc;
            const s = {};
            this.tsParseModifiers(
              {
                allowedModifiers: [
                  'public',
                  'private',
                  'protected',
                  'override',
                  'readonly',
                ],
              },
              s,
            );
            const i = s.accessibility;
            const n = s.override;
            const a = s.readonly;
            if (!(e & 4) && (i || a || n)) {
              this.raise(ie.UnexpectedParameterModifier, { at: r });
            }
            const o = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(o, e);
            const l = this.parseMaybeDefault(o.loc.start, o);
            if (i || a || n) {
              const e = this.startNodeAt(r);
              if (t.length) {
                e.decorators = t;
              }
              if (i) e.accessibility = i;
              if (a) e.readonly = a;
              if (n) e.override = n;
              if (l.type !== 'Identifier' && l.type !== 'AssignmentPattern') {
                this.raise(ie.UnsupportedParameterPropertyKind, { at: e });
              }
              e.parameter = l;
              return this.finishNode(e, 'TSParameterProperty');
            }
            if (t.length) {
              o.decorators = t;
            }
            return l;
          }
          isSimpleParameter(e) {
            return (
              (e.type === 'TSParameterProperty' &&
                super.isSimpleParameter(e.parameter)) ||
              super.isSimpleParameter(e)
            );
          }
          tsDisallowOptionalPattern(e) {
            for (const t of e.params) {
              if (
                t.type !== 'Identifier' &&
                t.optional &&
                !this.state.isAmbientContext
              ) {
                this.raise(ie.PatternIsOptional, { at: t });
              }
            }
          }
          setArrowFunctionParameters(e, t, r) {
            super.setArrowFunctionParameters(e, t, r);
            this.tsDisallowOptionalPattern(e);
          }
          parseFunctionBodyAndFinish(e, t, r = false) {
            if (this.match(14)) {
              e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            }
            const s =
              t === 'FunctionDeclaration'
                ? 'TSDeclareFunction'
                : t === 'ClassMethod' || t === 'ClassPrivateMethod'
                ? 'TSDeclareMethod'
                : undefined;
            if (s && !this.match(5) && this.isLineTerminator()) {
              return this.finishNode(e, s);
            }
            if (s === 'TSDeclareFunction' && this.state.isAmbientContext) {
              this.raise(ie.DeclareFunctionHasImplementation, { at: e });
              if (e.declare) {
                return super.parseFunctionBodyAndFinish(e, s, r);
              }
            }
            this.tsDisallowOptionalPattern(e);
            return super.parseFunctionBodyAndFinish(e, t, r);
          }
          registerFunctionStatementId(e) {
            if (!e.body && e.id) {
              this.checkIdentifier(e.id, 1024);
            } else {
              super.registerFunctionStatementId(e);
            }
          }
          tsCheckForInvalidTypeCasts(e) {
            e.forEach((e) => {
              if ((e == null ? void 0 : e.type) === 'TSTypeCastExpression') {
                this.raise(ie.UnexpectedTypeAnnotation, {
                  at: e.typeAnnotation,
                });
              }
            });
          }
          toReferencedList(e, t) {
            this.tsCheckForInvalidTypeCasts(e);
            return e;
          }
          parseArrayLike(e, t, r, s) {
            const i = super.parseArrayLike(e, t, r, s);
            if (i.type === 'ArrayExpression') {
              this.tsCheckForInvalidTypeCasts(i.elements);
            }
            return i;
          }
          parseSubscript(e, t, r, s) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = false;
              this.next();
              const r = this.startNodeAt(t);
              r.expression = e;
              return this.finishNode(r, 'TSNonNullExpression');
            }
            let i = false;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
              if (r) {
                s.stop = true;
                return e;
              }
              s.optionalChainMember = i = true;
              this.next();
            }
            if (this.match(47) || this.match(51)) {
              let n;
              const a = this.tsTryParseAndCatch(() => {
                if (!r && this.atPossibleAsyncArrow(e)) {
                  const e = this.tsTryParseGenericAsyncArrowFunction(t);
                  if (e) {
                    return e;
                  }
                }
                const a = this.tsParseTypeArgumentsInExpression();
                if (!a) return;
                if (i && !this.match(10)) {
                  n = this.state.curPosition();
                  return;
                }
                if (tokenIsTemplate(this.state.type)) {
                  const r = super.parseTaggedTemplateExpression(e, t, s);
                  r.typeParameters = a;
                  return r;
                }
                if (!r && this.eat(10)) {
                  const r = this.startNodeAt(t);
                  r.callee = e;
                  r.arguments = this.parseCallExpressionArguments(11, false);
                  this.tsCheckForInvalidTypeCasts(r.arguments);
                  r.typeParameters = a;
                  if (s.optionalChainMember) {
                    r.optional = i;
                  }
                  return this.finishCallExpression(r, s.optionalChainMember);
                }
                const o = this.state.type;
                if (
                  o === 48 ||
                  o === 52 ||
                  (o !== 10 &&
                    tokenCanStartExpression(o) &&
                    !this.hasPrecedingLineBreak())
                ) {
                  return;
                }
                const l = this.startNodeAt(t);
                l.expression = e;
                l.typeParameters = a;
                return this.finishNode(l, 'TSInstantiationExpression');
              });
              if (n) {
                this.unexpected(n, 10);
              }
              if (a) {
                if (
                  a.type === 'TSInstantiationExpression' &&
                  (this.match(16) ||
                    (this.match(18) && this.lookaheadCharCode() !== 40))
                ) {
                  this.raise(
                    ie.InvalidPropertyAccessAfterInstantiationExpression,
                    { at: this.state.startLoc },
                  );
                }
                return a;
              }
            }
            return super.parseSubscript(e, t, r, s);
          }
          parseNewCallee(e) {
            var t;
            super.parseNewCallee(e);
            const { callee: r } = e;
            if (
              r.type === 'TSInstantiationExpression' &&
              !((t = r.extra) != null && t.parenthesized)
            ) {
              e.typeParameters = r.typeParameters;
              e.callee = r.expression;
            }
          }
          parseExprOp(e, t, r) {
            let s;
            if (
              tokenOperatorPrecedence(58) > r &&
              !this.hasPrecedingLineBreak() &&
              (this.isContextual(93) || (s = this.isContextual(120)))
            ) {
              const i = this.startNodeAt(t);
              i.expression = e;
              i.typeAnnotation = this.tsInType(() => {
                this.next();
                if (this.match(75)) {
                  if (s) {
                    this.raise(u.UnexpectedKeyword, {
                      at: this.state.startLoc,
                      keyword: 'const',
                    });
                  }
                  return this.tsParseTypeReference();
                }
                return this.tsParseType();
              });
              this.finishNode(
                i,
                s ? 'TSSatisfiesExpression' : 'TSAsExpression',
              );
              this.reScan_lt_gt();
              return this.parseExprOp(i, t, r);
            }
            return super.parseExprOp(e, t, r);
          }
          checkReservedWord(e, t, r, s) {
            if (!this.state.isAmbientContext) {
              super.checkReservedWord(e, t, r, s);
            }
          }
          checkImportReflection(e) {
            super.checkImportReflection(e);
            if (e.module && e.importKind !== 'value') {
              this.raise(ie.ImportReflectionHasImportType, {
                at: e.specifiers[0].loc.start,
              });
            }
          }
          checkDuplicateExports() {}
          isPotentialImportPhase(e) {
            if (super.isPotentialImportPhase(e)) return true;
            if (this.isContextual(130)) {
              const t = this.lookaheadCharCode();
              return e ? t === 123 || t === 42 : t !== 61;
            }
            return !e && this.isContextual(87);
          }
          applyImportPhase(e, t, r, s) {
            super.applyImportPhase(e, t, r, s);
            if (t) {
              e.exportKind = r === 'type' ? 'type' : 'value';
            } else {
              e.importKind = r === 'type' || r === 'typeof' ? r : 'value';
            }
          }
          parseImport(e) {
            if (this.match(133)) {
              e.importKind = 'value';
              return super.parseImport(e);
            }
            let t;
            if (
              tokenIsIdentifier(this.state.type) &&
              this.lookaheadCharCode() === 61
            ) {
              e.importKind = 'value';
              return this.tsParseImportEqualsDeclaration(e);
            } else if (this.isContextual(130)) {
              const r = this.parseMaybeImportPhase(e, false);
              if (this.lookaheadCharCode() === 61) {
                return this.tsParseImportEqualsDeclaration(e, r);
              } else {
                t = super.parseImportSpecifiersAndAfter(e, r);
              }
            } else {
              t = super.parseImport(e);
            }
            if (
              t.importKind === 'type' &&
              t.specifiers.length > 1 &&
              t.specifiers[0].type === 'ImportDefaultSpecifier'
            ) {
              this.raise(ie.TypeImportCannotSpecifyDefaultAndNamed, { at: t });
            }
            return t;
          }
          parseExport(e, t) {
            if (this.match(83)) {
              this.next();
              let t = null;
              if (
                this.isContextual(130) &&
                this.isPotentialImportPhase(false)
              ) {
                t = this.parseMaybeImportPhase(e, false);
              } else {
                e.importKind = 'value';
              }
              return this.tsParseImportEqualsDeclaration(e, t, true);
            } else if (this.eat(29)) {
              const t = e;
              t.expression = super.parseExpression();
              this.semicolon();
              this.sawUnambiguousESM = true;
              return this.finishNode(t, 'TSExportAssignment');
            } else if (this.eatContextual(93)) {
              const t = e;
              this.expectContextual(128);
              t.id = this.parseIdentifier();
              this.semicolon();
              return this.finishNode(t, 'TSNamespaceExportDeclaration');
            } else {
              return super.parseExport(e, t);
            }
          }
          isAbstractClass() {
            return this.isContextual(124) && this.lookahead().type === 80;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const e = this.startNode();
              this.next();
              e.abstract = true;
              return this.parseClass(e, true, true);
            }
            if (this.match(129)) {
              const e = this.tsParseInterfaceDeclaration(this.startNode());
              if (e) return e;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(e, t, r = false) {
            const { isAmbientContext: s } = this.state;
            const i = super.parseVarStatement(e, t, r || s);
            if (!s) return i;
            for (const { id: e, init: r } of i.declarations) {
              if (!r) continue;
              if (t !== 'const' || !!e.typeAnnotation) {
                this.raise(ie.InitializerNotAllowedInAmbientContext, { at: r });
              } else if (
                !isValidAmbientConstInitializer(r, this.hasPlugin('estree'))
              ) {
                this.raise(
                  ie.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference,
                  { at: r },
                );
              }
            }
            return i;
          }
          parseStatementContent(e, t) {
            if (this.match(75) && this.isLookaheadContextual('enum')) {
              const e = this.startNode();
              this.expect(75);
              return this.tsParseEnumDeclaration(e, { const: true });
            }
            if (this.isContextual(126)) {
              return this.tsParseEnumDeclaration(this.startNode());
            }
            if (this.isContextual(129)) {
              const e = this.tsParseInterfaceDeclaration(this.startNode());
              if (e) return e;
            }
            return super.parseStatementContent(e, t);
          }
          parseAccessModifier() {
            return this.tsParseModifier(['public', 'protected', 'private']);
          }
          tsHasSomeModifiers(e, t) {
            return t.some((t) => {
              if (tsIsAccessModifier(t)) {
                return e.accessibility === t;
              }
              return !!e[t];
            });
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(106) && this.lookaheadCharCode() === 123;
          }
          parseClassMember(e, t, r) {
            const s = [
              'declare',
              'private',
              'public',
              'protected',
              'override',
              'abstract',
              'readonly',
              'static',
            ];
            this.tsParseModifiers(
              {
                allowedModifiers: s,
                disallowedModifiers: ['in', 'out'],
                stopOnStartOfClassStaticBlock: true,
                errorTemplate: ie.InvalidModifierOnTypeParameterPositions,
              },
              t,
            );
            const callParseClassMemberWithIsStatic = () => {
              if (this.tsIsStartOfStaticBlocks()) {
                this.next();
                this.next();
                if (this.tsHasSomeModifiers(t, s)) {
                  this.raise(ie.StaticBlockCannotHaveModifier, {
                    at: this.state.curPosition(),
                  });
                }
                super.parseClassStaticBlock(e, t);
              } else {
                this.parseClassMemberWithIsStatic(e, t, r, !!t.static);
              }
            };
            if (t.declare) {
              this.tsInAmbientContext(callParseClassMemberWithIsStatic);
            } else {
              callParseClassMemberWithIsStatic();
            }
          }
          parseClassMemberWithIsStatic(e, t, r, s) {
            const i = this.tsTryParseIndexSignature(t);
            if (i) {
              e.body.push(i);
              if (t.abstract) {
                this.raise(ie.IndexSignatureHasAbstract, { at: t });
              }
              if (t.accessibility) {
                this.raise(ie.IndexSignatureHasAccessibility, {
                  at: t,
                  modifier: t.accessibility,
                });
              }
              if (t.declare) {
                this.raise(ie.IndexSignatureHasDeclare, { at: t });
              }
              if (t.override) {
                this.raise(ie.IndexSignatureHasOverride, { at: t });
              }
              return;
            }
            if (!this.state.inAbstractClass && t.abstract) {
              this.raise(ie.NonAbstractClassHasAbstractMethod, { at: t });
            }
            if (t.override) {
              if (!r.hadSuperClass) {
                this.raise(ie.OverrideNotInSubClass, { at: t });
              }
            }
            super.parseClassMemberWithIsStatic(e, t, r, s);
          }
          parsePostMemberNameModifiers(e) {
            const t = this.eat(17);
            if (t) e.optional = true;
            if (e.readonly && this.match(10)) {
              this.raise(ie.ClassMethodHasReadonly, { at: e });
            }
            if (e.declare && this.match(10)) {
              this.raise(ie.ClassMethodHasDeclare, { at: e });
            }
          }
          parseExpressionStatement(e, t, r) {
            const s =
              t.type === 'Identifier'
                ? this.tsParseExpressionStatement(e, t, r)
                : undefined;
            return s || super.parseExpressionStatement(e, t, r);
          }
          shouldParseExportDeclaration() {
            if (this.tsIsDeclarationStart()) return true;
            return super.shouldParseExportDeclaration();
          }
          parseConditional(e, t, r) {
            if (!this.state.maybeInArrowParameters || !this.match(17)) {
              return super.parseConditional(e, t, r);
            }
            const s = this.tryParse(() => super.parseConditional(e, t));
            if (!s.node) {
              if (s.error) {
                super.setOptionalParametersError(r, s.error);
              }
              return e;
            }
            if (s.error) this.state = s.failState;
            return s.node;
          }
          parseParenItem(e, t) {
            e = super.parseParenItem(e, t);
            if (this.eat(17)) {
              e.optional = true;
              this.resetEndLocation(e);
            }
            if (this.match(14)) {
              const r = this.startNodeAt(t);
              r.expression = e;
              r.typeAnnotation = this.tsParseTypeAnnotation();
              return this.finishNode(r, 'TSTypeCastExpression');
            }
            return e;
          }
          parseExportDeclaration(e) {
            if (!this.state.isAmbientContext && this.isContextual(125)) {
              return this.tsInAmbientContext(() =>
                this.parseExportDeclaration(e),
              );
            }
            const t = this.state.startLoc;
            const r = this.eatContextual(125);
            if (
              r &&
              (this.isContextual(125) || !this.shouldParseExportDeclaration())
            ) {
              throw this.raise(ie.ExpectedAmbientAfterExportDeclare, {
                at: this.state.startLoc,
              });
            }
            const s = tokenIsIdentifier(this.state.type);
            const i =
              (s && this.tsTryParseExportDeclaration()) ||
              super.parseExportDeclaration(e);
            if (!i) return null;
            if (
              i.type === 'TSInterfaceDeclaration' ||
              i.type === 'TSTypeAliasDeclaration' ||
              r
            ) {
              e.exportKind = 'type';
            }
            if (r) {
              this.resetStartLocation(i, t);
              i.declare = true;
            }
            return i;
          }
          parseClassId(e, t, r, s) {
            if ((!t || r) && this.isContextual(113)) {
              return;
            }
            super.parseClassId(e, t, r, e.declare ? 1024 : 8331);
            const i = this.tsTryParseTypeParameters(
              this.tsParseInOutConstModifiers,
            );
            if (i) e.typeParameters = i;
          }
          parseClassPropertyAnnotation(e) {
            if (!e.optional) {
              if (this.eat(35)) {
                e.definite = true;
              } else if (this.eat(17)) {
                e.optional = true;
              }
            }
            const t = this.tsTryParseTypeAnnotation();
            if (t) e.typeAnnotation = t;
          }
          parseClassProperty(e) {
            this.parseClassPropertyAnnotation(e);
            if (
              this.state.isAmbientContext &&
              !(e.readonly && !e.typeAnnotation) &&
              this.match(29)
            ) {
              this.raise(ie.DeclareClassFieldHasInitializer, {
                at: this.state.startLoc,
              });
            }
            if (e.abstract && this.match(29)) {
              const { key: t } = e;
              this.raise(ie.AbstractPropertyHasInitializer, {
                at: this.state.startLoc,
                propertyName:
                  t.type === 'Identifier' && !e.computed
                    ? t.name
                    : `[${this.input.slice(t.start, t.end)}]`,
              });
            }
            return super.parseClassProperty(e);
          }
          parseClassPrivateProperty(e) {
            if (e.abstract) {
              this.raise(ie.PrivateElementHasAbstract, { at: e });
            }
            if (e.accessibility) {
              this.raise(ie.PrivateElementHasAccessibility, {
                at: e,
                modifier: e.accessibility,
              });
            }
            this.parseClassPropertyAnnotation(e);
            return super.parseClassPrivateProperty(e);
          }
          parseClassAccessorProperty(e) {
            this.parseClassPropertyAnnotation(e);
            if (e.optional) {
              this.raise(ie.AccessorCannotBeOptional, { at: e });
            }
            return super.parseClassAccessorProperty(e);
          }
          pushClassMethod(e, t, r, s, i, n) {
            const a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            if (a && i) {
              this.raise(ie.ConstructorHasTypeParameters, { at: a });
            }
            const { declare: o = false, kind: l } = t;
            if (o && (l === 'get' || l === 'set')) {
              this.raise(ie.DeclareAccessor, { at: t, kind: l });
            }
            if (a) t.typeParameters = a;
            super.pushClassMethod(e, t, r, s, i, n);
          }
          pushClassPrivateMethod(e, t, r, s) {
            const i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            if (i) t.typeParameters = i;
            super.pushClassPrivateMethod(e, t, r, s);
          }
          declareClassPrivateMethodInScope(e, t) {
            if (e.type === 'TSDeclareMethod') return;
            if (e.type === 'MethodDefinition' && !e.value.body) return;
            super.declareClassPrivateMethodInScope(e, t);
          }
          parseClassSuper(e) {
            super.parseClassSuper(e);
            if (e.superClass && (this.match(47) || this.match(51))) {
              e.superTypeParameters = this.tsParseTypeArgumentsInExpression();
            }
            if (this.eatContextual(113)) {
              e.implements = this.tsParseHeritageClause('implements');
            }
          }
          parseObjPropValue(e, t, r, s, i, n, a) {
            const o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            if (o) e.typeParameters = o;
            return super.parseObjPropValue(e, t, r, s, i, n, a);
          }
          parseFunctionParams(e, t) {
            const r = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            if (r) e.typeParameters = r;
            super.parseFunctionParams(e, t);
          }
          parseVarId(e, t) {
            super.parseVarId(e, t);
            if (
              e.id.type === 'Identifier' &&
              !this.hasPrecedingLineBreak() &&
              this.eat(35)
            ) {
              e.definite = true;
            }
            const r = this.tsTryParseTypeAnnotation();
            if (r) {
              e.id.typeAnnotation = r;
              this.resetEndLocation(e.id);
            }
          }
          parseAsyncArrowFromCallExpression(e, t) {
            if (this.match(14)) {
              e.returnType = this.tsParseTypeAnnotation();
            }
            return super.parseAsyncArrowFromCallExpression(e, t);
          }
          parseMaybeAssign(e, t) {
            var r, s, i, n, a;
            let o;
            let l;
            let c;
            if (this.hasPlugin('jsx') && (this.match(142) || this.match(47))) {
              o = this.state.clone();
              l = this.tryParse(() => super.parseMaybeAssign(e, t), o);
              if (!l.error) return l.node;
              const { context: r } = this.state;
              const s = r[r.length - 1];
              if (s === f.j_oTag || s === f.j_expr) {
                r.pop();
              }
            }
            if (!((r = l) != null && r.error) && !this.match(47)) {
              return super.parseMaybeAssign(e, t);
            }
            if (!o || o === this.state) o = this.state.clone();
            let p;
            const u = this.tryParse((r) => {
              var s, i;
              p = this.tsParseTypeParameters(this.tsParseConstModifier);
              const n = super.parseMaybeAssign(e, t);
              if (
                n.type !== 'ArrowFunctionExpression' ||
                ((s = n.extra) != null && s.parenthesized)
              ) {
                r();
              }
              if (((i = p) == null ? void 0 : i.params.length) !== 0) {
                this.resetStartLocationFromNode(n, p);
              }
              n.typeParameters = p;
              return n;
            }, o);
            if (!u.error && !u.aborted) {
              if (p) this.reportReservedArrowTypeParam(p);
              return u.node;
            }
            if (!l) {
              assert(!this.hasPlugin('jsx'));
              c = this.tryParse(() => super.parseMaybeAssign(e, t), o);
              if (!c.error) return c.node;
            }
            if ((s = l) != null && s.node) {
              this.state = l.failState;
              return l.node;
            }
            if (u.node) {
              this.state = u.failState;
              if (p) this.reportReservedArrowTypeParam(p);
              return u.node;
            }
            if ((i = c) != null && i.node) {
              this.state = c.failState;
              return c.node;
            }
            throw (
              ((n = l) == null ? void 0 : n.error) ||
              u.error ||
              ((a = c) == null ? void 0 : a.error)
            );
          }
          reportReservedArrowTypeParam(e) {
            var t;
            if (
              e.params.length === 1 &&
              !e.params[0].constraint &&
              !((t = e.extra) != null && t.trailingComma) &&
              this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')
            ) {
              this.raise(ie.ReservedArrowTypeParam, { at: e });
            }
          }
          parseMaybeUnary(e, t) {
            if (!this.hasPlugin('jsx') && this.match(47)) {
              return this.tsParseTypeAssertion();
            }
            return super.parseMaybeUnary(e, t);
          }
          parseArrow(e) {
            if (this.match(14)) {
              const t = this.tryParse((e) => {
                const t = this.tsParseTypeOrTypePredicateAnnotation(14);
                if (this.canInsertSemicolon() || !this.match(19)) e();
                return t;
              });
              if (t.aborted) return;
              if (!t.thrown) {
                if (t.error) this.state = t.failState;
                e.returnType = t.node;
              }
            }
            return super.parseArrow(e);
          }
          parseAssignableListItemTypes(e, t) {
            if (!(t & 2)) return e;
            if (this.eat(17)) {
              e.optional = true;
            }
            const r = this.tsTryParseTypeAnnotation();
            if (r) e.typeAnnotation = r;
            this.resetEndLocation(e);
            return e;
          }
          isAssignable(e, t) {
            switch (e.type) {
              case 'TSTypeCastExpression':
                return this.isAssignable(e.expression, t);
              case 'TSParameterProperty':
                return true;
              default:
                return super.isAssignable(e, t);
            }
          }
          toAssignable(e, t = false) {
            switch (e.type) {
              case 'ParenthesizedExpression':
                this.toAssignableParenthesizedExpression(e, t);
                break;
              case 'TSAsExpression':
              case 'TSSatisfiesExpression':
              case 'TSNonNullExpression':
              case 'TSTypeAssertion':
                if (t) {
                  this.expressionScope.recordArrowParameterBindingError(
                    ie.UnexpectedTypeCastInParameter,
                    { at: e },
                  );
                } else {
                  this.raise(ie.UnexpectedTypeCastInParameter, { at: e });
                }
                this.toAssignable(e.expression, t);
                break;
              case 'AssignmentExpression':
                if (!t && e.left.type === 'TSTypeCastExpression') {
                  e.left = this.typeCastToParameter(e.left);
                }
              default:
                super.toAssignable(e, t);
            }
          }
          toAssignableParenthesizedExpression(e, t) {
            switch (e.expression.type) {
              case 'TSAsExpression':
              case 'TSSatisfiesExpression':
              case 'TSNonNullExpression':
              case 'TSTypeAssertion':
              case 'ParenthesizedExpression':
                this.toAssignable(e.expression, t);
                break;
              default:
                super.toAssignable(e, t);
            }
          }
          checkToRestConversion(e, t) {
            switch (e.type) {
              case 'TSAsExpression':
              case 'TSSatisfiesExpression':
              case 'TSTypeAssertion':
              case 'TSNonNullExpression':
                this.checkToRestConversion(e.expression, false);
                break;
              default:
                super.checkToRestConversion(e, t);
            }
          }
          isValidLVal(e, t, r) {
            return (
              getOwn(
                {
                  TSTypeCastExpression: true,
                  TSParameterProperty: 'parameter',
                  TSNonNullExpression: 'expression',
                  TSAsExpression: (r !== 64 || !t) && ['expression', true],
                  TSSatisfiesExpression: (r !== 64 || !t) && [
                    'expression',
                    true,
                  ],
                  TSTypeAssertion: (r !== 64 || !t) && ['expression', true],
                },
                e,
              ) || super.isValidLVal(e, t, r)
            );
          }
          parseBindingAtom() {
            if (this.state.type === 78) {
              return this.parseIdentifier(true);
            }
            return super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(e) {
            if (this.match(47) || this.match(51)) {
              const t = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                const r = super.parseMaybeDecoratorArguments(e);
                r.typeParameters = t;
                return r;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(e);
          }
          checkCommaAfterRest(e) {
            if (
              this.state.isAmbientContext &&
              this.match(12) &&
              this.lookaheadCharCode() === e
            ) {
              this.next();
              return false;
            }
            return super.checkCommaAfterRest(e);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(e, t) {
            const r = super.parseMaybeDefault(e, t);
            if (
              r.type === 'AssignmentPattern' &&
              r.typeAnnotation &&
              r.right.start < r.typeAnnotation.start
            ) {
              this.raise(ie.TypeAnnotationAfterAssign, {
                at: r.typeAnnotation,
              });
            }
            return r;
          }
          getTokenFromCode(e) {
            if (this.state.inType) {
              if (e === 62) {
                this.finishOp(48, 1);
                return;
              }
              if (e === 60) {
                this.finishOp(47, 1);
                return;
              }
            }
            super.getTokenFromCode(e);
          }
          reScan_lt_gt() {
            const { type: e } = this.state;
            if (e === 47) {
              this.state.pos -= 1;
              this.readToken_lt();
            } else if (e === 48) {
              this.state.pos -= 1;
              this.readToken_gt();
            }
          }
          reScan_lt() {
            const { type: e } = this.state;
            if (e === 51) {
              this.state.pos -= 2;
              this.finishOp(47, 1);
              return 47;
            }
            return e;
          }
          toAssignableList(e, t, r) {
            for (let t = 0; t < e.length; t++) {
              const r = e[t];
              if ((r == null ? void 0 : r.type) === 'TSTypeCastExpression') {
                e[t] = this.typeCastToParameter(r);
              }
            }
            super.toAssignableList(e, t, r);
          }
          typeCastToParameter(e) {
            e.expression.typeAnnotation = e.typeAnnotation;
            this.resetEndLocation(e.expression, e.typeAnnotation.loc.end);
            return e.expression;
          }
          shouldParseArrow(e) {
            if (this.match(14)) {
              return e.every((e) => this.isAssignable(e, true));
            }
            return super.shouldParseArrow(e);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(e) {
            if (this.match(47) || this.match(51)) {
              const t = this.tsTryParseAndCatch(() =>
                this.tsParseTypeArgumentsInExpression(),
              );
              if (t) e.typeParameters = t;
            }
            return super.jsxParseOpeningElementAfterName(e);
          }
          getGetterSetterExpectedParamCount(e) {
            const t = super.getGetterSetterExpectedParamCount(e);
            const r = this.getObjectOrClassMethodParams(e);
            const s = r[0];
            const i = s && this.isThisParam(s);
            return i ? t + 1 : t;
          }
          parseCatchClauseParam() {
            const e = super.parseCatchClauseParam();
            const t = this.tsTryParseTypeAnnotation();
            if (t) {
              e.typeAnnotation = t;
              this.resetEndLocation(e);
            }
            return e;
          }
          tsInAmbientContext(e) {
            const t = this.state.isAmbientContext;
            this.state.isAmbientContext = true;
            try {
              return e();
            } finally {
              this.state.isAmbientContext = t;
            }
          }
          parseClass(e, t, r) {
            const s = this.state.inAbstractClass;
            this.state.inAbstractClass = !!e.abstract;
            try {
              return super.parseClass(e, t, r);
            } finally {
              this.state.inAbstractClass = s;
            }
          }
          tsParseAbstractDeclaration(e, t) {
            if (this.match(80)) {
              e.abstract = true;
              return this.maybeTakeDecorators(
                t,
                this.parseClass(e, true, false),
              );
            } else if (this.isContextual(129)) {
              if (!this.hasFollowingLineBreak()) {
                e.abstract = true;
                this.raise(ie.NonClassMethodPropertyHasAbstractModifer, {
                  at: e,
                });
                return this.tsParseInterfaceDeclaration(e);
              }
            } else {
              this.unexpected(null, 80);
            }
          }
          parseMethod(e, t, r, s, i, n, a) {
            const o = super.parseMethod(e, t, r, s, i, n, a);
            if (o.abstract) {
              const e = this.hasPlugin('estree') ? !!o.value.body : !!o.body;
              if (e) {
                const { key: e } = o;
                this.raise(ie.AbstractMethodHasImplementation, {
                  at: o,
                  methodName:
                    e.type === 'Identifier' && !o.computed
                      ? e.name
                      : `[${this.input.slice(e.start, e.end)}]`,
                });
              }
            }
            return o;
          }
          tsParseTypeParameterName() {
            const e = this.parseIdentifier();
            return e.name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption('typescript', 'dts');
          }
          parse() {
            if (this.shouldParseAsAmbientContext()) {
              this.state.isAmbientContext = true;
            }
            return super.parse();
          }
          getExpression() {
            if (this.shouldParseAsAmbientContext()) {
              this.state.isAmbientContext = true;
            }
            return super.getExpression();
          }
          parseExportSpecifier(e, t, r, s) {
            if (!t && s) {
              this.parseTypeOnlyImportExportSpecifier(e, false, r);
              return this.finishNode(e, 'ExportSpecifier');
            }
            e.exportKind = 'value';
            return super.parseExportSpecifier(e, t, r, s);
          }
          parseImportSpecifier(e, t, r, s, i) {
            if (!t && s) {
              this.parseTypeOnlyImportExportSpecifier(e, true, r);
              return this.finishNode(e, 'ImportSpecifier');
            }
            e.importKind = 'value';
            return super.parseImportSpecifier(e, t, r, s, r ? 4098 : 4096);
          }
          parseTypeOnlyImportExportSpecifier(e, t, r) {
            const s = t ? 'imported' : 'local';
            const i = t ? 'local' : 'exported';
            let n = e[s];
            let a;
            let o = false;
            let l = true;
            const c = n.loc.start;
            if (this.isContextual(93)) {
              const e = this.parseIdentifier();
              if (this.isContextual(93)) {
                const r = this.parseIdentifier();
                if (tokenIsKeywordOrIdentifier(this.state.type)) {
                  o = true;
                  n = e;
                  a = t ? this.parseIdentifier() : this.parseModuleExportName();
                  l = false;
                } else {
                  a = r;
                  l = false;
                }
              } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                l = false;
                a = t ? this.parseIdentifier() : this.parseModuleExportName();
              } else {
                o = true;
                n = e;
              }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
              o = true;
              if (t) {
                n = this.parseIdentifier(true);
                if (!this.isContextual(93)) {
                  this.checkReservedWord(n.name, n.loc.start, true, true);
                }
              } else {
                n = this.parseModuleExportName();
              }
            }
            if (o && r) {
              this.raise(
                t
                  ? ie.TypeModifierIsUsedInTypeImports
                  : ie.TypeModifierIsUsedInTypeExports,
                { at: c },
              );
            }
            e[s] = n;
            e[i] = a;
            const p = t ? 'importKind' : 'exportKind';
            e[p] = o ? 'type' : 'value';
            if (l && this.eatContextual(93)) {
              e[i] = t ? this.parseIdentifier() : this.parseModuleExportName();
            }
            if (!e[i]) {
              e[i] = cloneIdentifier(e[s]);
            }
            if (t) {
              this.checkIdentifier(e[i], o ? 4098 : 4096);
            }
          }
        };
      function isPossiblyLiteralEnum(e) {
        if (e.type !== 'MemberExpression') return false;
        const { computed: t, property: r } = e;
        if (
          t &&
          r.type !== 'StringLiteral' &&
          (r.type !== 'TemplateLiteral' || r.expressions.length > 0)
        ) {
          return false;
        }
        return isUncomputedMemberExpressionChain(e.object);
      }
      function isValidAmbientConstInitializer(e, t) {
        var r;
        const { type: s } = e;
        if ((r = e.extra) != null && r.parenthesized) {
          return false;
        }
        if (t) {
          if (s === 'Literal') {
            const { value: t } = e;
            if (typeof t === 'string' || typeof t === 'boolean') {
              return true;
            }
          }
        } else {
          if (s === 'StringLiteral' || s === 'BooleanLiteral') {
            return true;
          }
        }
        if (isNumber(e, t) || isNegativeNumber(e, t)) {
          return true;
        }
        if (s === 'TemplateLiteral' && e.expressions.length === 0) {
          return true;
        }
        if (isPossiblyLiteralEnum(e)) {
          return true;
        }
        return false;
      }
      function isNumber(e, t) {
        if (t) {
          return (
            e.type === 'Literal' &&
            (typeof e.value === 'number' || 'bigint' in e)
          );
        }
        return e.type === 'NumericLiteral' || e.type === 'BigIntLiteral';
      }
      function isNegativeNumber(e, t) {
        if (e.type === 'UnaryExpression') {
          const { operator: r, argument: s } = e;
          if (r === '-' && isNumber(s, t)) {
            return true;
          }
        }
        return false;
      }
      function isUncomputedMemberExpressionChain(e) {
        if (e.type === 'Identifier') return true;
        if (e.type !== 'MemberExpression' || e.computed) {
          return false;
        }
        return isUncomputedMemberExpressionChain(e.object);
      }
      const ne = ParseErrorEnum`placeholders`({
        ClassNameIsRequired: 'A class name is required.',
        UnexpectedSpace: 'Unexpected space in placeholder.',
      });
      var placeholders = (e) =>
        class PlaceholdersParserMixin extends e {
          parsePlaceholder(e) {
            if (this.match(144)) {
              const t = this.startNode();
              this.next();
              this.assertNoSpace();
              t.name = super.parseIdentifier(true);
              this.assertNoSpace();
              this.expect(144);
              return this.finishPlaceholder(t, e);
            }
          }
          finishPlaceholder(e, t) {
            const r = !!(e.expectedNode && e.type === 'Placeholder');
            e.expectedNode = t;
            return r ? e : this.finishNode(e, 'Placeholder');
          }
          getTokenFromCode(e) {
            if (e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
              this.finishOp(144, 2);
            } else {
              super.getTokenFromCode(e);
            }
          }
          parseExprAtom(e) {
            return (
              this.parsePlaceholder('Expression') || super.parseExprAtom(e)
            );
          }
          parseIdentifier(e) {
            return (
              this.parsePlaceholder('Identifier') || super.parseIdentifier(e)
            );
          }
          checkReservedWord(e, t, r, s) {
            if (e !== undefined) {
              super.checkReservedWord(e, t, r, s);
            }
          }
          parseBindingAtom() {
            return this.parsePlaceholder('Pattern') || super.parseBindingAtom();
          }
          isValidLVal(e, t, r) {
            return e === 'Placeholder' || super.isValidLVal(e, t, r);
          }
          toAssignable(e, t) {
            if (
              e &&
              e.type === 'Placeholder' &&
              e.expectedNode === 'Expression'
            ) {
              e.expectedNode = 'Pattern';
            } else {
              super.toAssignable(e, t);
            }
          }
          chStartsBindingIdentifier(e, t) {
            if (super.chStartsBindingIdentifier(e, t)) {
              return true;
            }
            const r = this.lookahead();
            if (r.type === 144) {
              return true;
            }
            return false;
          }
          verifyBreakContinue(e, t) {
            if (e.label && e.label.type === 'Placeholder') return;
            super.verifyBreakContinue(e, t);
          }
          parseExpressionStatement(e, t) {
            var r;
            if (
              t.type !== 'Placeholder' ||
              ((r = t.extra) != null && r.parenthesized)
            ) {
              return super.parseExpressionStatement(e, t);
            }
            if (this.match(14)) {
              const r = e;
              r.label = this.finishPlaceholder(t, 'Identifier');
              this.next();
              r.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
              return this.finishNode(r, 'LabeledStatement');
            }
            this.semicolon();
            e.name = t.name;
            return this.finishPlaceholder(e, 'Statement');
          }
          parseBlock(e, t, r) {
            return (
              this.parsePlaceholder('BlockStatement') ||
              super.parseBlock(e, t, r)
            );
          }
          parseFunctionId(e) {
            return (
              this.parsePlaceholder('Identifier') || super.parseFunctionId(e)
            );
          }
          parseClass(e, t, r) {
            const s = t ? 'ClassDeclaration' : 'ClassExpression';
            this.next();
            const i = this.state.strict;
            const n = this.parsePlaceholder('Identifier');
            if (n) {
              if (this.match(81) || this.match(144) || this.match(5)) {
                e.id = n;
              } else if (r || !t) {
                e.id = null;
                e.body = this.finishPlaceholder(n, 'ClassBody');
                return this.finishNode(e, s);
              } else {
                throw this.raise(ne.ClassNameIsRequired, {
                  at: this.state.startLoc,
                });
              }
            } else {
              this.parseClassId(e, t, r);
            }
            super.parseClassSuper(e);
            e.body =
              this.parsePlaceholder('ClassBody') ||
              super.parseClassBody(!!e.superClass, i);
            return this.finishNode(e, s);
          }
          parseExport(e, t) {
            const r = this.parsePlaceholder('Identifier');
            if (!r) return super.parseExport(e, t);
            if (!this.isContextual(98) && !this.match(12)) {
              e.specifiers = [];
              e.source = null;
              e.declaration = this.finishPlaceholder(r, 'Declaration');
              return this.finishNode(e, 'ExportNamedDeclaration');
            }
            this.expectPlugin('exportDefaultFrom');
            const s = this.startNode();
            s.exported = r;
            e.specifiers = [this.finishNode(s, 'ExportDefaultSpecifier')];
            return super.parseExport(e, t);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              const e = this.nextTokenStart();
              if (this.isUnparsedContextual(e, 'from')) {
                if (
                  this.input.startsWith(
                    tokenLabelName(144),
                    this.nextTokenStartSince(e + 4),
                  )
                ) {
                  return true;
                }
              }
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(e, t) {
            var r;
            if ((r = e.specifiers) != null && r.length) {
              return true;
            }
            return super.maybeParseExportDefaultSpecifier(e, t);
          }
          checkExport(e) {
            const { specifiers: t } = e;
            if (t != null && t.length) {
              e.specifiers = t.filter((e) => e.exported.type === 'Placeholder');
            }
            super.checkExport(e);
            e.specifiers = t;
          }
          parseImport(e) {
            const t = this.parsePlaceholder('Identifier');
            if (!t) return super.parseImport(e);
            e.specifiers = [];
            if (!this.isContextual(98) && !this.match(12)) {
              e.source = this.finishPlaceholder(t, 'StringLiteral');
              this.semicolon();
              return this.finishNode(e, 'ImportDeclaration');
            }
            const r = this.startNodeAtNode(t);
            r.local = t;
            e.specifiers.push(this.finishNode(r, 'ImportDefaultSpecifier'));
            if (this.eat(12)) {
              const t = this.maybeParseStarImportSpecifier(e);
              if (!t) this.parseNamedImportSpecifiers(e);
            }
            this.expectContextual(98);
            e.source = this.parseImportSource();
            this.semicolon();
            return this.finishNode(e, 'ImportDeclaration');
          }
          parseImportSource() {
            return (
              this.parsePlaceholder('StringLiteral') ||
              super.parseImportSource()
            );
          }
          assertNoSpace() {
            if (this.state.start > this.state.lastTokEndLoc.index) {
              this.raise(ne.UnexpectedSpace, { at: this.state.lastTokEndLoc });
            }
          }
        };
      var v8intrinsic = (e) =>
        class V8IntrinsicMixin extends e {
          parseV8Intrinsic() {
            if (this.match(54)) {
              const e = this.state.startLoc;
              const t = this.startNode();
              this.next();
              if (tokenIsIdentifier(this.state.type)) {
                const e = this.parseIdentifierName();
                const r = this.createIdentifier(t, e);
                r.type = 'V8IntrinsicIdentifier';
                if (this.match(10)) {
                  return r;
                }
              }
              this.unexpected(e);
            }
          }
          parseExprAtom(e) {
            return this.parseV8Intrinsic() || super.parseExprAtom(e);
          }
        };
      function hasPlugin(e, t) {
        const [r, s] = typeof t === 'string' ? [t, {}] : t;
        const i = Object.keys(s);
        const n = i.length === 0;
        return e.some((e) => {
          if (typeof e === 'string') {
            return n && e === r;
          } else {
            const [t, n] = e;
            if (t !== r) {
              return false;
            }
            for (const e of i) {
              if (n[e] !== s[e]) {
                return false;
              }
            }
            return true;
          }
        });
      }
      function getPluginOption(e, t, r) {
        const s = e.find((e) => {
          if (Array.isArray(e)) {
            return e[0] === t;
          } else {
            return e === t;
          }
        });
        if (s && Array.isArray(s) && s.length > 1) {
          return s[1][r];
        }
        return null;
      }
      const ae = ['minimal', 'fsharp', 'hack', 'smart'];
      const oe = ['^^', '@@', '^', '%', '#'];
      const le = ['hash', 'bar'];
      function validatePlugins(e) {
        if (hasPlugin(e, 'decorators')) {
          if (hasPlugin(e, 'decorators-legacy')) {
            throw new Error(
              'Cannot use the decorators and decorators-legacy plugin together',
            );
          }
          const t = getPluginOption(e, 'decorators', 'decoratorsBeforeExport');
          if (t != null && typeof t !== 'boolean') {
            throw new Error(
              "'decoratorsBeforeExport' must be a boolean, if specified.",
            );
          }
          const r = getPluginOption(e, 'decorators', 'allowCallParenthesized');
          if (r != null && typeof r !== 'boolean') {
            throw new Error("'allowCallParenthesized' must be a boolean.");
          }
        }
        if (hasPlugin(e, 'flow') && hasPlugin(e, 'typescript')) {
          throw new Error('Cannot combine flow and typescript plugins.');
        }
        if (hasPlugin(e, 'placeholders') && hasPlugin(e, 'v8intrinsic')) {
          throw new Error(
            'Cannot combine placeholders and v8intrinsic plugins.',
          );
        }
        if (hasPlugin(e, 'pipelineOperator')) {
          const t = getPluginOption(e, 'pipelineOperator', 'proposal');
          if (!ae.includes(t)) {
            const e = ae.map((e) => `"${e}"`).join(', ');
            throw new Error(
              `"pipelineOperator" requires "proposal" option whose value must be one of: ${e}.`,
            );
          }
          const r = hasPlugin(e, ['recordAndTuple', { syntaxType: 'hash' }]);
          if (t === 'hack') {
            if (hasPlugin(e, 'placeholders')) {
              throw new Error(
                'Cannot combine placeholders plugin and Hack-style pipes.',
              );
            }
            if (hasPlugin(e, 'v8intrinsic')) {
              throw new Error(
                'Cannot combine v8intrinsic plugin and Hack-style pipes.',
              );
            }
            const t = getPluginOption(e, 'pipelineOperator', 'topicToken');
            if (!oe.includes(t)) {
              const e = oe.map((e) => `"${e}"`).join(', ');
              throw new Error(
                `"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e}.`,
              );
            }
            if (t === '#' && r) {
              throw new Error(
                'Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.',
              );
            }
          } else if (t === 'smart' && r) {
            throw new Error(
              'Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.',
            );
          }
        }
        if (hasPlugin(e, 'moduleAttributes')) {
          {
            if (
              hasPlugin(e, 'importAssertions') ||
              hasPlugin(e, 'importAttributes')
            ) {
              throw new Error(
                'Cannot combine importAssertions, importAttributes and moduleAttributes plugins.',
              );
            }
            const t = getPluginOption(e, 'moduleAttributes', 'version');
            if (t !== 'may-2020') {
              throw new Error(
                "The 'moduleAttributes' plugin requires a 'version' option," +
                  ' representing the last proposal update. Currently, the' +
                  " only supported value is 'may-2020'.",
              );
            }
          }
        }
        if (
          hasPlugin(e, 'importAssertions') &&
          hasPlugin(e, 'importAttributes')
        ) {
          throw new Error(
            'Cannot combine importAssertions and importAttributes plugins.',
          );
        }
        if (
          hasPlugin(e, 'recordAndTuple') &&
          getPluginOption(e, 'recordAndTuple', 'syntaxType') != null &&
          !le.includes(getPluginOption(e, 'recordAndTuple', 'syntaxType'))
        ) {
          throw new Error(
            "The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " +
              le.map((e) => `'${e}'`).join(', '),
          );
        }
        if (
          hasPlugin(e, 'asyncDoExpressions') &&
          !hasPlugin(e, 'doExpressions')
        ) {
          const e = new Error(
            "'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.",
          );
          e.missingPlugins = 'doExpressions';
          throw e;
        }
        if (
          hasPlugin(e, 'optionalChainingAssign') &&
          getPluginOption(e, 'optionalChainingAssign', 'version') !== '2023-07'
        ) {
          throw new Error(
            "The 'optionalChainingAssign' plugin requires a 'version' option," +
              ' representing the last proposal update. Currently, the' +
              " only supported value is '2023-07'.",
          );
        }
      }
      const ce = {
        estree: estree,
        jsx: jsx,
        flow: flow,
        typescript: typescript,
        v8intrinsic: v8intrinsic,
        placeholders: placeholders,
      };
      const pe = Object.keys(ce);
      const ue = {
        sourceType: 'script',
        sourceFilename: undefined,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowNewTargetOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createImportExpressions: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true,
        annexB: true,
      };
      function getOptions(e) {
        if (e == null) {
          return Object.assign({}, ue);
        }
        if (e.annexB != null && e.annexB !== false) {
          throw new Error('The `annexB` option can only be set to `false`.');
        }
        const t = {};
        for (const s of Object.keys(ue)) {
          var r;
          t[s] = (r = e[s]) != null ? r : ue[s];
        }
        return t;
      }
      class ExpressionParser extends LValParser {
        checkProto(e, t, r, s) {
          if (
            e.type === 'SpreadElement' ||
            this.isObjectMethod(e) ||
            e.computed ||
            e.shorthand
          ) {
            return;
          }
          const i = e.key;
          const n = i.type === 'Identifier' ? i.name : i.value;
          if (n === '__proto__') {
            if (t) {
              this.raise(u.RecordNoProto, { at: i });
              return;
            }
            if (r.used) {
              if (s) {
                if (s.doubleProtoLoc === null) {
                  s.doubleProtoLoc = i.loc.start;
                }
              } else {
                this.raise(u.DuplicateProto, { at: i });
              }
            }
            r.used = true;
          }
        }
        shouldExitDescending(e, t) {
          return e.type === 'ArrowFunctionExpression' && e.start === t;
        }
        getExpression() {
          this.enterInitialScopes();
          this.nextToken();
          const e = this.parseExpression();
          if (!this.match(139)) {
            this.unexpected();
          }
          this.finalizeRemainingComments();
          e.comments = this.state.comments;
          e.errors = this.state.errors;
          if (this.options.tokens) {
            e.tokens = this.tokens;
          }
          return e;
        }
        parseExpression(e, t) {
          if (e) {
            return this.disallowInAnd(() => this.parseExpressionBase(t));
          }
          return this.allowInAnd(() => this.parseExpressionBase(t));
        }
        parseExpressionBase(e) {
          const t = this.state.startLoc;
          const r = this.parseMaybeAssign(e);
          if (this.match(12)) {
            const s = this.startNodeAt(t);
            s.expressions = [r];
            while (this.eat(12)) {
              s.expressions.push(this.parseMaybeAssign(e));
            }
            this.toReferencedList(s.expressions);
            return this.finishNode(s, 'SequenceExpression');
          }
          return r;
        }
        parseMaybeAssignDisallowIn(e, t) {
          return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
        }
        parseMaybeAssignAllowIn(e, t) {
          return this.allowInAnd(() => this.parseMaybeAssign(e, t));
        }
        setOptionalParametersError(e, t) {
          var r;
          e.optionalParametersLoc =
            (r = t == null ? void 0 : t.loc) != null ? r : this.state.startLoc;
        }
        parseMaybeAssign(e, t) {
          const r = this.state.startLoc;
          if (this.isContextual(108)) {
            if (this.prodParam.hasYield) {
              let e = this.parseYield();
              if (t) {
                e = t.call(this, e, r);
              }
              return e;
            }
          }
          let s;
          if (e) {
            s = false;
          } else {
            e = new ExpressionErrors();
            s = true;
          }
          const { type: i } = this.state;
          if (i === 10 || tokenIsIdentifier(i)) {
            this.state.potentialArrowAt = this.state.start;
          }
          let n = this.parseMaybeConditional(e);
          if (t) {
            n = t.call(this, n, r);
          }
          if (tokenIsAssignment(this.state.type)) {
            const t = this.startNodeAt(r);
            const s = this.state.value;
            t.operator = s;
            if (this.match(29)) {
              this.toAssignable(n, true);
              t.left = n;
              const s = r.index;
              if (e.doubleProtoLoc != null && e.doubleProtoLoc.index >= s) {
                e.doubleProtoLoc = null;
              }
              if (
                e.shorthandAssignLoc != null &&
                e.shorthandAssignLoc.index >= s
              ) {
                e.shorthandAssignLoc = null;
              }
              if (e.privateKeyLoc != null && e.privateKeyLoc.index >= s) {
                this.checkDestructuringPrivate(e);
                e.privateKeyLoc = null;
              }
            } else {
              t.left = n;
            }
            this.next();
            t.right = this.parseMaybeAssign();
            this.checkLVal(n, {
              in: this.finishNode(t, 'AssignmentExpression'),
            });
            return t;
          } else if (s) {
            this.checkExpressionErrors(e, true);
          }
          return n;
        }
        parseMaybeConditional(e) {
          const t = this.state.startLoc;
          const r = this.state.potentialArrowAt;
          const s = this.parseExprOps(e);
          if (this.shouldExitDescending(s, r)) {
            return s;
          }
          return this.parseConditional(s, t, e);
        }
        parseConditional(e, t, r) {
          if (this.eat(17)) {
            const r = this.startNodeAt(t);
            r.test = e;
            r.consequent = this.parseMaybeAssignAllowIn();
            this.expect(14);
            r.alternate = this.parseMaybeAssign();
            return this.finishNode(r, 'ConditionalExpression');
          }
          return e;
        }
        parseMaybeUnaryOrPrivate(e) {
          return this.match(138)
            ? this.parsePrivateName()
            : this.parseMaybeUnary(e);
        }
        parseExprOps(e) {
          const t = this.state.startLoc;
          const r = this.state.potentialArrowAt;
          const s = this.parseMaybeUnaryOrPrivate(e);
          if (this.shouldExitDescending(s, r)) {
            return s;
          }
          return this.parseExprOp(s, t, -1);
        }
        parseExprOp(e, t, r) {
          if (this.isPrivateName(e)) {
            const t = this.getPrivateNameSV(e);
            if (
              r >= tokenOperatorPrecedence(58) ||
              !this.prodParam.hasIn ||
              !this.match(58)
            ) {
              this.raise(u.PrivateInExpectedIn, { at: e, identifierName: t });
            }
            this.classScope.usePrivateName(t, e.loc.start);
          }
          const s = this.state.type;
          if (tokenIsOperator(s) && (this.prodParam.hasIn || !this.match(58))) {
            let i = tokenOperatorPrecedence(s);
            if (i > r) {
              if (s === 39) {
                this.expectPlugin('pipelineOperator');
                if (this.state.inFSharpPipelineDirectBody) {
                  return e;
                }
                this.checkPipelineAtInfixOperator(e, t);
              }
              const n = this.startNodeAt(t);
              n.left = e;
              n.operator = this.state.value;
              const a = s === 41 || s === 42;
              const o = s === 40;
              if (o) {
                i = tokenOperatorPrecedence(42);
              }
              this.next();
              if (
                s === 39 &&
                this.hasPlugin(['pipelineOperator', { proposal: 'minimal' }])
              ) {
                if (this.state.type === 96 && this.prodParam.hasAwait) {
                  throw this.raise(u.UnexpectedAwaitAfterPipelineBody, {
                    at: this.state.startLoc,
                  });
                }
              }
              n.right = this.parseExprOpRightExpr(s, i);
              const l = this.finishNode(
                n,
                a || o ? 'LogicalExpression' : 'BinaryExpression',
              );
              const c = this.state.type;
              if ((o && (c === 41 || c === 42)) || (a && c === 40)) {
                throw this.raise(u.MixingCoalesceWithLogical, {
                  at: this.state.startLoc,
                });
              }
              return this.parseExprOp(l, t, r);
            }
          }
          return e;
        }
        parseExprOpRightExpr(e, t) {
          const r = this.state.startLoc;
          switch (e) {
            case 39:
              switch (this.getPluginOption('pipelineOperator', 'proposal')) {
                case 'hack':
                  return this.withTopicBindingContext(() =>
                    this.parseHackPipeBody(),
                  );
                case 'smart':
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(108)) {
                      throw this.raise(u.PipeBodyIsTighter, {
                        at: this.state.startLoc,
                      });
                    }
                    return this.parseSmartPipelineBodyInStyle(
                      this.parseExprOpBaseRightExpr(e, t),
                      r,
                    );
                  });
                case 'fsharp':
                  return this.withSoloAwaitPermittingContext(() =>
                    this.parseFSharpPipelineBody(t),
                  );
              }
            default:
              return this.parseExprOpBaseRightExpr(e, t);
          }
        }
        parseExprOpBaseRightExpr(e, t) {
          const r = this.state.startLoc;
          return this.parseExprOp(
            this.parseMaybeUnaryOrPrivate(),
            r,
            tokenIsRightAssociative(e) ? t - 1 : t,
          );
        }
        parseHackPipeBody() {
          var e;
          const { startLoc: t } = this.state;
          const r = this.parseMaybeAssign();
          const s = o.has(r.type);
          if (s && !((e = r.extra) != null && e.parenthesized)) {
            this.raise(u.PipeUnparenthesizedBody, { at: t, type: r.type });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(u.PipeTopicUnused, { at: t });
          }
          return r;
        }
        checkExponentialAfterUnary(e) {
          if (this.match(57)) {
            this.raise(u.UnexpectedTokenUnaryExponentiation, {
              at: e.argument,
            });
          }
        }
        parseMaybeUnary(e, t) {
          const r = this.state.startLoc;
          const s = this.isContextual(96);
          if (s && this.isAwaitAllowed()) {
            this.next();
            const e = this.parseAwait(r);
            if (!t) this.checkExponentialAfterUnary(e);
            return e;
          }
          const i = this.match(34);
          const n = this.startNode();
          if (tokenIsPrefix(this.state.type)) {
            n.operator = this.state.value;
            n.prefix = true;
            if (this.match(72)) {
              this.expectPlugin('throwExpressions');
            }
            const r = this.match(89);
            this.next();
            n.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(e, true);
            if (this.state.strict && r) {
              const e = n.argument;
              if (e.type === 'Identifier') {
                this.raise(u.StrictDelete, { at: n });
              } else if (this.hasPropertyAsPrivateName(e)) {
                this.raise(u.DeletePrivateField, { at: n });
              }
            }
            if (!i) {
              if (!t) {
                this.checkExponentialAfterUnary(n);
              }
              return this.finishNode(n, 'UnaryExpression');
            }
          }
          const a = this.parseUpdate(n, i, e);
          if (s) {
            const { type: e } = this.state;
            const t = this.hasPlugin('v8intrinsic')
              ? tokenCanStartExpression(e)
              : tokenCanStartExpression(e) && !this.match(54);
            if (t && !this.isAmbiguousAwait()) {
              this.raiseOverwrite(u.AwaitNotInAsyncContext, { at: r });
              return this.parseAwait(r);
            }
          }
          return a;
        }
        parseUpdate(e, t, r) {
          if (t) {
            const t = e;
            this.checkLVal(t.argument, {
              in: this.finishNode(t, 'UpdateExpression'),
            });
            return e;
          }
          const s = this.state.startLoc;
          let i = this.parseExprSubscripts(r);
          if (this.checkExpressionErrors(r, false)) return i;
          while (
            tokenIsPostfix(this.state.type) &&
            !this.canInsertSemicolon()
          ) {
            const e = this.startNodeAt(s);
            e.operator = this.state.value;
            e.prefix = false;
            e.argument = i;
            this.next();
            this.checkLVal(i, {
              in: (i = this.finishNode(e, 'UpdateExpression')),
            });
          }
          return i;
        }
        parseExprSubscripts(e) {
          const t = this.state.startLoc;
          const r = this.state.potentialArrowAt;
          const s = this.parseExprAtom(e);
          if (this.shouldExitDescending(s, r)) {
            return s;
          }
          return this.parseSubscripts(s, t);
        }
        parseSubscripts(e, t, r) {
          const s = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(e),
            stop: false,
          };
          do {
            e = this.parseSubscript(e, t, r, s);
            s.maybeAsyncArrow = false;
          } while (!s.stop);
          return e;
        }
        parseSubscript(e, t, r, s) {
          const { type: i } = this.state;
          if (!r && i === 15) {
            return this.parseBind(e, t, r, s);
          } else if (tokenIsTemplate(i)) {
            return this.parseTaggedTemplateExpression(e, t, s);
          }
          let n = false;
          if (i === 18) {
            if (r) {
              this.raise(u.OptionalChainingNoNew, { at: this.state.startLoc });
              if (this.lookaheadCharCode() === 40) {
                s.stop = true;
                return e;
              }
            }
            s.optionalChainMember = n = true;
            this.next();
          }
          if (!r && this.match(10)) {
            return this.parseCoverCallAndAsyncArrowHead(e, t, s, n);
          } else {
            const r = this.eat(0);
            if (r || n || this.eat(16)) {
              return this.parseMember(e, t, s, r, n);
            } else {
              s.stop = true;
              return e;
            }
          }
        }
        parseMember(e, t, r, s, i) {
          const n = this.startNodeAt(t);
          n.object = e;
          n.computed = s;
          if (s) {
            n.property = this.parseExpression();
            this.expect(3);
          } else if (this.match(138)) {
            if (e.type === 'Super') {
              this.raise(u.SuperPrivateField, { at: t });
            }
            this.classScope.usePrivateName(
              this.state.value,
              this.state.startLoc,
            );
            n.property = this.parsePrivateName();
          } else {
            n.property = this.parseIdentifier(true);
          }
          if (r.optionalChainMember) {
            n.optional = i;
            return this.finishNode(n, 'OptionalMemberExpression');
          } else {
            return this.finishNode(n, 'MemberExpression');
          }
        }
        parseBind(e, t, r, s) {
          const i = this.startNodeAt(t);
          i.object = e;
          this.next();
          i.callee = this.parseNoCallExpr();
          s.stop = true;
          return this.parseSubscripts(
            this.finishNode(i, 'BindExpression'),
            t,
            r,
          );
        }
        parseCoverCallAndAsyncArrowHead(e, t, r, s) {
          const i = this.state.maybeInArrowParameters;
          let n = null;
          this.state.maybeInArrowParameters = true;
          this.next();
          const a = this.startNodeAt(t);
          a.callee = e;
          const { maybeAsyncArrow: o, optionalChainMember: l } = r;
          if (o) {
            this.expressionScope.enter(newAsyncArrowScope());
            n = new ExpressionErrors();
          }
          if (l) {
            a.optional = s;
          }
          if (s) {
            a.arguments = this.parseCallExpressionArguments(11);
          } else {
            a.arguments = this.parseCallExpressionArguments(
              11,
              e.type === 'Import',
              e.type !== 'Super',
              a,
              n,
            );
          }
          let c = this.finishCallExpression(a, l);
          if (o && this.shouldParseAsyncArrow() && !s) {
            r.stop = true;
            this.checkDestructuringPrivate(n);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            c = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t), c);
          } else {
            if (o) {
              this.checkExpressionErrors(n, true);
              this.expressionScope.exit();
            }
            this.toReferencedArguments(c);
          }
          this.state.maybeInArrowParameters = i;
          return c;
        }
        toReferencedArguments(e, t) {
          this.toReferencedListDeep(e.arguments, t);
        }
        parseTaggedTemplateExpression(e, t, r) {
          const s = this.startNodeAt(t);
          s.tag = e;
          s.quasi = this.parseTemplate(true);
          if (r.optionalChainMember) {
            this.raise(u.OptionalChainingNoTemplate, { at: t });
          }
          return this.finishNode(s, 'TaggedTemplateExpression');
        }
        atPossibleAsyncArrow(e) {
          return (
            e.type === 'Identifier' &&
            e.name === 'async' &&
            this.state.lastTokEndLoc.index === e.end &&
            !this.canInsertSemicolon() &&
            e.end - e.start === 5 &&
            e.start === this.state.potentialArrowAt
          );
        }
        expectImportAttributesPlugin() {
          if (!this.hasPlugin('importAssertions')) {
            this.expectPlugin('importAttributes');
          }
        }
        finishCallExpression(e, t) {
          if (e.callee.type === 'Import') {
            if (e.arguments.length === 2) {
              {
                if (!this.hasPlugin('moduleAttributes')) {
                  this.expectImportAttributesPlugin();
                }
              }
            }
            if (e.arguments.length === 0 || e.arguments.length > 2) {
              this.raise(u.ImportCallArity, {
                at: e,
                maxArgumentCount:
                  this.hasPlugin('importAttributes') ||
                  this.hasPlugin('importAssertions') ||
                  this.hasPlugin('moduleAttributes')
                    ? 2
                    : 1,
              });
            } else {
              for (const t of e.arguments) {
                if (t.type === 'SpreadElement') {
                  this.raise(u.ImportCallSpreadArgument, { at: t });
                }
              }
            }
          }
          return this.finishNode(
            e,
            t ? 'OptionalCallExpression' : 'CallExpression',
          );
        }
        parseCallExpressionArguments(e, t, r, s, i) {
          const n = [];
          let a = true;
          const o = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          while (!this.eat(e)) {
            if (a) {
              a = false;
            } else {
              this.expect(12);
              if (this.match(e)) {
                if (
                  t &&
                  !this.hasPlugin('importAttributes') &&
                  !this.hasPlugin('importAssertions') &&
                  !this.hasPlugin('moduleAttributes')
                ) {
                  this.raise(u.ImportCallArgumentTrailingComma, {
                    at: this.state.lastTokStartLoc,
                  });
                }
                if (s) {
                  this.addTrailingCommaExtraToNode(s);
                }
                this.next();
                break;
              }
            }
            n.push(this.parseExprListItem(false, i, r));
          }
          this.state.inFSharpPipelineDirectBody = o;
          return n;
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(e, t) {
          var r;
          this.resetPreviousNodeTrailingComments(t);
          this.expect(19);
          this.parseArrowExpression(
            e,
            t.arguments,
            true,
            (r = t.extra) == null ? void 0 : r.trailingCommaLoc,
          );
          if (t.innerComments) {
            setInnerComments(e, t.innerComments);
          }
          if (t.callee.trailingComments) {
            setInnerComments(e, t.callee.trailingComments);
          }
          return e;
        }
        parseNoCallExpr() {
          const e = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), e, true);
        }
        parseExprAtom(e) {
          let t;
          let r = null;
          const { type: s } = this.state;
          switch (s) {
            case 79:
              return this.parseSuper();
            case 83:
              t = this.startNode();
              this.next();
              if (this.match(16)) {
                return this.parseImportMetaProperty(t);
              }
              if (this.match(10)) {
                if (this.options.createImportExpressions) {
                  return this.parseImportCall(t);
                } else {
                  return this.finishNode(t, 'Import');
                }
              } else {
                this.raise(u.UnsupportedImport, {
                  at: this.state.lastTokStartLoc,
                });
                return this.finishNode(t, 'Import');
              }
            case 78:
              t = this.startNode();
              this.next();
              return this.finishNode(t, 'ThisExpression');
            case 90: {
              return this.parseDo(this.startNode(), false);
            }
            case 56:
            case 31: {
              this.readRegexp();
              return this.parseRegExpLiteral(this.state.value);
            }
            case 134:
              return this.parseNumericLiteral(this.state.value);
            case 135:
              return this.parseBigIntLiteral(this.state.value);
            case 136:
              return this.parseDecimalLiteral(this.state.value);
            case 133:
              return this.parseStringLiteral(this.state.value);
            case 84:
              return this.parseNullLiteral();
            case 85:
              return this.parseBooleanLiteral(true);
            case 86:
              return this.parseBooleanLiteral(false);
            case 10: {
              const e = this.state.potentialArrowAt === this.state.start;
              return this.parseParenAndDistinguishExpression(e);
            }
            case 2:
            case 1: {
              return this.parseArrayLike(
                this.state.type === 2 ? 4 : 3,
                false,
                true,
              );
            }
            case 0: {
              return this.parseArrayLike(3, true, false, e);
            }
            case 6:
            case 7: {
              return this.parseObjectLike(
                this.state.type === 6 ? 9 : 8,
                false,
                true,
              );
            }
            case 5: {
              return this.parseObjectLike(8, false, false, e);
            }
            case 68:
              return this.parseFunctionOrFunctionSent();
            case 26:
              r = this.parseDecorators();
            case 80:
              return this.parseClass(
                this.maybeTakeDecorators(r, this.startNode()),
                false,
              );
            case 77:
              return this.parseNewOrNewTarget();
            case 25:
            case 24:
              return this.parseTemplate(false);
            case 15: {
              t = this.startNode();
              this.next();
              t.object = null;
              const e = (t.callee = this.parseNoCallExpr());
              if (e.type === 'MemberExpression') {
                return this.finishNode(t, 'BindExpression');
              } else {
                throw this.raise(u.UnsupportedBind, { at: e });
              }
            }
            case 138: {
              this.raise(u.PrivateInExpectedIn, {
                at: this.state.startLoc,
                identifierName: this.state.value,
              });
              return this.parsePrivateName();
            }
            case 33: {
              return this.parseTopicReferenceThenEqualsSign(54, '%');
            }
            case 32: {
              return this.parseTopicReferenceThenEqualsSign(44, '^');
            }
            case 37:
            case 38: {
              return this.parseTopicReference('hack');
            }
            case 44:
            case 54:
            case 27: {
              const e = this.getPluginOption('pipelineOperator', 'proposal');
              if (e) {
                return this.parseTopicReference(e);
              }
              this.unexpected();
              break;
            }
            case 47: {
              const e = this.input.codePointAt(this.nextTokenStart());
              if (isIdentifierStart(e) || e === 62) {
                this.expectOnePlugin(['jsx', 'flow', 'typescript']);
              } else {
                this.unexpected();
              }
              break;
            }
            default:
              if (tokenIsIdentifier(s)) {
                if (
                  this.isContextual(127) &&
                  this.lookaheadInLineCharCode() === 123
                ) {
                  return this.parseModuleExpression();
                }
                const e = this.state.potentialArrowAt === this.state.start;
                const t = this.state.containsEsc;
                const r = this.parseIdentifier();
                if (!t && r.name === 'async' && !this.canInsertSemicolon()) {
                  const { type: e } = this.state;
                  if (e === 68) {
                    this.resetPreviousNodeTrailingComments(r);
                    this.next();
                    return this.parseAsyncFunctionExpression(
                      this.startNodeAtNode(r),
                    );
                  } else if (tokenIsIdentifier(e)) {
                    if (this.lookaheadCharCode() === 61) {
                      return this.parseAsyncArrowUnaryFunction(
                        this.startNodeAtNode(r),
                      );
                    } else {
                      return r;
                    }
                  } else if (e === 90) {
                    this.resetPreviousNodeTrailingComments(r);
                    return this.parseDo(this.startNodeAtNode(r), true);
                  }
                }
                if (e && this.match(19) && !this.canInsertSemicolon()) {
                  this.next();
                  return this.parseArrowExpression(
                    this.startNodeAtNode(r),
                    [r],
                    false,
                  );
                }
                return r;
              } else {
                this.unexpected();
              }
          }
        }
        parseTopicReferenceThenEqualsSign(e, t) {
          const r = this.getPluginOption('pipelineOperator', 'proposal');
          if (r) {
            this.state.type = e;
            this.state.value = t;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc = createPositionWithColumnOffset(
              this.state.endLoc,
              -1,
            );
            return this.parseTopicReference(r);
          } else {
            this.unexpected();
          }
        }
        parseTopicReference(e) {
          const t = this.startNode();
          const r = this.state.startLoc;
          const s = this.state.type;
          this.next();
          return this.finishTopicReference(t, r, e, s);
        }
        finishTopicReference(e, t, r, s) {
          if (this.testTopicReferenceConfiguration(r, t, s)) {
            const s =
              r === 'smart'
                ? 'PipelinePrimaryTopicReference'
                : 'TopicReference';
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(
                r === 'smart' ? u.PrimaryTopicNotAllowed : u.PipeTopicUnbound,
                { at: t },
              );
            }
            this.registerTopicReference();
            return this.finishNode(e, s);
          } else {
            throw this.raise(u.PipeTopicUnconfiguredToken, {
              at: t,
              token: tokenLabelName(s),
            });
          }
        }
        testTopicReferenceConfiguration(e, t, r) {
          switch (e) {
            case 'hack': {
              return this.hasPlugin([
                'pipelineOperator',
                { topicToken: tokenLabelName(r) },
              ]);
            }
            case 'smart':
              return r === 27;
            default:
              throw this.raise(u.PipeTopicRequiresHackPipes, { at: t });
          }
        }
        parseAsyncArrowUnaryFunction(e) {
          this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
          const t = [this.parseIdentifier()];
          this.prodParam.exit();
          if (this.hasPrecedingLineBreak()) {
            this.raise(u.LineTerminatorBeforeArrow, {
              at: this.state.curPosition(),
            });
          }
          this.expect(19);
          return this.parseArrowExpression(e, t, true);
        }
        parseDo(e, t) {
          this.expectPlugin('doExpressions');
          if (t) {
            this.expectPlugin('asyncDoExpressions');
          }
          e.async = t;
          this.next();
          const r = this.state.labels;
          this.state.labels = [];
          if (t) {
            this.prodParam.enter(2);
            e.body = this.parseBlock();
            this.prodParam.exit();
          } else {
            e.body = this.parseBlock();
          }
          this.state.labels = r;
          return this.finishNode(e, 'DoExpression');
        }
        parseSuper() {
          const e = this.startNode();
          this.next();
          if (
            this.match(10) &&
            !this.scope.allowDirectSuper &&
            !this.options.allowSuperOutsideMethod
          ) {
            this.raise(u.SuperNotAllowed, { at: e });
          } else if (
            !this.scope.allowSuper &&
            !this.options.allowSuperOutsideMethod
          ) {
            this.raise(u.UnexpectedSuper, { at: e });
          }
          if (!this.match(10) && !this.match(0) && !this.match(16)) {
            this.raise(u.UnsupportedSuper, { at: e });
          }
          return this.finishNode(e, 'Super');
        }
        parsePrivateName() {
          const e = this.startNode();
          const t = this.startNodeAt(
            createPositionWithColumnOffset(this.state.startLoc, 1),
          );
          const r = this.state.value;
          this.next();
          e.id = this.createIdentifier(t, r);
          return this.finishNode(e, 'PrivateName');
        }
        parseFunctionOrFunctionSent() {
          const e = this.startNode();
          this.next();
          if (this.prodParam.hasYield && this.match(16)) {
            const t = this.createIdentifier(
              this.startNodeAtNode(e),
              'function',
            );
            this.next();
            if (this.match(103)) {
              this.expectPlugin('functionSent');
            } else if (!this.hasPlugin('functionSent')) {
              this.unexpected();
            }
            return this.parseMetaProperty(e, t, 'sent');
          }
          return this.parseFunction(e);
        }
        parseMetaProperty(e, t, r) {
          e.meta = t;
          const s = this.state.containsEsc;
          e.property = this.parseIdentifier(true);
          if (e.property.name !== r || s) {
            this.raise(u.UnsupportedMetaProperty, {
              at: e.property,
              target: t.name,
              onlyValidPropertyName: r,
            });
          }
          return this.finishNode(e, 'MetaProperty');
        }
        parseImportMetaProperty(e) {
          const t = this.createIdentifier(this.startNodeAtNode(e), 'import');
          this.next();
          if (this.isContextual(101)) {
            if (!this.inModule) {
              this.raise(u.ImportMetaOutsideModule, { at: t });
            }
            this.sawUnambiguousESM = true;
          } else if (this.isContextual(105) || this.isContextual(97)) {
            const t = this.isContextual(105);
            if (!t) this.unexpected();
            this.expectPlugin(
              t ? 'sourcePhaseImports' : 'deferredImportEvaluation',
            );
            if (!this.options.createImportExpressions) {
              throw this.raise(u.DynamicImportPhaseRequiresImportExpressions, {
                at: this.state.startLoc,
                phase: this.state.value,
              });
            }
            this.next();
            e.phase = t ? 'source' : 'defer';
            return this.parseImportCall(e);
          }
          return this.parseMetaProperty(e, t, 'meta');
        }
        parseLiteralAtNode(e, t, r) {
          this.addExtra(r, 'rawValue', e);
          this.addExtra(r, 'raw', this.input.slice(r.start, this.state.end));
          r.value = e;
          this.next();
          return this.finishNode(r, t);
        }
        parseLiteral(e, t) {
          const r = this.startNode();
          return this.parseLiteralAtNode(e, t, r);
        }
        parseStringLiteral(e) {
          return this.parseLiteral(e, 'StringLiteral');
        }
        parseNumericLiteral(e) {
          return this.parseLiteral(e, 'NumericLiteral');
        }
        parseBigIntLiteral(e) {
          return this.parseLiteral(e, 'BigIntLiteral');
        }
        parseDecimalLiteral(e) {
          return this.parseLiteral(e, 'DecimalLiteral');
        }
        parseRegExpLiteral(e) {
          const t = this.parseLiteral(e.value, 'RegExpLiteral');
          t.pattern = e.pattern;
          t.flags = e.flags;
          return t;
        }
        parseBooleanLiteral(e) {
          const t = this.startNode();
          t.value = e;
          this.next();
          return this.finishNode(t, 'BooleanLiteral');
        }
        parseNullLiteral() {
          const e = this.startNode();
          this.next();
          return this.finishNode(e, 'NullLiteral');
        }
        parseParenAndDistinguishExpression(e) {
          const t = this.state.startLoc;
          let r;
          this.next();
          this.expressionScope.enter(newArrowHeadScope());
          const s = this.state.maybeInArrowParameters;
          const i = this.state.inFSharpPipelineDirectBody;
          this.state.maybeInArrowParameters = true;
          this.state.inFSharpPipelineDirectBody = false;
          const n = this.state.startLoc;
          const a = [];
          const o = new ExpressionErrors();
          let l = true;
          let c;
          let p;
          while (!this.match(11)) {
            if (l) {
              l = false;
            } else {
              this.expect(
                12,
                o.optionalParametersLoc === null
                  ? null
                  : o.optionalParametersLoc,
              );
              if (this.match(11)) {
                p = this.state.startLoc;
                break;
              }
            }
            if (this.match(21)) {
              const e = this.state.startLoc;
              c = this.state.startLoc;
              a.push(this.parseParenItem(this.parseRestBinding(), e));
              if (!this.checkCommaAfterRest(41)) {
                break;
              }
            } else {
              a.push(this.parseMaybeAssignAllowIn(o, this.parseParenItem));
            }
          }
          const u = this.state.lastTokEndLoc;
          this.expect(11);
          this.state.maybeInArrowParameters = s;
          this.state.inFSharpPipelineDirectBody = i;
          let d = this.startNodeAt(t);
          if (e && this.shouldParseArrow(a) && (d = this.parseArrow(d))) {
            this.checkDestructuringPrivate(o);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            this.parseArrowExpression(d, a, false);
            return d;
          }
          this.expressionScope.exit();
          if (!a.length) {
            this.unexpected(this.state.lastTokStartLoc);
          }
          if (p) this.unexpected(p);
          if (c) this.unexpected(c);
          this.checkExpressionErrors(o, true);
          this.toReferencedListDeep(a, true);
          if (a.length > 1) {
            r = this.startNodeAt(n);
            r.expressions = a;
            this.finishNode(r, 'SequenceExpression');
            this.resetEndLocation(r, u);
          } else {
            r = a[0];
          }
          return this.wrapParenthesis(t, r);
        }
        wrapParenthesis(e, t) {
          if (!this.options.createParenthesizedExpressions) {
            this.addExtra(t, 'parenthesized', true);
            this.addExtra(t, 'parenStart', e.index);
            this.takeSurroundingComments(
              t,
              e.index,
              this.state.lastTokEndLoc.index,
            );
            return t;
          }
          const r = this.startNodeAt(e);
          r.expression = t;
          return this.finishNode(r, 'ParenthesizedExpression');
        }
        shouldParseArrow(e) {
          return !this.canInsertSemicolon();
        }
        parseArrow(e) {
          if (this.eat(19)) {
            return e;
          }
        }
        parseParenItem(e, t) {
          return e;
        }
        parseNewOrNewTarget() {
          const e = this.startNode();
          this.next();
          if (this.match(16)) {
            const t = this.createIdentifier(this.startNodeAtNode(e), 'new');
            this.next();
            const r = this.parseMetaProperty(e, t, 'target');
            if (
              !this.scope.inNonArrowFunction &&
              !this.scope.inClass &&
              !this.options.allowNewTargetOutsideFunction
            ) {
              this.raise(u.UnexpectedNewTarget, { at: r });
            }
            return r;
          }
          return this.parseNew(e);
        }
        parseNew(e) {
          this.parseNewCallee(e);
          if (this.eat(10)) {
            const t = this.parseExprList(11);
            this.toReferencedList(t);
            e.arguments = t;
          } else {
            e.arguments = [];
          }
          return this.finishNode(e, 'NewExpression');
        }
        parseNewCallee(e) {
          const t = this.match(83);
          const r = this.parseNoCallExpr();
          e.callee = r;
          if (t && (r.type === 'Import' || r.type === 'ImportExpression')) {
            this.raise(u.ImportCallNotNewExpression, { at: r });
          }
        }
        parseTemplateElement(e) {
          const { start: t, startLoc: r, end: s, value: i } = this.state;
          const n = t + 1;
          const a = this.startNodeAt(createPositionWithColumnOffset(r, 1));
          if (i === null) {
            if (!e) {
              this.raise(u.InvalidEscapeSequenceTemplate, {
                at: createPositionWithColumnOffset(
                  this.state.firstInvalidTemplateEscapePos,
                  1,
                ),
              });
            }
          }
          const o = this.match(24);
          const l = o ? -1 : -2;
          const c = s + l;
          a.value = {
            raw: this.input.slice(n, c).replace(/\r\n?/g, '\n'),
            cooked: i === null ? null : i.slice(1, l),
          };
          a.tail = o;
          this.next();
          const p = this.finishNode(a, 'TemplateElement');
          this.resetEndLocation(
            p,
            createPositionWithColumnOffset(this.state.lastTokEndLoc, l),
          );
          return p;
        }
        parseTemplate(e) {
          const t = this.startNode();
          t.expressions = [];
          let r = this.parseTemplateElement(e);
          t.quasis = [r];
          while (!r.tail) {
            t.expressions.push(this.parseTemplateSubstitution());
            this.readTemplateContinuation();
            t.quasis.push((r = this.parseTemplateElement(e)));
          }
          return this.finishNode(t, 'TemplateLiteral');
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(e, t, r, s) {
          if (r) {
            this.expectPlugin('recordAndTuple');
          }
          const i = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const n = Object.create(null);
          let a = true;
          const o = this.startNode();
          o.properties = [];
          this.next();
          while (!this.match(e)) {
            if (a) {
              a = false;
            } else {
              this.expect(12);
              if (this.match(e)) {
                this.addTrailingCommaExtraToNode(o);
                break;
              }
            }
            let i;
            if (t) {
              i = this.parseBindingProperty();
            } else {
              i = this.parsePropertyDefinition(s);
              this.checkProto(i, r, n, s);
            }
            if (r && !this.isObjectProperty(i) && i.type !== 'SpreadElement') {
              this.raise(u.InvalidRecordProperty, { at: i });
            }
            if (i.shorthand) {
              this.addExtra(i, 'shorthand', true);
            }
            o.properties.push(i);
          }
          this.next();
          this.state.inFSharpPipelineDirectBody = i;
          let l = 'ObjectExpression';
          if (t) {
            l = 'ObjectPattern';
          } else if (r) {
            l = 'RecordExpression';
          }
          return this.finishNode(o, l);
        }
        addTrailingCommaExtraToNode(e) {
          this.addExtra(e, 'trailingComma', this.state.lastTokStart);
          this.addExtra(
            e,
            'trailingCommaLoc',
            this.state.lastTokStartLoc,
            false,
          );
        }
        maybeAsyncOrAccessorProp(e) {
          return (
            !e.computed &&
            e.key.type === 'Identifier' &&
            (this.isLiteralPropertyName() || this.match(0) || this.match(55))
          );
        }
        parsePropertyDefinition(e) {
          let t = [];
          if (this.match(26)) {
            if (this.hasPlugin('decorators')) {
              this.raise(u.UnsupportedPropertyDecorator, {
                at: this.state.startLoc,
              });
            }
            while (this.match(26)) {
              t.push(this.parseDecorator());
            }
          }
          const r = this.startNode();
          let s = false;
          let i = false;
          let n;
          if (this.match(21)) {
            if (t.length) this.unexpected();
            return this.parseSpread();
          }
          if (t.length) {
            r.decorators = t;
            t = [];
          }
          r.method = false;
          if (e) {
            n = this.state.startLoc;
          }
          let a = this.eat(55);
          this.parsePropertyNamePrefixOperator(r);
          const o = this.state.containsEsc;
          const l = this.parsePropertyName(r, e);
          if (!a && !o && this.maybeAsyncOrAccessorProp(r)) {
            const e = l.name;
            if (e === 'async' && !this.hasPrecedingLineBreak()) {
              s = true;
              this.resetPreviousNodeTrailingComments(l);
              a = this.eat(55);
              this.parsePropertyName(r);
            }
            if (e === 'get' || e === 'set') {
              i = true;
              this.resetPreviousNodeTrailingComments(l);
              r.kind = e;
              if (this.match(55)) {
                a = true;
                this.raise(u.AccessorIsGenerator, {
                  at: this.state.curPosition(),
                  kind: e,
                });
                this.next();
              }
              this.parsePropertyName(r);
            }
          }
          return this.parseObjPropValue(r, n, a, s, false, i, e);
        }
        getGetterSetterExpectedParamCount(e) {
          return e.kind === 'get' ? 0 : 1;
        }
        getObjectOrClassMethodParams(e) {
          return e.params;
        }
        checkGetterSetterParams(e) {
          var t;
          const r = this.getGetterSetterExpectedParamCount(e);
          const s = this.getObjectOrClassMethodParams(e);
          if (s.length !== r) {
            this.raise(e.kind === 'get' ? u.BadGetterArity : u.BadSetterArity, {
              at: e,
            });
          }
          if (
            e.kind === 'set' &&
            ((t = s[s.length - 1]) == null ? void 0 : t.type) === 'RestElement'
          ) {
            this.raise(u.BadSetterRestParameter, { at: e });
          }
        }
        parseObjectMethod(e, t, r, s, i) {
          if (i) {
            const r = this.parseMethod(
              e,
              t,
              false,
              false,
              false,
              'ObjectMethod',
            );
            this.checkGetterSetterParams(r);
            return r;
          }
          if (r || t || this.match(10)) {
            if (s) this.unexpected();
            e.kind = 'method';
            e.method = true;
            return this.parseMethod(e, t, r, false, false, 'ObjectMethod');
          }
        }
        parseObjectProperty(e, t, r, s) {
          e.shorthand = false;
          if (this.eat(14)) {
            e.value = r
              ? this.parseMaybeDefault(this.state.startLoc)
              : this.parseMaybeAssignAllowIn(s);
            return this.finishNode(e, 'ObjectProperty');
          }
          if (!e.computed && e.key.type === 'Identifier') {
            this.checkReservedWord(e.key.name, e.key.loc.start, true, false);
            if (r) {
              e.value = this.parseMaybeDefault(t, cloneIdentifier(e.key));
            } else if (this.match(29)) {
              const r = this.state.startLoc;
              if (s != null) {
                if (s.shorthandAssignLoc === null) {
                  s.shorthandAssignLoc = r;
                }
              } else {
                this.raise(u.InvalidCoverInitializedName, { at: r });
              }
              e.value = this.parseMaybeDefault(t, cloneIdentifier(e.key));
            } else {
              e.value = cloneIdentifier(e.key);
            }
            e.shorthand = true;
            return this.finishNode(e, 'ObjectProperty');
          }
        }
        parseObjPropValue(e, t, r, s, i, n, a) {
          const o =
            this.parseObjectMethod(e, r, s, i, n) ||
            this.parseObjectProperty(e, t, i, a);
          if (!o) this.unexpected();
          return o;
        }
        parsePropertyName(e, t) {
          if (this.eat(0)) {
            e.computed = true;
            e.key = this.parseMaybeAssignAllowIn();
            this.expect(3);
          } else {
            const { type: r, value: s } = this.state;
            let i;
            if (tokenIsKeywordOrIdentifier(r)) {
              i = this.parseIdentifier(true);
            } else {
              switch (r) {
                case 134:
                  i = this.parseNumericLiteral(s);
                  break;
                case 133:
                  i = this.parseStringLiteral(s);
                  break;
                case 135:
                  i = this.parseBigIntLiteral(s);
                  break;
                case 136:
                  i = this.parseDecimalLiteral(s);
                  break;
                case 138: {
                  const e = this.state.startLoc;
                  if (t != null) {
                    if (t.privateKeyLoc === null) {
                      t.privateKeyLoc = e;
                    }
                  } else {
                    this.raise(u.UnexpectedPrivateField, { at: e });
                  }
                  i = this.parsePrivateName();
                  break;
                }
                default:
                  this.unexpected();
              }
            }
            e.key = i;
            if (r !== 138) {
              e.computed = false;
            }
          }
          return e.key;
        }
        initFunction(e, t) {
          e.id = null;
          e.generator = false;
          e.async = t;
        }
        parseMethod(e, t, r, s, i, n, a = false) {
          this.initFunction(e, r);
          e.generator = t;
          this.scope.enter(2 | 16 | (a ? 64 : 0) | (i ? 32 : 0));
          this.prodParam.enter(functionFlags(r, e.generator));
          this.parseFunctionParams(e, s);
          const o = this.parseFunctionBodyAndFinish(e, n, true);
          this.prodParam.exit();
          this.scope.exit();
          return o;
        }
        parseArrayLike(e, t, r, s) {
          if (r) {
            this.expectPlugin('recordAndTuple');
          }
          const i = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const n = this.startNode();
          this.next();
          n.elements = this.parseExprList(e, !r, s, n);
          this.state.inFSharpPipelineDirectBody = i;
          return this.finishNode(n, r ? 'TupleExpression' : 'ArrayExpression');
        }
        parseArrowExpression(e, t, r, s) {
          this.scope.enter(2 | 4);
          let i = functionFlags(r, false);
          if (!this.match(5) && this.prodParam.hasIn) {
            i |= 8;
          }
          this.prodParam.enter(i);
          this.initFunction(e, r);
          const n = this.state.maybeInArrowParameters;
          if (t) {
            this.state.maybeInArrowParameters = true;
            this.setArrowFunctionParameters(e, t, s);
          }
          this.state.maybeInArrowParameters = false;
          this.parseFunctionBody(e, true);
          this.prodParam.exit();
          this.scope.exit();
          this.state.maybeInArrowParameters = n;
          return this.finishNode(e, 'ArrowFunctionExpression');
        }
        setArrowFunctionParameters(e, t, r) {
          this.toAssignableList(t, r, false);
          e.params = t;
        }
        parseFunctionBodyAndFinish(e, t, r = false) {
          this.parseFunctionBody(e, false, r);
          return this.finishNode(e, t);
        }
        parseFunctionBody(e, t, r = false) {
          const s = t && !this.match(5);
          this.expressionScope.enter(newExpressionScope());
          if (s) {
            e.body = this.parseMaybeAssign();
            this.checkParams(e, false, t, false);
          } else {
            const s = this.state.strict;
            const i = this.state.labels;
            this.state.labels = [];
            this.prodParam.enter(this.prodParam.currentFlags() | 4);
            e.body = this.parseBlock(true, false, (i) => {
              const n = !this.isSimpleParamList(e.params);
              if (i && n) {
                this.raise(u.IllegalLanguageModeDirective, {
                  at:
                    (e.kind === 'method' || e.kind === 'constructor') && !!e.key
                      ? e.key.loc.end
                      : e,
                });
              }
              const a = !s && this.state.strict;
              this.checkParams(e, !this.state.strict && !t && !r && !n, t, a);
              if (this.state.strict && e.id) {
                this.checkIdentifier(e.id, 65, a);
              }
            });
            this.prodParam.exit();
            this.state.labels = i;
          }
          this.expressionScope.exit();
        }
        isSimpleParameter(e) {
          return e.type === 'Identifier';
        }
        isSimpleParamList(e) {
          for (let t = 0, r = e.length; t < r; t++) {
            if (!this.isSimpleParameter(e[t])) return false;
          }
          return true;
        }
        checkParams(e, t, r, s = true) {
          const i = !t && new Set();
          const n = { type: 'FormalParameters' };
          for (const t of e.params) {
            this.checkLVal(t, {
              in: n,
              binding: 5,
              checkClashes: i,
              strictModeChanged: s,
            });
          }
        }
        parseExprList(e, t, r, s) {
          const i = [];
          let n = true;
          while (!this.eat(e)) {
            if (n) {
              n = false;
            } else {
              this.expect(12);
              if (this.match(e)) {
                if (s) {
                  this.addTrailingCommaExtraToNode(s);
                }
                this.next();
                break;
              }
            }
            i.push(this.parseExprListItem(t, r));
          }
          return i;
        }
        parseExprListItem(e, t, r) {
          let s;
          if (this.match(12)) {
            if (!e) {
              this.raise(u.UnexpectedToken, {
                at: this.state.curPosition(),
                unexpected: ',',
              });
            }
            s = null;
          } else if (this.match(21)) {
            const e = this.state.startLoc;
            s = this.parseParenItem(this.parseSpread(t), e);
          } else if (this.match(17)) {
            this.expectPlugin('partialApplication');
            if (!r) {
              this.raise(u.UnexpectedArgumentPlaceholder, {
                at: this.state.startLoc,
              });
            }
            const e = this.startNode();
            this.next();
            s = this.finishNode(e, 'ArgumentPlaceholder');
          } else {
            s = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
          }
          return s;
        }
        parseIdentifier(e) {
          const t = this.startNode();
          const r = this.parseIdentifierName(e);
          return this.createIdentifier(t, r);
        }
        createIdentifier(e, t) {
          e.name = t;
          e.loc.identifierName = t;
          return this.finishNode(e, 'Identifier');
        }
        parseIdentifierName(e) {
          let t;
          const { startLoc: r, type: s } = this.state;
          if (tokenIsKeywordOrIdentifier(s)) {
            t = this.state.value;
          } else {
            this.unexpected();
          }
          const i = tokenKeywordOrIdentifierIsKeyword(s);
          if (e) {
            if (i) {
              this.replaceToken(132);
            }
          } else {
            this.checkReservedWord(t, r, i, false);
          }
          this.next();
          return t;
        }
        checkReservedWord(e, t, r, s) {
          if (e.length > 10) {
            return;
          }
          if (!canBeReservedWord(e)) {
            return;
          }
          if (r && isKeyword(e)) {
            this.raise(u.UnexpectedKeyword, { at: t, keyword: e });
            return;
          }
          const i = !this.state.strict
            ? isReservedWord
            : s
            ? isStrictBindReservedWord
            : isStrictReservedWord;
          if (i(e, this.inModule)) {
            this.raise(u.UnexpectedReservedWord, { at: t, reservedWord: e });
            return;
          } else if (e === 'yield') {
            if (this.prodParam.hasYield) {
              this.raise(u.YieldBindingIdentifier, { at: t });
              return;
            }
          } else if (e === 'await') {
            if (this.prodParam.hasAwait) {
              this.raise(u.AwaitBindingIdentifier, { at: t });
              return;
            }
            if (this.scope.inStaticBlock) {
              this.raise(u.AwaitBindingIdentifierInStaticBlock, { at: t });
              return;
            }
            this.expressionScope.recordAsyncArrowParametersError({ at: t });
          } else if (e === 'arguments') {
            if (this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(u.ArgumentsInClass, { at: t });
              return;
            }
          }
        }
        isAwaitAllowed() {
          if (this.prodParam.hasAwait) return true;
          if (
            this.options.allowAwaitOutsideFunction &&
            !this.scope.inFunction
          ) {
            return true;
          }
          return false;
        }
        parseAwait(e) {
          const t = this.startNodeAt(e);
          this.expressionScope.recordParameterInitializerError(
            u.AwaitExpressionFormalParameter,
            { at: t },
          );
          if (this.eat(55)) {
            this.raise(u.ObsoleteAwaitStar, { at: t });
          }
          if (
            !this.scope.inFunction &&
            !this.options.allowAwaitOutsideFunction
          ) {
            if (this.isAmbiguousAwait()) {
              this.ambiguousScriptDifferentAst = true;
            } else {
              this.sawUnambiguousESM = true;
            }
          }
          if (!this.state.soloAwait) {
            t.argument = this.parseMaybeUnary(null, true);
          }
          return this.finishNode(t, 'AwaitExpression');
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak()) return true;
          const { type: e } = this.state;
          return (
            e === 53 ||
            e === 10 ||
            e === 0 ||
            tokenIsTemplate(e) ||
            (e === 102 && !this.state.containsEsc) ||
            e === 137 ||
            e === 56 ||
            (this.hasPlugin('v8intrinsic') && e === 54)
          );
        }
        parseYield() {
          const e = this.startNode();
          this.expressionScope.recordParameterInitializerError(
            u.YieldInParameter,
            { at: e },
          );
          this.next();
          let t = false;
          let r = null;
          if (!this.hasPrecedingLineBreak()) {
            t = this.eat(55);
            switch (this.state.type) {
              case 13:
              case 139:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!t) break;
              default:
                r = this.parseMaybeAssign();
            }
          }
          e.delegate = t;
          e.argument = r;
          return this.finishNode(e, 'YieldExpression');
        }
        parseImportCall(e) {
          this.next();
          e.source = this.parseMaybeAssignAllowIn();
          if (
            this.hasPlugin('importAttributes') ||
            this.hasPlugin('importAssertions')
          ) {
            e.options = null;
          }
          if (this.eat(12)) {
            this.expectImportAttributesPlugin();
            if (!this.match(11)) {
              e.options = this.parseMaybeAssignAllowIn();
              this.eat(12);
            }
          }
          this.expect(11);
          return this.finishNode(e, 'ImportExpression');
        }
        checkPipelineAtInfixOperator(e, t) {
          if (this.hasPlugin(['pipelineOperator', { proposal: 'smart' }])) {
            if (e.type === 'SequenceExpression') {
              this.raise(u.PipelineHeadSequenceExpression, { at: t });
            }
          }
        }
        parseSmartPipelineBodyInStyle(e, t) {
          if (this.isSimpleReference(e)) {
            const r = this.startNodeAt(t);
            r.callee = e;
            return this.finishNode(r, 'PipelineBareFunction');
          } else {
            const r = this.startNodeAt(t);
            this.checkSmartPipeTopicBodyEarlyErrors(t);
            r.expression = e;
            return this.finishNode(r, 'PipelineTopicExpression');
          }
        }
        isSimpleReference(e) {
          switch (e.type) {
            case 'MemberExpression':
              return !e.computed && this.isSimpleReference(e.object);
            case 'Identifier':
              return true;
            default:
              return false;
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(e) {
          if (this.match(19)) {
            throw this.raise(u.PipelineBodyNoArrow, {
              at: this.state.startLoc,
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(u.PipelineTopicUnused, { at: e });
          }
        }
        withTopicBindingContext(e) {
          const t = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null,
          };
          try {
            return e();
          } finally {
            this.state.topicContext = t;
          }
        }
        withSmartMixTopicForbiddingContext(e) {
          if (this.hasPlugin(['pipelineOperator', { proposal: 'smart' }])) {
            const t = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null,
            };
            try {
              return e();
            } finally {
              this.state.topicContext = t;
            }
          } else {
            return e();
          }
        }
        withSoloAwaitPermittingContext(e) {
          const t = this.state.soloAwait;
          this.state.soloAwait = true;
          try {
            return e();
          } finally {
            this.state.soloAwait = t;
          }
        }
        allowInAnd(e) {
          const t = this.prodParam.currentFlags();
          const r = 8 & ~t;
          if (r) {
            this.prodParam.enter(t | 8);
            try {
              return e();
            } finally {
              this.prodParam.exit();
            }
          }
          return e();
        }
        disallowInAnd(e) {
          const t = this.prodParam.currentFlags();
          const r = 8 & t;
          if (r) {
            this.prodParam.enter(t & ~8);
            try {
              return e();
            } finally {
              this.prodParam.exit();
            }
          }
          return e();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
          return (
            this.state.topicContext.maxTopicIndex != null &&
            this.state.topicContext.maxTopicIndex >= 0
          );
        }
        parseFSharpPipelineBody(e) {
          const t = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          const r = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = true;
          const s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e);
          this.state.inFSharpPipelineDirectBody = r;
          return s;
        }
        parseModuleExpression() {
          this.expectPlugin('moduleBlocks');
          const e = this.startNode();
          this.next();
          if (!this.match(5)) {
            this.unexpected(null, 5);
          }
          const t = this.startNodeAt(this.state.endLoc);
          this.next();
          const r = this.initializeScopes(true);
          this.enterInitialScopes();
          try {
            e.body = this.parseProgram(t, 8, 'module');
          } finally {
            r();
          }
          return this.finishNode(e, 'ModuleExpression');
        }
        parsePropertyNamePrefixOperator(e) {}
      }
      const de = { kind: 'loop' },
        fe = { kind: 'switch' };
      const he = /[\uD800-\uDFFF]/u;
      const ye = /in(?:stanceof)?/y;
      function babel7CompatTokens(e, t) {
        for (let r = 0; r < e.length; r++) {
          const s = e[r];
          const { type: i } = s;
          if (typeof i === 'number') {
            {
              if (i === 138) {
                const { loc: t, start: i, value: n, end: a } = s;
                const o = i + 1;
                const l = createPositionWithColumnOffset(t.start, 1);
                e.splice(
                  r,
                  1,
                  new Token({
                    type: getExportedToken(27),
                    value: '#',
                    start: i,
                    end: o,
                    startLoc: t.start,
                    endLoc: l,
                  }),
                  new Token({
                    type: getExportedToken(132),
                    value: n,
                    start: o,
                    end: a,
                    startLoc: l,
                    endLoc: t.end,
                  }),
                );
                r++;
                continue;
              }
              if (tokenIsTemplate(i)) {
                const { loc: n, start: a, value: o, end: l } = s;
                const c = a + 1;
                const p = createPositionWithColumnOffset(n.start, 1);
                let u;
                if (t.charCodeAt(a) === 96) {
                  u = new Token({
                    type: getExportedToken(22),
                    value: '`',
                    start: a,
                    end: c,
                    startLoc: n.start,
                    endLoc: p,
                  });
                } else {
                  u = new Token({
                    type: getExportedToken(8),
                    value: '}',
                    start: a,
                    end: c,
                    startLoc: n.start,
                    endLoc: p,
                  });
                }
                let d, f, h, y;
                if (i === 24) {
                  f = l - 1;
                  h = createPositionWithColumnOffset(n.end, -1);
                  d = o === null ? null : o.slice(1, -1);
                  y = new Token({
                    type: getExportedToken(22),
                    value: '`',
                    start: f,
                    end: l,
                    startLoc: h,
                    endLoc: n.end,
                  });
                } else {
                  f = l - 2;
                  h = createPositionWithColumnOffset(n.end, -2);
                  d = o === null ? null : o.slice(1, -2);
                  y = new Token({
                    type: getExportedToken(23),
                    value: '${',
                    start: f,
                    end: l,
                    startLoc: h,
                    endLoc: n.end,
                  });
                }
                e.splice(
                  r,
                  1,
                  u,
                  new Token({
                    type: getExportedToken(20),
                    value: d,
                    start: c,
                    end: f,
                    startLoc: p,
                    endLoc: h,
                  }),
                  y,
                );
                r += 2;
                continue;
              }
            }
            s.type = getExportedToken(i);
          }
        }
        return e;
      }
      class StatementParser extends ExpressionParser {
        parseTopLevel(e, t) {
          e.program = this.parseProgram(t);
          e.comments = this.state.comments;
          if (this.options.tokens) {
            e.tokens = babel7CompatTokens(this.tokens, this.input);
          }
          return this.finishNode(e, 'File');
        }
        parseProgram(e, t = 139, r = this.options.sourceType) {
          e.sourceType = r;
          e.interpreter = this.parseInterpreterDirective();
          this.parseBlockBody(e, true, true, t);
          if (
            this.inModule &&
            !this.options.allowUndeclaredExports &&
            this.scope.undefinedExports.size > 0
          ) {
            for (const [e, t] of Array.from(this.scope.undefinedExports)) {
              this.raise(u.ModuleExportUndefined, { at: t, localName: e });
            }
          }
          let s;
          if (t === 139) {
            s = this.finishNode(e, 'Program');
          } else {
            s = this.finishNodeAt(
              e,
              'Program',
              createPositionWithColumnOffset(this.state.startLoc, -1),
            );
          }
          return s;
        }
        stmtToDirective(e) {
          const t = e;
          t.type = 'Directive';
          t.value = t.expression;
          delete t.expression;
          const r = t.value;
          const s = r.value;
          const i = this.input.slice(r.start, r.end);
          const n = (r.value = i.slice(1, -1));
          this.addExtra(r, 'raw', i);
          this.addExtra(r, 'rawValue', n);
          this.addExtra(r, 'expressionValue', s);
          r.type = 'DirectiveLiteral';
          return t;
        }
        parseInterpreterDirective() {
          if (!this.match(28)) {
            return null;
          }
          const e = this.startNode();
          e.value = this.state.value;
          this.next();
          return this.finishNode(e, 'InterpreterDirective');
        }
        isLet() {
          if (!this.isContextual(100)) {
            return false;
          }
          return this.hasFollowingBindingAtom();
        }
        chStartsBindingIdentifier(e, t) {
          if (isIdentifierStart(e)) {
            ye.lastIndex = t;
            if (ye.test(this.input)) {
              const e = this.codePointAtPos(ye.lastIndex);
              if (!isIdentifierChar(e) && e !== 92) {
                return false;
              }
            }
            return true;
          } else if (e === 92) {
            return true;
          } else {
            return false;
          }
        }
        chStartsBindingPattern(e) {
          return e === 91 || e === 123;
        }
        hasFollowingBindingAtom() {
          const e = this.nextTokenStart();
          const t = this.codePointAtPos(e);
          return (
            this.chStartsBindingPattern(t) ||
            this.chStartsBindingIdentifier(t, e)
          );
        }
        hasInLineFollowingBindingIdentifier() {
          const e = this.nextTokenInLineStart();
          const t = this.codePointAtPos(e);
          return this.chStartsBindingIdentifier(t, e);
        }
        startsUsingForOf() {
          const { type: e, containsEsc: t } = this.lookahead();
          if (e === 102 && !t) {
            return false;
          } else if (tokenIsIdentifier(e) && !this.hasFollowingLineBreak()) {
            this.expectPlugin('explicitResourceManagement');
            return true;
          }
        }
        startsAwaitUsing() {
          let e = this.nextTokenInLineStart();
          if (this.isUnparsedContextual(e, 'using')) {
            e = this.nextTokenInLineStartSince(e + 5);
            const t = this.codePointAtPos(e);
            if (this.chStartsBindingIdentifier(t, e)) {
              this.expectPlugin('explicitResourceManagement');
              return true;
            }
          }
          return false;
        }
        parseModuleItem() {
          return this.parseStatementLike(1 | 2 | 4 | 8);
        }
        parseStatementListItem() {
          return this.parseStatementLike(
            2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8),
          );
        }
        parseStatementOrSloppyAnnexBFunctionDeclaration(e = false) {
          let t = 0;
          if (this.options.annexB && !this.state.strict) {
            t |= 4;
            if (e) {
              t |= 8;
            }
          }
          return this.parseStatementLike(t);
        }
        parseStatement() {
          return this.parseStatementLike(0);
        }
        parseStatementLike(e) {
          let t = null;
          if (this.match(26)) {
            t = this.parseDecorators(true);
          }
          return this.parseStatementContent(e, t);
        }
        parseStatementContent(e, t) {
          const r = this.state.type;
          const s = this.startNode();
          const i = !!(e & 2);
          const n = !!(e & 4);
          const a = e & 1;
          switch (r) {
            case 60:
              return this.parseBreakContinueStatement(s, true);
            case 63:
              return this.parseBreakContinueStatement(s, false);
            case 64:
              return this.parseDebuggerStatement(s);
            case 90:
              return this.parseDoWhileStatement(s);
            case 91:
              return this.parseForStatement(s);
            case 68:
              if (this.lookaheadCharCode() === 46) break;
              if (!n) {
                this.raise(
                  this.state.strict
                    ? u.StrictFunction
                    : this.options.annexB
                    ? u.SloppyFunctionAnnexB
                    : u.SloppyFunction,
                  { at: this.state.startLoc },
                );
              }
              return this.parseFunctionStatement(s, false, !i && n);
            case 80:
              if (!i) this.unexpected();
              return this.parseClass(this.maybeTakeDecorators(t, s), true);
            case 69:
              return this.parseIfStatement(s);
            case 70:
              return this.parseReturnStatement(s);
            case 71:
              return this.parseSwitchStatement(s);
            case 72:
              return this.parseThrowStatement(s);
            case 73:
              return this.parseTryStatement(s);
            case 96:
              if (!this.state.containsEsc && this.startsAwaitUsing()) {
                if (!this.isAwaitAllowed()) {
                  this.raise(u.AwaitUsingNotInAsyncContext, { at: s });
                } else if (!i) {
                  this.raise(u.UnexpectedLexicalDeclaration, { at: s });
                }
                this.next();
                return this.parseVarStatement(s, 'await using');
              }
              break;
            case 107:
              if (
                this.state.containsEsc ||
                !this.hasInLineFollowingBindingIdentifier()
              ) {
                break;
              }
              this.expectPlugin('explicitResourceManagement');
              if (!this.scope.inModule && this.scope.inTopLevel) {
                this.raise(u.UnexpectedUsingDeclaration, {
                  at: this.state.startLoc,
                });
              } else if (!i) {
                this.raise(u.UnexpectedLexicalDeclaration, {
                  at: this.state.startLoc,
                });
              }
              return this.parseVarStatement(s, 'using');
            case 100: {
              if (this.state.containsEsc) {
                break;
              }
              const e = this.nextTokenStart();
              const t = this.codePointAtPos(e);
              if (t !== 91) {
                if (!i && this.hasFollowingLineBreak()) break;
                if (!this.chStartsBindingIdentifier(t, e) && t !== 123) {
                  break;
                }
              }
            }
            case 75: {
              if (!i) {
                this.raise(u.UnexpectedLexicalDeclaration, {
                  at: this.state.startLoc,
                });
              }
            }
            case 74: {
              const e = this.state.value;
              return this.parseVarStatement(s, e);
            }
            case 92:
              return this.parseWhileStatement(s);
            case 76:
              return this.parseWithStatement(s);
            case 5:
              return this.parseBlock();
            case 13:
              return this.parseEmptyStatement(s);
            case 83: {
              const e = this.lookaheadCharCode();
              if (e === 40 || e === 46) {
                break;
              }
            }
            case 82: {
              if (!this.options.allowImportExportEverywhere && !a) {
                this.raise(u.UnexpectedImportExport, {
                  at: this.state.startLoc,
                });
              }
              this.next();
              let e;
              if (r === 83) {
                e = this.parseImport(s);
                if (
                  e.type === 'ImportDeclaration' &&
                  (!e.importKind || e.importKind === 'value')
                ) {
                  this.sawUnambiguousESM = true;
                }
              } else {
                e = this.parseExport(s, t);
                if (
                  (e.type === 'ExportNamedDeclaration' &&
                    (!e.exportKind || e.exportKind === 'value')) ||
                  (e.type === 'ExportAllDeclaration' &&
                    (!e.exportKind || e.exportKind === 'value')) ||
                  e.type === 'ExportDefaultDeclaration'
                ) {
                  this.sawUnambiguousESM = true;
                }
              }
              this.assertModuleNodeAllowed(e);
              return e;
            }
            default: {
              if (this.isAsyncFunction()) {
                if (!i) {
                  this.raise(u.AsyncFunctionInSingleStatementContext, {
                    at: this.state.startLoc,
                  });
                }
                this.next();
                return this.parseFunctionStatement(s, true, !i && n);
              }
            }
          }
          const o = this.state.value;
          const l = this.parseExpression();
          if (tokenIsIdentifier(r) && l.type === 'Identifier' && this.eat(14)) {
            return this.parseLabeledStatement(s, o, l, e);
          } else {
            return this.parseExpressionStatement(s, l, t);
          }
        }
        assertModuleNodeAllowed(e) {
          if (!this.options.allowImportExportEverywhere && !this.inModule) {
            this.raise(u.ImportOutsideModule, { at: e });
          }
        }
        decoratorsEnabledBeforeExport() {
          if (this.hasPlugin('decorators-legacy')) return true;
          return (
            this.hasPlugin('decorators') &&
            this.getPluginOption('decorators', 'decoratorsBeforeExport') !==
              false
          );
        }
        maybeTakeDecorators(e, t, r) {
          if (e) {
            if (t.decorators && t.decorators.length > 0) {
              if (
                typeof this.getPluginOption(
                  'decorators',
                  'decoratorsBeforeExport',
                ) !== 'boolean'
              ) {
                this.raise(u.DecoratorsBeforeAfterExport, {
                  at: t.decorators[0],
                });
              }
              t.decorators.unshift(...e);
            } else {
              t.decorators = e;
            }
            this.resetStartLocationFromNode(t, e[0]);
            if (r) this.resetStartLocationFromNode(r, t);
          }
          return t;
        }
        canHaveLeadingDecorator() {
          return this.match(80);
        }
        parseDecorators(e) {
          const t = [];
          do {
            t.push(this.parseDecorator());
          } while (this.match(26));
          if (this.match(82)) {
            if (!e) {
              this.unexpected();
            }
            if (!this.decoratorsEnabledBeforeExport()) {
              this.raise(u.DecoratorExportClass, { at: this.state.startLoc });
            }
          } else if (!this.canHaveLeadingDecorator()) {
            throw this.raise(u.UnexpectedLeadingDecorator, {
              at: this.state.startLoc,
            });
          }
          return t;
        }
        parseDecorator() {
          this.expectOnePlugin(['decorators', 'decorators-legacy']);
          const e = this.startNode();
          this.next();
          if (this.hasPlugin('decorators')) {
            const t = this.state.startLoc;
            let r;
            if (this.match(10)) {
              const t = this.state.startLoc;
              this.next();
              r = this.parseExpression();
              this.expect(11);
              r = this.wrapParenthesis(t, r);
              const s = this.state.startLoc;
              e.expression = this.parseMaybeDecoratorArguments(r);
              if (
                this.getPluginOption('decorators', 'allowCallParenthesized') ===
                  false &&
                e.expression !== r
              ) {
                this.raise(u.DecoratorArgumentsOutsideParentheses, { at: s });
              }
            } else {
              r = this.parseIdentifier(false);
              while (this.eat(16)) {
                const e = this.startNodeAt(t);
                e.object = r;
                if (this.match(138)) {
                  this.classScope.usePrivateName(
                    this.state.value,
                    this.state.startLoc,
                  );
                  e.property = this.parsePrivateName();
                } else {
                  e.property = this.parseIdentifier(true);
                }
                e.computed = false;
                r = this.finishNode(e, 'MemberExpression');
              }
              e.expression = this.parseMaybeDecoratorArguments(r);
            }
          } else {
            e.expression = this.parseExprSubscripts();
          }
          return this.finishNode(e, 'Decorator');
        }
        parseMaybeDecoratorArguments(e) {
          if (this.eat(10)) {
            const t = this.startNodeAtNode(e);
            t.callee = e;
            t.arguments = this.parseCallExpressionArguments(11, false);
            this.toReferencedList(t.arguments);
            return this.finishNode(t, 'CallExpression');
          }
          return e;
        }
        parseBreakContinueStatement(e, t) {
          this.next();
          if (this.isLineTerminator()) {
            e.label = null;
          } else {
            e.label = this.parseIdentifier();
            this.semicolon();
          }
          this.verifyBreakContinue(e, t);
          return this.finishNode(e, t ? 'BreakStatement' : 'ContinueStatement');
        }
        verifyBreakContinue(e, t) {
          let r;
          for (r = 0; r < this.state.labels.length; ++r) {
            const s = this.state.labels[r];
            if (e.label == null || s.name === e.label.name) {
              if (s.kind != null && (t || s.kind === 'loop')) break;
              if (e.label && t) break;
            }
          }
          if (r === this.state.labels.length) {
            const r = t ? 'BreakStatement' : 'ContinueStatement';
            this.raise(u.IllegalBreakContinue, { at: e, type: r });
          }
        }
        parseDebuggerStatement(e) {
          this.next();
          this.semicolon();
          return this.finishNode(e, 'DebuggerStatement');
        }
        parseHeaderExpression() {
          this.expect(10);
          const e = this.parseExpression();
          this.expect(11);
          return e;
        }
        parseDoWhileStatement(e) {
          this.next();
          this.state.labels.push(de);
          e.body = this.withSmartMixTopicForbiddingContext(() =>
            this.parseStatement(),
          );
          this.state.labels.pop();
          this.expect(92);
          e.test = this.parseHeaderExpression();
          this.eat(13);
          return this.finishNode(e, 'DoWhileStatement');
        }
        parseForStatement(e) {
          this.next();
          this.state.labels.push(de);
          let t = null;
          if (this.isAwaitAllowed() && this.eatContextual(96)) {
            t = this.state.lastTokStartLoc;
          }
          this.scope.enter(0);
          this.expect(10);
          if (this.match(13)) {
            if (t !== null) {
              this.unexpected(t);
            }
            return this.parseFor(e, null);
          }
          const r = this.isContextual(100);
          {
            const s = this.isContextual(96) && this.startsAwaitUsing();
            const i = s || (this.isContextual(107) && this.startsUsingForOf());
            const n = (r && this.hasFollowingBindingAtom()) || i;
            if (this.match(74) || this.match(75) || n) {
              const r = this.startNode();
              let n;
              if (s) {
                n = 'await using';
                if (!this.isAwaitAllowed()) {
                  this.raise(u.AwaitUsingNotInAsyncContext, {
                    at: this.state.startLoc,
                  });
                }
                this.next();
              } else {
                n = this.state.value;
              }
              this.next();
              this.parseVar(r, true, n);
              const a = this.finishNode(r, 'VariableDeclaration');
              const o = this.match(58);
              if (o && i) {
                this.raise(u.ForInUsing, { at: a });
              }
              if (
                (o || this.isContextual(102)) &&
                a.declarations.length === 1
              ) {
                return this.parseForIn(e, a, t);
              }
              if (t !== null) {
                this.unexpected(t);
              }
              return this.parseFor(e, a);
            }
          }
          const s = this.isContextual(95);
          const i = new ExpressionErrors();
          const n = this.parseExpression(true, i);
          const a = this.isContextual(102);
          if (a) {
            if (r) {
              this.raise(u.ForOfLet, { at: n });
            }
            if (t === null && s && n.type === 'Identifier') {
              this.raise(u.ForOfAsync, { at: n });
            }
          }
          if (a || this.match(58)) {
            this.checkDestructuringPrivate(i);
            this.toAssignable(n, true);
            const r = a ? 'ForOfStatement' : 'ForInStatement';
            this.checkLVal(n, { in: { type: r } });
            return this.parseForIn(e, n, t);
          } else {
            this.checkExpressionErrors(i, true);
          }
          if (t !== null) {
            this.unexpected(t);
          }
          return this.parseFor(e, n);
        }
        parseFunctionStatement(e, t, r) {
          this.next();
          return this.parseFunction(e, 1 | (r ? 2 : 0) | (t ? 8 : 0));
        }
        parseIfStatement(e) {
          this.next();
          e.test = this.parseHeaderExpression();
          e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
          e.alternate = this.eat(66)
            ? this.parseStatementOrSloppyAnnexBFunctionDeclaration()
            : null;
          return this.finishNode(e, 'IfStatement');
        }
        parseReturnStatement(e) {
          if (
            !this.prodParam.hasReturn &&
            !this.options.allowReturnOutsideFunction
          ) {
            this.raise(u.IllegalReturn, { at: this.state.startLoc });
          }
          this.next();
          if (this.isLineTerminator()) {
            e.argument = null;
          } else {
            e.argument = this.parseExpression();
            this.semicolon();
          }
          return this.finishNode(e, 'ReturnStatement');
        }
        parseSwitchStatement(e) {
          this.next();
          e.discriminant = this.parseHeaderExpression();
          const t = (e.cases = []);
          this.expect(5);
          this.state.labels.push(fe);
          this.scope.enter(0);
          let r;
          for (let e; !this.match(8); ) {
            if (this.match(61) || this.match(65)) {
              const s = this.match(61);
              if (r) this.finishNode(r, 'SwitchCase');
              t.push((r = this.startNode()));
              r.consequent = [];
              this.next();
              if (s) {
                r.test = this.parseExpression();
              } else {
                if (e) {
                  this.raise(u.MultipleDefaultsInSwitch, {
                    at: this.state.lastTokStartLoc,
                  });
                }
                e = true;
                r.test = null;
              }
              this.expect(14);
            } else {
              if (r) {
                r.consequent.push(this.parseStatementListItem());
              } else {
                this.unexpected();
              }
            }
          }
          this.scope.exit();
          if (r) this.finishNode(r, 'SwitchCase');
          this.next();
          this.state.labels.pop();
          return this.finishNode(e, 'SwitchStatement');
        }
        parseThrowStatement(e) {
          this.next();
          if (this.hasPrecedingLineBreak()) {
            this.raise(u.NewlineAfterThrow, { at: this.state.lastTokEndLoc });
          }
          e.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(e, 'ThrowStatement');
        }
        parseCatchClauseParam() {
          const e = this.parseBindingAtom();
          this.scope.enter(
            this.options.annexB && e.type === 'Identifier' ? 8 : 0,
          );
          this.checkLVal(e, { in: { type: 'CatchClause' }, binding: 9 });
          return e;
        }
        parseTryStatement(e) {
          this.next();
          e.block = this.parseBlock();
          e.handler = null;
          if (this.match(62)) {
            const t = this.startNode();
            this.next();
            if (this.match(10)) {
              this.expect(10);
              t.param = this.parseCatchClauseParam();
              this.expect(11);
            } else {
              t.param = null;
              this.scope.enter(0);
            }
            t.body = this.withSmartMixTopicForbiddingContext(() =>
              this.parseBlock(false, false),
            );
            this.scope.exit();
            e.handler = this.finishNode(t, 'CatchClause');
          }
          e.finalizer = this.eat(67) ? this.parseBlock() : null;
          if (!e.handler && !e.finalizer) {
            this.raise(u.NoCatchOrFinally, { at: e });
          }
          return this.finishNode(e, 'TryStatement');
        }
        parseVarStatement(e, t, r = false) {
          this.next();
          this.parseVar(e, false, t, r);
          this.semicolon();
          return this.finishNode(e, 'VariableDeclaration');
        }
        parseWhileStatement(e) {
          this.next();
          e.test = this.parseHeaderExpression();
          this.state.labels.push(de);
          e.body = this.withSmartMixTopicForbiddingContext(() =>
            this.parseStatement(),
          );
          this.state.labels.pop();
          return this.finishNode(e, 'WhileStatement');
        }
        parseWithStatement(e) {
          if (this.state.strict) {
            this.raise(u.StrictWith, { at: this.state.startLoc });
          }
          this.next();
          e.object = this.parseHeaderExpression();
          e.body = this.withSmartMixTopicForbiddingContext(() =>
            this.parseStatement(),
          );
          return this.finishNode(e, 'WithStatement');
        }
        parseEmptyStatement(e) {
          this.next();
          return this.finishNode(e, 'EmptyStatement');
        }
        parseLabeledStatement(e, t, r, s) {
          for (const e of this.state.labels) {
            if (e.name === t) {
              this.raise(u.LabelRedeclaration, { at: r, labelName: t });
            }
          }
          const i = tokenIsLoop(this.state.type)
            ? 'loop'
            : this.match(71)
            ? 'switch'
            : null;
          for (let t = this.state.labels.length - 1; t >= 0; t--) {
            const r = this.state.labels[t];
            if (r.statementStart === e.start) {
              r.statementStart = this.state.start;
              r.kind = i;
            } else {
              break;
            }
          }
          this.state.labels.push({
            name: t,
            kind: i,
            statementStart: this.state.start,
          });
          e.body =
            s & 8
              ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true)
              : this.parseStatement();
          this.state.labels.pop();
          e.label = r;
          return this.finishNode(e, 'LabeledStatement');
        }
        parseExpressionStatement(e, t, r) {
          e.expression = t;
          this.semicolon();
          return this.finishNode(e, 'ExpressionStatement');
        }
        parseBlock(e = false, t = true, r) {
          const s = this.startNode();
          if (e) {
            this.state.strictErrors.clear();
          }
          this.expect(5);
          if (t) {
            this.scope.enter(0);
          }
          this.parseBlockBody(s, e, false, 8, r);
          if (t) {
            this.scope.exit();
          }
          return this.finishNode(s, 'BlockStatement');
        }
        isValidDirective(e) {
          return (
            e.type === 'ExpressionStatement' &&
            e.expression.type === 'StringLiteral' &&
            !e.expression.extra.parenthesized
          );
        }
        parseBlockBody(e, t, r, s, i) {
          const n = (e.body = []);
          const a = (e.directives = []);
          this.parseBlockOrModuleBlockBody(n, t ? a : undefined, r, s, i);
        }
        parseBlockOrModuleBlockBody(e, t, r, s, i) {
          const n = this.state.strict;
          let a = false;
          let o = false;
          while (!this.match(s)) {
            const s = r
              ? this.parseModuleItem()
              : this.parseStatementListItem();
            if (t && !o) {
              if (this.isValidDirective(s)) {
                const e = this.stmtToDirective(s);
                t.push(e);
                if (!a && e.value.value === 'use strict') {
                  a = true;
                  this.setStrict(true);
                }
                continue;
              }
              o = true;
              this.state.strictErrors.clear();
            }
            e.push(s);
          }
          i == null || i.call(this, a);
          if (!n) {
            this.setStrict(false);
          }
          this.next();
        }
        parseFor(e, t) {
          e.init = t;
          this.semicolon(false);
          e.test = this.match(13) ? null : this.parseExpression();
          this.semicolon(false);
          e.update = this.match(11) ? null : this.parseExpression();
          this.expect(11);
          e.body = this.withSmartMixTopicForbiddingContext(() =>
            this.parseStatement(),
          );
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(e, 'ForStatement');
        }
        parseForIn(e, t, r) {
          const s = this.match(58);
          this.next();
          if (s) {
            if (r !== null) this.unexpected(r);
          } else {
            e.await = r !== null;
          }
          if (
            t.type === 'VariableDeclaration' &&
            t.declarations[0].init != null &&
            (!s ||
              !this.options.annexB ||
              this.state.strict ||
              t.kind !== 'var' ||
              t.declarations[0].id.type !== 'Identifier')
          ) {
            this.raise(u.ForInOfLoopInitializer, {
              at: t,
              type: s ? 'ForInStatement' : 'ForOfStatement',
            });
          }
          if (t.type === 'AssignmentPattern') {
            this.raise(u.InvalidLhs, {
              at: t,
              ancestor: { type: 'ForStatement' },
            });
          }
          e.left = t;
          e.right = s ? this.parseExpression() : this.parseMaybeAssignAllowIn();
          this.expect(11);
          e.body = this.withSmartMixTopicForbiddingContext(() =>
            this.parseStatement(),
          );
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(e, s ? 'ForInStatement' : 'ForOfStatement');
        }
        parseVar(e, t, r, s = false) {
          const i = (e.declarations = []);
          e.kind = r;
          for (;;) {
            const e = this.startNode();
            this.parseVarId(e, r);
            e.init = !this.eat(29)
              ? null
              : t
              ? this.parseMaybeAssignDisallowIn()
              : this.parseMaybeAssignAllowIn();
            if (e.init === null && !s) {
              if (
                e.id.type !== 'Identifier' &&
                !(t && (this.match(58) || this.isContextual(102)))
              ) {
                this.raise(u.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: 'destructuring',
                });
              } else if (
                r === 'const' &&
                !(this.match(58) || this.isContextual(102))
              ) {
                this.raise(u.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: 'const',
                });
              }
            }
            i.push(this.finishNode(e, 'VariableDeclarator'));
            if (!this.eat(12)) break;
          }
          return e;
        }
        parseVarId(e, t) {
          const r = this.parseBindingAtom();
          this.checkLVal(r, {
            in: { type: 'VariableDeclarator' },
            binding: t === 'var' ? 5 : 8201,
          });
          e.id = r;
        }
        parseAsyncFunctionExpression(e) {
          return this.parseFunction(e, 8);
        }
        parseFunction(e, t = 0) {
          const r = t & 2;
          const s = !!(t & 1);
          const i = s && !(t & 4);
          const n = !!(t & 8);
          this.initFunction(e, n);
          if (this.match(55)) {
            if (r) {
              this.raise(u.GeneratorInSingleStatementContext, {
                at: this.state.startLoc,
              });
            }
            this.next();
            e.generator = true;
          }
          if (s) {
            e.id = this.parseFunctionId(i);
          }
          const a = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = false;
          this.scope.enter(2);
          this.prodParam.enter(functionFlags(n, e.generator));
          if (!s) {
            e.id = this.parseFunctionId();
          }
          this.parseFunctionParams(e, false);
          this.withSmartMixTopicForbiddingContext(() => {
            this.parseFunctionBodyAndFinish(
              e,
              s ? 'FunctionDeclaration' : 'FunctionExpression',
            );
          });
          this.prodParam.exit();
          this.scope.exit();
          if (s && !r) {
            this.registerFunctionStatementId(e);
          }
          this.state.maybeInArrowParameters = a;
          return e;
        }
        parseFunctionId(e) {
          return e || tokenIsIdentifier(this.state.type)
            ? this.parseIdentifier()
            : null;
        }
        parseFunctionParams(e, t) {
          this.expect(10);
          this.expressionScope.enter(newParameterDeclarationScope());
          e.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0));
          this.expressionScope.exit();
        }
        registerFunctionStatementId(e) {
          if (!e.id) return;
          this.scope.declareName(
            e.id.name,
            !this.options.annexB || this.state.strict || e.generator || e.async
              ? this.scope.treatFunctionsAsVar
                ? 5
                : 8201
              : 17,
            e.id.loc.start,
          );
        }
        parseClass(e, t, r) {
          this.next();
          const s = this.state.strict;
          this.state.strict = true;
          this.parseClassId(e, t, r);
          this.parseClassSuper(e);
          e.body = this.parseClassBody(!!e.superClass, s);
          return this.finishNode(e, t ? 'ClassDeclaration' : 'ClassExpression');
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
          return this.match(10);
        }
        isNonstaticConstructor(e) {
          return (
            !e.computed &&
            !e.static &&
            (e.key.name === 'constructor' || e.key.value === 'constructor')
          );
        }
        parseClassBody(e, t) {
          this.classScope.enter();
          const r = { hadConstructor: false, hadSuperClass: e };
          let s = [];
          const i = this.startNode();
          i.body = [];
          this.expect(5);
          this.withSmartMixTopicForbiddingContext(() => {
            while (!this.match(8)) {
              if (this.eat(13)) {
                if (s.length > 0) {
                  throw this.raise(u.DecoratorSemicolon, {
                    at: this.state.lastTokEndLoc,
                  });
                }
                continue;
              }
              if (this.match(26)) {
                s.push(this.parseDecorator());
                continue;
              }
              const e = this.startNode();
              if (s.length) {
                e.decorators = s;
                this.resetStartLocationFromNode(e, s[0]);
                s = [];
              }
              this.parseClassMember(i, e, r);
              if (
                e.kind === 'constructor' &&
                e.decorators &&
                e.decorators.length > 0
              ) {
                this.raise(u.DecoratorConstructor, { at: e });
              }
            }
          });
          this.state.strict = t;
          this.next();
          if (s.length) {
            throw this.raise(u.TrailingDecorator, { at: this.state.startLoc });
          }
          this.classScope.exit();
          return this.finishNode(i, 'ClassBody');
        }
        parseClassMemberFromModifier(e, t) {
          const r = this.parseIdentifier(true);
          if (this.isClassMethod()) {
            const s = t;
            s.kind = 'method';
            s.computed = false;
            s.key = r;
            s.static = false;
            this.pushClassMethod(e, s, false, false, false, false);
            return true;
          } else if (this.isClassProperty()) {
            const s = t;
            s.computed = false;
            s.key = r;
            s.static = false;
            e.body.push(this.parseClassProperty(s));
            return true;
          }
          this.resetPreviousNodeTrailingComments(r);
          return false;
        }
        parseClassMember(e, t, r) {
          const s = this.isContextual(106);
          if (s) {
            if (this.parseClassMemberFromModifier(e, t)) {
              return;
            }
            if (this.eat(5)) {
              this.parseClassStaticBlock(e, t);
              return;
            }
          }
          this.parseClassMemberWithIsStatic(e, t, r, s);
        }
        parseClassMemberWithIsStatic(e, t, r, s) {
          const i = t;
          const n = t;
          const a = t;
          const o = t;
          const l = t;
          const c = i;
          const p = i;
          t.static = s;
          this.parsePropertyNamePrefixOperator(t);
          if (this.eat(55)) {
            c.kind = 'method';
            const t = this.match(138);
            this.parseClassElementName(c);
            if (t) {
              this.pushClassPrivateMethod(e, n, true, false);
              return;
            }
            if (this.isNonstaticConstructor(i)) {
              this.raise(u.ConstructorIsGenerator, { at: i.key });
            }
            this.pushClassMethod(e, i, true, false, false, false);
            return;
          }
          const d =
            tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
          const f = this.match(138);
          const h = this.parseClassElementName(t);
          const y = this.state.startLoc;
          this.parsePostMemberNameModifiers(p);
          if (this.isClassMethod()) {
            c.kind = 'method';
            if (f) {
              this.pushClassPrivateMethod(e, n, false, false);
              return;
            }
            const s = this.isNonstaticConstructor(i);
            let a = false;
            if (s) {
              i.kind = 'constructor';
              if (r.hadConstructor && !this.hasPlugin('typescript')) {
                this.raise(u.DuplicateConstructor, { at: h });
              }
              if (s && this.hasPlugin('typescript') && t.override) {
                this.raise(u.OverrideOnConstructor, { at: h });
              }
              r.hadConstructor = true;
              a = r.hadSuperClass;
            }
            this.pushClassMethod(e, i, false, false, s, a);
          } else if (this.isClassProperty()) {
            if (f) {
              this.pushClassPrivateProperty(e, o);
            } else {
              this.pushClassProperty(e, a);
            }
          } else if (d && h.name === 'async' && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(h);
            const t = this.eat(55);
            if (p.optional) {
              this.unexpected(y);
            }
            c.kind = 'method';
            const r = this.match(138);
            this.parseClassElementName(c);
            this.parsePostMemberNameModifiers(p);
            if (r) {
              this.pushClassPrivateMethod(e, n, t, true);
            } else {
              if (this.isNonstaticConstructor(i)) {
                this.raise(u.ConstructorIsAsync, { at: i.key });
              }
              this.pushClassMethod(e, i, t, true, false, false);
            }
          } else if (
            d &&
            (h.name === 'get' || h.name === 'set') &&
            !(this.match(55) && this.isLineTerminator())
          ) {
            this.resetPreviousNodeTrailingComments(h);
            c.kind = h.name;
            const t = this.match(138);
            this.parseClassElementName(i);
            if (t) {
              this.pushClassPrivateMethod(e, n, false, false);
            } else {
              if (this.isNonstaticConstructor(i)) {
                this.raise(u.ConstructorIsAccessor, { at: i.key });
              }
              this.pushClassMethod(e, i, false, false, false, false);
            }
            this.checkGetterSetterParams(i);
          } else if (d && h.name === 'accessor' && !this.isLineTerminator()) {
            this.expectPlugin('decoratorAutoAccessors');
            this.resetPreviousNodeTrailingComments(h);
            const t = this.match(138);
            this.parseClassElementName(a);
            this.pushClassAccessorProperty(e, l, t);
          } else if (this.isLineTerminator()) {
            if (f) {
              this.pushClassPrivateProperty(e, o);
            } else {
              this.pushClassProperty(e, a);
            }
          } else {
            this.unexpected();
          }
        }
        parseClassElementName(e) {
          const { type: t, value: r } = this.state;
          if ((t === 132 || t === 133) && e.static && r === 'prototype') {
            this.raise(u.StaticPrototype, { at: this.state.startLoc });
          }
          if (t === 138) {
            if (r === 'constructor') {
              this.raise(u.ConstructorClassPrivateField, {
                at: this.state.startLoc,
              });
            }
            const t = this.parsePrivateName();
            e.key = t;
            return t;
          }
          return this.parsePropertyName(e);
        }
        parseClassStaticBlock(e, t) {
          var r;
          this.scope.enter(64 | 128 | 16);
          const s = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(0);
          const i = (t.body = []);
          this.parseBlockOrModuleBlockBody(i, undefined, false, 8);
          this.prodParam.exit();
          this.scope.exit();
          this.state.labels = s;
          e.body.push(this.finishNode(t, 'StaticBlock'));
          if ((r = t.decorators) != null && r.length) {
            this.raise(u.DecoratorStaticBlock, { at: t });
          }
        }
        pushClassProperty(e, t) {
          if (
            !t.computed &&
            (t.key.name === 'constructor' || t.key.value === 'constructor')
          ) {
            this.raise(u.ConstructorClassField, { at: t.key });
          }
          e.body.push(this.parseClassProperty(t));
        }
        pushClassPrivateProperty(e, t) {
          const r = this.parseClassPrivateProperty(t);
          e.body.push(r);
          this.classScope.declarePrivateName(
            this.getPrivateNameSV(r.key),
            0,
            r.key.loc.start,
          );
        }
        pushClassAccessorProperty(e, t, r) {
          if (!r && !t.computed) {
            const e = t.key;
            if (e.name === 'constructor' || e.value === 'constructor') {
              this.raise(u.ConstructorClassField, { at: e });
            }
          }
          const s = this.parseClassAccessorProperty(t);
          e.body.push(s);
          if (r) {
            this.classScope.declarePrivateName(
              this.getPrivateNameSV(s.key),
              0,
              s.key.loc.start,
            );
          }
        }
        pushClassMethod(e, t, r, s, i, n) {
          e.body.push(this.parseMethod(t, r, s, i, n, 'ClassMethod', true));
        }
        pushClassPrivateMethod(e, t, r, s) {
          const i = this.parseMethod(
            t,
            r,
            s,
            false,
            false,
            'ClassPrivateMethod',
            true,
          );
          e.body.push(i);
          const n =
            i.kind === 'get'
              ? i.static
                ? 6
                : 2
              : i.kind === 'set'
              ? i.static
                ? 5
                : 1
              : 0;
          this.declareClassPrivateMethodInScope(i, n);
        }
        declareClassPrivateMethodInScope(e, t) {
          this.classScope.declarePrivateName(
            this.getPrivateNameSV(e.key),
            t,
            e.key.loc.start,
          );
        }
        parsePostMemberNameModifiers(e) {}
        parseClassPrivateProperty(e) {
          this.parseInitializer(e);
          this.semicolon();
          return this.finishNode(e, 'ClassPrivateProperty');
        }
        parseClassProperty(e) {
          this.parseInitializer(e);
          this.semicolon();
          return this.finishNode(e, 'ClassProperty');
        }
        parseClassAccessorProperty(e) {
          this.parseInitializer(e);
          this.semicolon();
          return this.finishNode(e, 'ClassAccessorProperty');
        }
        parseInitializer(e) {
          this.scope.enter(64 | 16);
          this.expressionScope.enter(newExpressionScope());
          this.prodParam.enter(0);
          e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
          this.expressionScope.exit();
          this.prodParam.exit();
          this.scope.exit();
        }
        parseClassId(e, t, r, s = 8331) {
          if (tokenIsIdentifier(this.state.type)) {
            e.id = this.parseIdentifier();
            if (t) {
              this.declareNameFromIdentifier(e.id, s);
            }
          } else {
            if (r || !t) {
              e.id = null;
            } else {
              throw this.raise(u.MissingClassName, { at: this.state.startLoc });
            }
          }
        }
        parseClassSuper(e) {
          e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(e, t) {
          const r = this.parseMaybeImportPhase(e, true);
          const s = this.maybeParseExportDefaultSpecifier(e, r);
          const i = !s || this.eat(12);
          const n = i && this.eatExportStar(e);
          const a = n && this.maybeParseExportNamespaceSpecifier(e);
          const o = i && (!a || this.eat(12));
          const l = s || n;
          if (n && !a) {
            if (s) this.unexpected();
            if (t) {
              throw this.raise(u.UnsupportedDecoratorExport, { at: e });
            }
            this.parseExportFrom(e, true);
            return this.finishNode(e, 'ExportAllDeclaration');
          }
          const c = this.maybeParseExportNamedSpecifiers(e);
          if (s && i && !n && !c) {
            this.unexpected(null, 5);
          }
          if (a && o) {
            this.unexpected(null, 98);
          }
          let p;
          if (l || c) {
            p = false;
            if (t) {
              throw this.raise(u.UnsupportedDecoratorExport, { at: e });
            }
            this.parseExportFrom(e, l);
          } else {
            p = this.maybeParseExportDeclaration(e);
          }
          if (l || c || p) {
            var d;
            const r = e;
            this.checkExport(r, true, false, !!r.source);
            if (
              ((d = r.declaration) == null ? void 0 : d.type) ===
              'ClassDeclaration'
            ) {
              this.maybeTakeDecorators(t, r.declaration, r);
            } else if (t) {
              throw this.raise(u.UnsupportedDecoratorExport, { at: e });
            }
            return this.finishNode(r, 'ExportNamedDeclaration');
          }
          if (this.eat(65)) {
            const r = e;
            const s = this.parseExportDefaultExpression();
            r.declaration = s;
            if (s.type === 'ClassDeclaration') {
              this.maybeTakeDecorators(t, s, r);
            } else if (t) {
              throw this.raise(u.UnsupportedDecoratorExport, { at: e });
            }
            this.checkExport(r, true, true);
            return this.finishNode(r, 'ExportDefaultDeclaration');
          }
          this.unexpected(null, 5);
        }
        eatExportStar(e) {
          return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(e, t) {
          if (t || this.isExportDefaultSpecifier()) {
            this.expectPlugin(
              'exportDefaultFrom',
              t == null ? void 0 : t.loc.start,
            );
            const r = t || this.parseIdentifier(true);
            const s = this.startNodeAtNode(r);
            s.exported = r;
            e.specifiers = [this.finishNode(s, 'ExportDefaultSpecifier')];
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(e) {
          if (this.isContextual(93)) {
            if (!e.specifiers) e.specifiers = [];
            const t = this.startNodeAt(this.state.lastTokStartLoc);
            this.next();
            t.exported = this.parseModuleExportName();
            e.specifiers.push(this.finishNode(t, 'ExportNamespaceSpecifier'));
            return true;
          }
          return false;
        }
        maybeParseExportNamedSpecifiers(e) {
          if (this.match(5)) {
            if (!e.specifiers) e.specifiers = [];
            const t = e.exportKind === 'type';
            e.specifiers.push(...this.parseExportSpecifiers(t));
            e.source = null;
            e.declaration = null;
            if (this.hasPlugin('importAssertions')) {
              e.assertions = [];
            }
            return true;
          }
          return false;
        }
        maybeParseExportDeclaration(e) {
          if (this.shouldParseExportDeclaration()) {
            e.specifiers = [];
            e.source = null;
            if (this.hasPlugin('importAssertions')) {
              e.assertions = [];
            }
            e.declaration = this.parseExportDeclaration(e);
            return true;
          }
          return false;
        }
        isAsyncFunction() {
          if (!this.isContextual(95)) return false;
          const e = this.nextTokenInLineStart();
          return this.isUnparsedContextual(e, 'function');
        }
        parseExportDefaultExpression() {
          const e = this.startNode();
          if (this.match(68)) {
            this.next();
            return this.parseFunction(e, 1 | 4);
          } else if (this.isAsyncFunction()) {
            this.next();
            this.next();
            return this.parseFunction(e, 1 | 4 | 8);
          }
          if (this.match(80)) {
            return this.parseClass(e, true, true);
          }
          if (this.match(26)) {
            if (
              this.hasPlugin('decorators') &&
              this.getPluginOption('decorators', 'decoratorsBeforeExport') ===
                true
            ) {
              this.raise(u.DecoratorBeforeExport, { at: this.state.startLoc });
            }
            return this.parseClass(
              this.maybeTakeDecorators(
                this.parseDecorators(false),
                this.startNode(),
              ),
              true,
              true,
            );
          }
          if (this.match(75) || this.match(74) || this.isLet()) {
            throw this.raise(u.UnsupportedDefaultExport, {
              at: this.state.startLoc,
            });
          }
          const t = this.parseMaybeAssignAllowIn();
          this.semicolon();
          return t;
        }
        parseExportDeclaration(e) {
          if (this.match(80)) {
            const e = this.parseClass(this.startNode(), true, false);
            return e;
          }
          return this.parseStatementListItem();
        }
        isExportDefaultSpecifier() {
          const { type: e } = this.state;
          if (tokenIsIdentifier(e)) {
            if ((e === 95 && !this.state.containsEsc) || e === 100) {
              return false;
            }
            if ((e === 130 || e === 129) && !this.state.containsEsc) {
              const { type: e } = this.lookahead();
              if ((tokenIsIdentifier(e) && e !== 98) || e === 5) {
                this.expectOnePlugin(['flow', 'typescript']);
                return false;
              }
            }
          } else if (!this.match(65)) {
            return false;
          }
          const t = this.nextTokenStart();
          const r = this.isUnparsedContextual(t, 'from');
          if (
            this.input.charCodeAt(t) === 44 ||
            (tokenIsIdentifier(this.state.type) && r)
          ) {
            return true;
          }
          if (this.match(65) && r) {
            const e = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
            return e === 34 || e === 39;
          }
          return false;
        }
        parseExportFrom(e, t) {
          if (this.eatContextual(98)) {
            e.source = this.parseImportSource();
            this.checkExport(e);
            this.maybeParseImportAttributes(e);
            this.checkJSONModuleImport(e);
          } else if (t) {
            this.unexpected();
          }
          this.semicolon();
        }
        shouldParseExportDeclaration() {
          const { type: e } = this.state;
          if (e === 26) {
            this.expectOnePlugin(['decorators', 'decorators-legacy']);
            if (this.hasPlugin('decorators')) {
              if (
                this.getPluginOption('decorators', 'decoratorsBeforeExport') ===
                true
              ) {
                this.raise(u.DecoratorBeforeExport, {
                  at: this.state.startLoc,
                });
              }
              return true;
            }
          }
          return (
            e === 74 ||
            e === 75 ||
            e === 68 ||
            e === 80 ||
            this.isLet() ||
            this.isAsyncFunction()
          );
        }
        checkExport(e, t, r, s) {
          if (t) {
            var i;
            if (r) {
              this.checkDuplicateExports(e, 'default');
              if (this.hasPlugin('exportDefaultFrom')) {
                var n;
                const t = e.declaration;
                if (
                  t.type === 'Identifier' &&
                  t.name === 'from' &&
                  t.end - t.start === 4 &&
                  !((n = t.extra) != null && n.parenthesized)
                ) {
                  this.raise(u.ExportDefaultFromAsIdentifier, { at: t });
                }
              }
            } else if ((i = e.specifiers) != null && i.length) {
              for (const t of e.specifiers) {
                const { exported: e } = t;
                const r = e.type === 'Identifier' ? e.name : e.value;
                this.checkDuplicateExports(t, r);
                if (!s && t.local) {
                  const { local: e } = t;
                  if (e.type !== 'Identifier') {
                    this.raise(u.ExportBindingIsString, {
                      at: t,
                      localName: e.value,
                      exportName: r,
                    });
                  } else {
                    this.checkReservedWord(e.name, e.loc.start, true, false);
                    this.scope.checkLocalExport(e);
                  }
                }
              }
            } else if (e.declaration) {
              if (
                e.declaration.type === 'FunctionDeclaration' ||
                e.declaration.type === 'ClassDeclaration'
              ) {
                const t = e.declaration.id;
                if (!t) throw new Error('Assertion failure');
                this.checkDuplicateExports(e, t.name);
              } else if (e.declaration.type === 'VariableDeclaration') {
                for (const t of e.declaration.declarations) {
                  this.checkDeclaration(t.id);
                }
              }
            }
          }
        }
        checkDeclaration(e) {
          if (e.type === 'Identifier') {
            this.checkDuplicateExports(e, e.name);
          } else if (e.type === 'ObjectPattern') {
            for (const t of e.properties) {
              this.checkDeclaration(t);
            }
          } else if (e.type === 'ArrayPattern') {
            for (const t of e.elements) {
              if (t) {
                this.checkDeclaration(t);
              }
            }
          } else if (e.type === 'ObjectProperty') {
            this.checkDeclaration(e.value);
          } else if (e.type === 'RestElement') {
            this.checkDeclaration(e.argument);
          } else if (e.type === 'AssignmentPattern') {
            this.checkDeclaration(e.left);
          }
        }
        checkDuplicateExports(e, t) {
          if (this.exportedIdentifiers.has(t)) {
            if (t === 'default') {
              this.raise(u.DuplicateDefaultExport, { at: e });
            } else {
              this.raise(u.DuplicateExport, { at: e, exportName: t });
            }
          }
          this.exportedIdentifiers.add(t);
        }
        parseExportSpecifiers(e) {
          const t = [];
          let r = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (r) {
              r = false;
            } else {
              this.expect(12);
              if (this.eat(8)) break;
            }
            const s = this.isContextual(130);
            const i = this.match(133);
            const n = this.startNode();
            n.local = this.parseModuleExportName();
            t.push(this.parseExportSpecifier(n, i, e, s));
          }
          return t;
        }
        parseExportSpecifier(e, t, r, s) {
          if (this.eatContextual(93)) {
            e.exported = this.parseModuleExportName();
          } else if (t) {
            e.exported = cloneStringLiteral(e.local);
          } else if (!e.exported) {
            e.exported = cloneIdentifier(e.local);
          }
          return this.finishNode(e, 'ExportSpecifier');
        }
        parseModuleExportName() {
          if (this.match(133)) {
            const e = this.parseStringLiteral(this.state.value);
            const t = e.value.match(he);
            if (t) {
              this.raise(u.ModuleExportNameHasLoneSurrogate, {
                at: e,
                surrogateCharCode: t[0].charCodeAt(0),
              });
            }
            return e;
          }
          return this.parseIdentifier(true);
        }
        isJSONModuleImport(e) {
          if (e.assertions != null) {
            return e.assertions.some(
              ({ key: e, value: t }) =>
                t.value === 'json' &&
                (e.type === 'Identifier'
                  ? e.name === 'type'
                  : e.value === 'type'),
            );
          }
          return false;
        }
        checkImportReflection(e) {
          const { specifiers: t } = e;
          const r = t.length === 1 ? t[0].type : null;
          if (e.phase === 'source') {
            if (r !== 'ImportDefaultSpecifier') {
              this.raise(u.SourcePhaseImportRequiresDefault, {
                at: t[0].loc.start,
              });
            }
          } else if (e.phase === 'defer') {
            if (r !== 'ImportNamespaceSpecifier') {
              this.raise(u.DeferImportRequiresNamespace, {
                at: t[0].loc.start,
              });
            }
          } else if (e.module) {
            var s;
            if (r !== 'ImportDefaultSpecifier') {
              this.raise(u.ImportReflectionNotBinding, { at: t[0].loc.start });
            }
            if (((s = e.assertions) == null ? void 0 : s.length) > 0) {
              this.raise(u.ImportReflectionHasAssertion, {
                at: e.specifiers[0].loc.start,
              });
            }
          }
        }
        checkJSONModuleImport(e) {
          if (this.isJSONModuleImport(e) && e.type !== 'ExportAllDeclaration') {
            const { specifiers: t } = e;
            if (t != null) {
              const e = t.find((e) => {
                let t;
                if (e.type === 'ExportSpecifier') {
                  t = e.local;
                } else if (e.type === 'ImportSpecifier') {
                  t = e.imported;
                }
                if (t !== undefined) {
                  return t.type === 'Identifier'
                    ? t.name !== 'default'
                    : t.value !== 'default';
                }
              });
              if (e !== undefined) {
                this.raise(u.ImportJSONBindingNotDefault, { at: e.loc.start });
              }
            }
          }
        }
        isPotentialImportPhase(e) {
          if (e) return false;
          return (
            this.isContextual(105) ||
            this.isContextual(97) ||
            this.isContextual(127)
          );
        }
        applyImportPhase(e, t, r, s) {
          if (t) {
            return;
          }
          if (r === 'module') {
            this.expectPlugin('importReflection', s);
            e.module = true;
          } else if (this.hasPlugin('importReflection')) {
            e.module = false;
          }
          if (r === 'source') {
            this.expectPlugin('sourcePhaseImports', s);
            e.phase = 'source';
          } else if (r === 'defer') {
            this.expectPlugin('deferredImportEvaluation', s);
            e.phase = 'defer';
          } else if (this.hasPlugin('sourcePhaseImports')) {
            e.phase = null;
          }
        }
        parseMaybeImportPhase(e, t) {
          if (!this.isPotentialImportPhase(t)) {
            this.applyImportPhase(e, t, null);
            return null;
          }
          const r = this.parseIdentifier(true);
          const { type: s } = this.state;
          const i = tokenIsKeywordOrIdentifier(s)
            ? s !== 98 || this.lookaheadCharCode() === 102
            : s !== 12;
          if (i) {
            this.resetPreviousIdentifierLeadingComments(r);
            this.applyImportPhase(e, t, r.name, r.loc.start);
            return null;
          } else {
            this.applyImportPhase(e, t, null);
            return r;
          }
        }
        isPrecedingIdImportPhase(e) {
          const { type: t } = this.state;
          return tokenIsIdentifier(t)
            ? t !== 98 || this.lookaheadCharCode() === 102
            : t !== 12;
        }
        parseImport(e) {
          if (this.match(133)) {
            return this.parseImportSourceAndAttributes(e);
          }
          return this.parseImportSpecifiersAndAfter(
            e,
            this.parseMaybeImportPhase(e, false),
          );
        }
        parseImportSpecifiersAndAfter(e, t) {
          e.specifiers = [];
          const r = this.maybeParseDefaultImportSpecifier(e, t);
          const s = !r || this.eat(12);
          const i = s && this.maybeParseStarImportSpecifier(e);
          if (s && !i) this.parseNamedImportSpecifiers(e);
          this.expectContextual(98);
          return this.parseImportSourceAndAttributes(e);
        }
        parseImportSourceAndAttributes(e) {
          var t;
          (t = e.specifiers) != null ? t : (e.specifiers = []);
          e.source = this.parseImportSource();
          this.maybeParseImportAttributes(e);
          this.checkImportReflection(e);
          this.checkJSONModuleImport(e);
          this.semicolon();
          return this.finishNode(e, 'ImportDeclaration');
        }
        parseImportSource() {
          if (!this.match(133)) this.unexpected();
          return this.parseExprAtom();
        }
        parseImportSpecifierLocal(e, t, r) {
          t.local = this.parseIdentifier();
          e.specifiers.push(this.finishImportSpecifier(t, r));
        }
        finishImportSpecifier(e, t, r = 8201) {
          this.checkLVal(e.local, { in: { type: t }, binding: r });
          return this.finishNode(e, t);
        }
        parseImportAttributes() {
          this.expect(5);
          const e = [];
          const t = new Set();
          do {
            if (this.match(8)) {
              break;
            }
            const r = this.startNode();
            const s = this.state.value;
            if (t.has(s)) {
              this.raise(u.ModuleAttributesWithDuplicateKeys, {
                at: this.state.startLoc,
                key: s,
              });
            }
            t.add(s);
            if (this.match(133)) {
              r.key = this.parseStringLiteral(s);
            } else {
              r.key = this.parseIdentifier(true);
            }
            this.expect(14);
            if (!this.match(133)) {
              throw this.raise(u.ModuleAttributeInvalidValue, {
                at: this.state.startLoc,
              });
            }
            r.value = this.parseStringLiteral(this.state.value);
            e.push(this.finishNode(r, 'ImportAttribute'));
          } while (this.eat(12));
          this.expect(8);
          return e;
        }
        parseModuleAttributes() {
          const e = [];
          const t = new Set();
          do {
            const r = this.startNode();
            r.key = this.parseIdentifier(true);
            if (r.key.name !== 'type') {
              this.raise(u.ModuleAttributeDifferentFromType, { at: r.key });
            }
            if (t.has(r.key.name)) {
              this.raise(u.ModuleAttributesWithDuplicateKeys, {
                at: r.key,
                key: r.key.name,
              });
            }
            t.add(r.key.name);
            this.expect(14);
            if (!this.match(133)) {
              throw this.raise(u.ModuleAttributeInvalidValue, {
                at: this.state.startLoc,
              });
            }
            r.value = this.parseStringLiteral(this.state.value);
            e.push(this.finishNode(r, 'ImportAttribute'));
          } while (this.eat(12));
          return e;
        }
        maybeParseImportAttributes(e) {
          let t;
          let r = false;
          if (this.match(76)) {
            if (
              this.hasPrecedingLineBreak() &&
              this.lookaheadCharCode() === 40
            ) {
              return;
            }
            this.next();
            {
              if (this.hasPlugin('moduleAttributes')) {
                t = this.parseModuleAttributes();
              } else {
                this.expectImportAttributesPlugin();
                t = this.parseImportAttributes();
              }
            }
            r = true;
          } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
            if (this.hasPlugin('importAttributes')) {
              if (
                this.getPluginOption(
                  'importAttributes',
                  'deprecatedAssertSyntax',
                ) !== true
              ) {
                this.raise(u.ImportAttributesUseAssert, {
                  at: this.state.startLoc,
                });
              }
              this.addExtra(e, 'deprecatedAssertSyntax', true);
            } else {
              this.expectOnePlugin(['importAttributes', 'importAssertions']);
            }
            this.next();
            t = this.parseImportAttributes();
          } else if (
            this.hasPlugin('importAttributes') ||
            this.hasPlugin('importAssertions')
          ) {
            t = [];
          } else {
            if (this.hasPlugin('moduleAttributes')) {
              t = [];
            } else return;
          }
          if (!r && this.hasPlugin('importAssertions')) {
            e.assertions = t;
          } else {
            e.attributes = t;
          }
        }
        maybeParseDefaultImportSpecifier(e, t) {
          if (t) {
            const r = this.startNodeAtNode(t);
            r.local = t;
            e.specifiers.push(
              this.finishImportSpecifier(r, 'ImportDefaultSpecifier'),
            );
            return true;
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            this.parseImportSpecifierLocal(
              e,
              this.startNode(),
              'ImportDefaultSpecifier',
            );
            return true;
          }
          return false;
        }
        maybeParseStarImportSpecifier(e) {
          if (this.match(55)) {
            const t = this.startNode();
            this.next();
            this.expectContextual(93);
            this.parseImportSpecifierLocal(e, t, 'ImportNamespaceSpecifier');
            return true;
          }
          return false;
        }
        parseNamedImportSpecifiers(e) {
          let t = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (t) {
              t = false;
            } else {
              if (this.eat(14)) {
                throw this.raise(u.DestructureNamedImport, {
                  at: this.state.startLoc,
                });
              }
              this.expect(12);
              if (this.eat(8)) break;
            }
            const r = this.startNode();
            const s = this.match(133);
            const i = this.isContextual(130);
            r.imported = this.parseModuleExportName();
            const n = this.parseImportSpecifier(
              r,
              s,
              e.importKind === 'type' || e.importKind === 'typeof',
              i,
              undefined,
            );
            e.specifiers.push(n);
          }
        }
        parseImportSpecifier(e, t, r, s, i) {
          if (this.eatContextual(93)) {
            e.local = this.parseIdentifier();
          } else {
            const { imported: r } = e;
            if (t) {
              throw this.raise(u.ImportBindingIsString, {
                at: e,
                importName: r.value,
              });
            }
            this.checkReservedWord(r.name, e.loc.start, true, true);
            if (!e.local) {
              e.local = cloneIdentifier(r);
            }
          }
          return this.finishImportSpecifier(e, 'ImportSpecifier', i);
        }
        isThisParam(e) {
          return e.type === 'Identifier' && e.name === 'this';
        }
      }
      class Parser extends StatementParser {
        constructor(e, t) {
          e = getOptions(e);
          super(e, t);
          this.options = e;
          this.initializeScopes();
          this.plugins = pluginsMap(this.options.plugins);
          this.filename = e.sourceFilename;
        }
        getScopeHandler() {
          return ScopeHandler;
        }
        parse() {
          this.enterInitialScopes();
          const e = this.startNode();
          const t = this.startNode();
          this.nextToken();
          e.errors = null;
          this.parseTopLevel(e, t);
          e.errors = this.state.errors;
          return e;
        }
      }
      function pluginsMap(e) {
        const t = new Map();
        for (const r of e) {
          const [e, s] = Array.isArray(r) ? r : [r, {}];
          if (!t.has(e)) t.set(e, s || {});
        }
        return t;
      }
      function parse(e, t) {
        var r;
        if (((r = t) == null ? void 0 : r.sourceType) === 'unambiguous') {
          t = Object.assign({}, t);
          try {
            t.sourceType = 'module';
            const r = getParser(t, e);
            const s = r.parse();
            if (r.sawUnambiguousESM) {
              return s;
            }
            if (r.ambiguousScriptDifferentAst) {
              try {
                t.sourceType = 'script';
                return getParser(t, e).parse();
              } catch (e) {}
            } else {
              s.program.sourceType = 'script';
            }
            return s;
          } catch (r) {
            try {
              t.sourceType = 'script';
              return getParser(t, e).parse();
            } catch (e) {}
            throw r;
          }
        } else {
          return getParser(t, e).parse();
        }
      }
      function parseExpression(e, t) {
        const r = getParser(t, e);
        if (r.options.strictMode) {
          r.state.strict = true;
        }
        return r.getExpression();
      }
      function generateExportedTokenTypes(e) {
        const t = {};
        for (const r of Object.keys(e)) {
          t[r] = getExportedToken(e[r]);
        }
        return t;
      }
      const me = generateExportedTokenTypes(N);
      function getParser(e, t) {
        let r = Parser;
        if (e != null && e.plugins) {
          validatePlugins(e.plugins);
          r = getParserClass(e.plugins);
        }
        return new r(e, t);
      }
      const Te = {};
      function getParserClass(e) {
        const t = pe.filter((t) => hasPlugin(e, t));
        const r = t.join('/');
        let s = Te[r];
        if (!s) {
          s = Parser;
          for (const e of t) {
            s = ce[e](s);
          }
          Te[r] = s;
        }
        return s;
      }
      t.parse = parse;
      t.parseExpression = parseExpression;
      t.tokTypes = me;
    },
    4435: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = void 0;
      var s = r(6028);
      var i = (t['default'] = (0, s.declare)((e) => {
        e.assertVersion(7);
        return {
          name: 'syntax-jsx',
          manipulateOptions(e, t) {
            {
              if (
                t.plugins.some(
                  (e) => (Array.isArray(e) ? e[0] : e) === 'typescript',
                )
              ) {
                return;
              }
            }
            t.plugins.push('jsx');
          },
        };
      }));
    },
    6435: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = createTemplateBuilder;
      var s = r(9541);
      var i = r(5435);
      var n = r(1527);
      const a = (0, s.validate)({ placeholderPattern: false });
      function createTemplateBuilder(e, t) {
        const r = new WeakMap();
        const o = new WeakMap();
        const l = t || (0, s.validate)(null);
        return Object.assign(
          (t, ...a) => {
            if (typeof t === 'string') {
              if (a.length > 1) throw new Error('Unexpected extra params.');
              return extendedTrace(
                (0, i.default)(e, t, (0, s.merge)(l, (0, s.validate)(a[0]))),
              );
            } else if (Array.isArray(t)) {
              let s = r.get(t);
              if (!s) {
                s = (0, n.default)(e, t, l);
                r.set(t, s);
              }
              return extendedTrace(s(a));
            } else if (typeof t === 'object' && t) {
              if (a.length > 0) throw new Error('Unexpected extra params.');
              return createTemplateBuilder(
                e,
                (0, s.merge)(l, (0, s.validate)(t)),
              );
            }
            throw new Error(`Unexpected template param ${typeof t}`);
          },
          {
            ast: (t, ...r) => {
              if (typeof t === 'string') {
                if (r.length > 1) throw new Error('Unexpected extra params.');
                return (0, i.default)(
                  e,
                  t,
                  (0, s.merge)((0, s.merge)(l, (0, s.validate)(r[0])), a),
                )();
              } else if (Array.isArray(t)) {
                let i = o.get(t);
                if (!i) {
                  i = (0, n.default)(e, t, (0, s.merge)(l, a));
                  o.set(t, i);
                }
                return i(r)();
              }
              throw new Error(`Unexpected template param ${typeof t}`);
            },
          },
        );
      }
      function extendedTrace(e) {
        let t = '';
        try {
          throw new Error();
        } catch (e) {
          if (e.stack) {
            t = e.stack.split('\n').slice(3).join('\n');
          }
        }
        return (r) => {
          try {
            return e(r);
          } catch (e) {
            e.stack += `\n    =============\n${t}`;
            throw e;
          }
        };
      }
    },
    3499: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.statements = t.statement = t.smart = t.program = t.expression = void 0;
      var s = r(4739);
      const { assertExpressionStatement: i } = s;
      function makeStatementFormatter(e) {
        return {
          code: (e) => `/* @babel/template */;\n${e}`,
          validate: () => {},
          unwrap: (t) => e(t.program.body.slice(1)),
        };
      }
      const n = makeStatementFormatter((e) => {
        if (e.length > 1) {
          return e;
        } else {
          return e[0];
        }
      });
      t.smart = n;
      const a = makeStatementFormatter((e) => e);
      t.statements = a;
      const o = makeStatementFormatter((e) => {
        if (e.length === 0) {
          throw new Error('Found nothing to return.');
        }
        if (e.length > 1) {
          throw new Error('Found multiple statements but wanted one');
        }
        return e[0];
      });
      t.statement = o;
      const l = {
        code: (e) => `(\n${e}\n)`,
        validate: (e) => {
          if (e.program.body.length > 1) {
            throw new Error('Found multiple statements but wanted one');
          }
          if (l.unwrap(e).start === 0) {
            throw new Error('Parse result included parens.');
          }
        },
        unwrap: ({ program: e }) => {
          const [t] = e.body;
          i(t);
          return t.expression;
        },
      };
      t.expression = l;
      const c = {
        code: (e) => e,
        validate: () => {},
        unwrap: (e) => e.program,
      };
      t.program = c;
    },
    8063: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.statements =
        t.statement =
        t.smart =
        t.program =
        t.expression =
        t['default'] =
          void 0;
      var s = r(3499);
      var i = r(6435);
      const n = (0, i.default)(s.smart);
      t.smart = n;
      const a = (0, i.default)(s.statement);
      t.statement = a;
      const o = (0, i.default)(s.statements);
      t.statements = o;
      const l = (0, i.default)(s.expression);
      t.expression = l;
      const c = (0, i.default)(s.program);
      t.program = c;
      var p = Object.assign(n.bind(undefined), {
        smart: n,
        statement: a,
        statements: o,
        expression: l,
        program: c,
        ast: n.ast,
      });
      t['default'] = p;
    },
    1527: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = literalTemplate;
      var s = r(9541);
      var i = r(6340);
      var n = r(7839);
      function literalTemplate(e, t, r) {
        const { metadata: i, names: a } = buildLiteralData(e, t, r);
        return (t) => {
          const r = {};
          t.forEach((e, t) => {
            r[a[t]] = e;
          });
          return (t) => {
            const a = (0, s.normalizeReplacements)(t);
            if (a) {
              Object.keys(a).forEach((e) => {
                if (Object.prototype.hasOwnProperty.call(r, e)) {
                  throw new Error('Unexpected replacement overlap.');
                }
              });
            }
            return e.unwrap((0, n.default)(i, a ? Object.assign(a, r) : r));
          };
        };
      }
      function buildLiteralData(e, t, r) {
        let s = 'BABEL_TPL$';
        const n = t.join('');
        do {
          s = '$$' + s;
        } while (n.includes(s));
        const { names: a, code: o } = buildTemplateCode(t, s);
        const l = (0, i.default)(e, e.code(o), {
          parser: r.parser,
          placeholderWhitelist: new Set(
            a.concat(
              r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [],
            ),
          ),
          placeholderPattern: r.placeholderPattern,
          preserveComments: r.preserveComments,
          syntacticPlaceholders: r.syntacticPlaceholders,
        });
        return { metadata: l, names: a };
      }
      function buildTemplateCode(e, t) {
        const r = [];
        let s = e[0];
        for (let i = 1; i < e.length; i++) {
          const n = `${t}${i - 1}`;
          r.push(n);
          s += n + e[i];
        }
        return { names: r, code: s };
      }
    },
    9541: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.merge = merge;
      t.normalizeReplacements = normalizeReplacements;
      t.validate = validate;
      const r = [
        'placeholderWhitelist',
        'placeholderPattern',
        'preserveComments',
        'syntacticPlaceholders',
      ];
      function _objectWithoutPropertiesLoose(e, t) {
        if (e == null) return {};
        var r = {};
        var s = Object.keys(e);
        var i, n;
        for (n = 0; n < s.length; n++) {
          i = s[n];
          if (t.indexOf(i) >= 0) continue;
          r[i] = e[i];
        }
        return r;
      }
      function merge(e, t) {
        const {
          placeholderWhitelist: r = e.placeholderWhitelist,
          placeholderPattern: s = e.placeholderPattern,
          preserveComments: i = e.preserveComments,
          syntacticPlaceholders: n = e.syntacticPlaceholders,
        } = t;
        return {
          parser: Object.assign({}, e.parser, t.parser),
          placeholderWhitelist: r,
          placeholderPattern: s,
          preserveComments: i,
          syntacticPlaceholders: n,
        };
      }
      function validate(e) {
        if (e != null && typeof e !== 'object') {
          throw new Error('Unknown template options.');
        }
        const t = e || {},
          {
            placeholderWhitelist: s,
            placeholderPattern: i,
            preserveComments: n,
            syntacticPlaceholders: a,
          } = t,
          o = _objectWithoutPropertiesLoose(t, r);
        if (s != null && !(s instanceof Set)) {
          throw new Error(
            "'.placeholderWhitelist' must be a Set, null, or undefined",
          );
        }
        if (i != null && !(i instanceof RegExp) && i !== false) {
          throw new Error(
            "'.placeholderPattern' must be a RegExp, false, null, or undefined",
          );
        }
        if (n != null && typeof n !== 'boolean') {
          throw new Error(
            "'.preserveComments' must be a boolean, null, or undefined",
          );
        }
        if (a != null && typeof a !== 'boolean') {
          throw new Error(
            "'.syntacticPlaceholders' must be a boolean, null, or undefined",
          );
        }
        if (a === true && (s != null || i != null)) {
          throw new Error(
            "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" +
              " with '.syntacticPlaceholders: true'",
          );
        }
        return {
          parser: o,
          placeholderWhitelist: s || undefined,
          placeholderPattern: i == null ? undefined : i,
          preserveComments: n == null ? undefined : n,
          syntacticPlaceholders: a == null ? undefined : a,
        };
      }
      function normalizeReplacements(e) {
        if (Array.isArray(e)) {
          return e.reduce((e, t, r) => {
            e['$' + r] = t;
            return e;
          }, {});
        } else if (typeof e === 'object' || e == null) {
          return e || undefined;
        }
        throw new Error(
          'Template replacements must be an array, object, null, or undefined',
        );
      }
    },
    6340: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = parseAndBuildMetadata;
      var s = r(4739);
      var i = r(3033);
      var n = r(8135);
      const {
        isCallExpression: a,
        isExpressionStatement: o,
        isFunction: l,
        isIdentifier: c,
        isJSXIdentifier: p,
        isNewExpression: u,
        isPlaceholder: d,
        isStatement: f,
        isStringLiteral: h,
        removePropertiesDeep: y,
        traverse: m,
      } = s;
      const T = /^[_$A-Z0-9]+$/;
      function parseAndBuildMetadata(e, t, r) {
        const {
          placeholderWhitelist: s,
          placeholderPattern: i,
          preserveComments: n,
          syntacticPlaceholders: a,
        } = r;
        const o = parseWithCodeFrame(t, r.parser, a);
        y(o, { preserveComments: n });
        e.validate(o);
        const l = {
          syntactic: { placeholders: [], placeholderNames: new Set() },
          legacy: { placeholders: [], placeholderNames: new Set() },
          placeholderWhitelist: s,
          placeholderPattern: i,
          syntacticPlaceholders: a,
        };
        m(o, placeholderVisitorHandler, l);
        return Object.assign(
          { ast: o },
          l.syntactic.placeholders.length ? l.syntactic : l.legacy,
        );
      }
      function placeholderVisitorHandler(e, t, r) {
        var s;
        let i;
        let n = r.syntactic.placeholders.length > 0;
        if (d(e)) {
          if (r.syntacticPlaceholders === false) {
            throw new Error(
              "%%foo%%-style placeholders can't be used when " +
                "'.syntacticPlaceholders' is false.",
            );
          }
          i = e.name.name;
          n = true;
        } else if (n || r.syntacticPlaceholders) {
          return;
        } else if (c(e) || p(e)) {
          i = e.name;
        } else if (h(e)) {
          i = e.value;
        } else {
          return;
        }
        if (
          n &&
          (r.placeholderPattern != null || r.placeholderWhitelist != null)
        ) {
          throw new Error(
            "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" +
              " with '.syntacticPlaceholders: true'",
          );
        }
        if (
          !n &&
          (r.placeholderPattern === false ||
            !(r.placeholderPattern || T).test(i)) &&
          !((s = r.placeholderWhitelist) != null && s.has(i))
        ) {
          return;
        }
        t = t.slice();
        const { node: y, key: m } = t[t.length - 1];
        let S;
        if (h(e) || d(e, { expectedNode: 'StringLiteral' })) {
          S = 'string';
        } else if (
          (u(y) && m === 'arguments') ||
          (a(y) && m === 'arguments') ||
          (l(y) && m === 'params')
        ) {
          S = 'param';
        } else if (o(y) && !d(e)) {
          S = 'statement';
          t = t.slice(0, -1);
        } else if (f(e) && d(e)) {
          S = 'statement';
        } else {
          S = 'other';
        }
        const { placeholders: x, placeholderNames: b } = !n
          ? r.legacy
          : r.syntactic;
        x.push({
          name: i,
          type: S,
          resolve: (e) => resolveAncestors(e, t),
          isDuplicate: b.has(i),
        });
        b.add(i);
      }
      function resolveAncestors(e, t) {
        let r = e;
        for (let e = 0; e < t.length - 1; e++) {
          const { key: s, index: i } = t[e];
          if (i === undefined) {
            r = r[s];
          } else {
            r = r[s][i];
          }
        }
        const { key: s, index: i } = t[t.length - 1];
        return { parent: r, key: s, index: i };
      }
      function parseWithCodeFrame(e, t, r) {
        const s = (t.plugins || []).slice();
        if (r !== false) {
          s.push('placeholders');
        }
        t = Object.assign(
          {
            allowReturnOutsideFunction: true,
            allowSuperOutsideMethod: true,
            sourceType: 'module',
          },
          t,
          { plugins: s },
        );
        try {
          return (0, i.parse)(e, t);
        } catch (t) {
          const r = t.loc;
          if (r) {
            t.message += '\n' + (0, n.codeFrameColumns)(e, { start: r });
            t.code = 'BABEL_TEMPLATE_PARSE_ERROR';
          }
          throw t;
        }
      }
    },
    7839: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = populatePlaceholders;
      var s = r(4739);
      const {
        blockStatement: i,
        cloneNode: n,
        emptyStatement: a,
        expressionStatement: o,
        identifier: l,
        isStatement: c,
        isStringLiteral: p,
        stringLiteral: u,
        validate: d,
      } = s;
      function populatePlaceholders(e, t) {
        const r = n(e.ast);
        if (t) {
          e.placeholders.forEach((e) => {
            if (!Object.prototype.hasOwnProperty.call(t, e.name)) {
              const t = e.name;
              throw new Error(
                `Error: No substitution given for "${t}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t}'])}\n            - { placeholderPattern: /^${t}$/ }`,
              );
            }
          });
          Object.keys(t).forEach((t) => {
            if (!e.placeholderNames.has(t)) {
              throw new Error(`Unknown substitution "${t}" given`);
            }
          });
        }
        e.placeholders
          .slice()
          .reverse()
          .forEach((e) => {
            try {
              applyReplacement(e, r, (t && t[e.name]) || null);
            } catch (t) {
              t.message = `@babel/template placeholder "${e.name}": ${t.message}`;
              throw t;
            }
          });
        return r;
      }
      function applyReplacement(e, t, r) {
        if (e.isDuplicate) {
          if (Array.isArray(r)) {
            r = r.map((e) => n(e));
          } else if (typeof r === 'object') {
            r = n(r);
          }
        }
        const { parent: s, key: f, index: h } = e.resolve(t);
        if (e.type === 'string') {
          if (typeof r === 'string') {
            r = u(r);
          }
          if (!r || !p(r)) {
            throw new Error('Expected string substitution');
          }
        } else if (e.type === 'statement') {
          if (h === undefined) {
            if (!r) {
              r = a();
            } else if (Array.isArray(r)) {
              r = i(r);
            } else if (typeof r === 'string') {
              r = o(l(r));
            } else if (!c(r)) {
              r = o(r);
            }
          } else {
            if (r && !Array.isArray(r)) {
              if (typeof r === 'string') {
                r = l(r);
              }
              if (!c(r)) {
                r = o(r);
              }
            }
          }
        } else if (e.type === 'param') {
          if (typeof r === 'string') {
            r = l(r);
          }
          if (h === undefined) throw new Error('Assertion failure.');
        } else {
          if (typeof r === 'string') {
            r = l(r);
          }
          if (Array.isArray(r)) {
            throw new Error('Cannot replace single expression with an array.');
          }
        }
        if (h === undefined) {
          d(s, f, r);
          s[f] = r;
        } else {
          const t = s[f].slice();
          if (e.type === 'statement' || e.type === 'param') {
            if (r == null) {
              t.splice(h, 1);
            } else if (Array.isArray(r)) {
              t.splice(h, 1, ...r);
            } else {
              t[h] = r;
            }
          } else {
            t[h] = r;
          }
          d(s, f, t);
          s[f] = t;
        }
      }
    },
    5435: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = stringTemplate;
      var s = r(9541);
      var i = r(6340);
      var n = r(7839);
      function stringTemplate(e, t, r) {
        t = e.code(t);
        let a;
        return (o) => {
          const l = (0, s.normalizeReplacements)(o);
          if (!a) a = (0, i.default)(e, t, r);
          return e.unwrap((0, n.default)(a, l));
        };
      }
    },
    4632: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = assertNode;
      var s = r(6516);
      function assertNode(e) {
        if (!(0, s.default)(e)) {
          var t;
          const r =
            (t = e == null ? void 0 : e.type) != null ? t : JSON.stringify(e);
          throw new TypeError(`Not a valid node of type "${r}"`);
        }
      }
    },
    3701: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.assertAccessor = assertAccessor;
      t.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
      t.assertArgumentPlaceholder = assertArgumentPlaceholder;
      t.assertArrayExpression = assertArrayExpression;
      t.assertArrayPattern = assertArrayPattern;
      t.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
      t.assertArrowFunctionExpression = assertArrowFunctionExpression;
      t.assertAssignmentExpression = assertAssignmentExpression;
      t.assertAssignmentPattern = assertAssignmentPattern;
      t.assertAwaitExpression = assertAwaitExpression;
      t.assertBigIntLiteral = assertBigIntLiteral;
      t.assertBinary = assertBinary;
      t.assertBinaryExpression = assertBinaryExpression;
      t.assertBindExpression = assertBindExpression;
      t.assertBlock = assertBlock;
      t.assertBlockParent = assertBlockParent;
      t.assertBlockStatement = assertBlockStatement;
      t.assertBooleanLiteral = assertBooleanLiteral;
      t.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
      t.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
      t.assertBreakStatement = assertBreakStatement;
      t.assertCallExpression = assertCallExpression;
      t.assertCatchClause = assertCatchClause;
      t.assertClass = assertClass;
      t.assertClassAccessorProperty = assertClassAccessorProperty;
      t.assertClassBody = assertClassBody;
      t.assertClassDeclaration = assertClassDeclaration;
      t.assertClassExpression = assertClassExpression;
      t.assertClassImplements = assertClassImplements;
      t.assertClassMethod = assertClassMethod;
      t.assertClassPrivateMethod = assertClassPrivateMethod;
      t.assertClassPrivateProperty = assertClassPrivateProperty;
      t.assertClassProperty = assertClassProperty;
      t.assertCompletionStatement = assertCompletionStatement;
      t.assertConditional = assertConditional;
      t.assertConditionalExpression = assertConditionalExpression;
      t.assertContinueStatement = assertContinueStatement;
      t.assertDebuggerStatement = assertDebuggerStatement;
      t.assertDecimalLiteral = assertDecimalLiteral;
      t.assertDeclaration = assertDeclaration;
      t.assertDeclareClass = assertDeclareClass;
      t.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
      t.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
      t.assertDeclareFunction = assertDeclareFunction;
      t.assertDeclareInterface = assertDeclareInterface;
      t.assertDeclareModule = assertDeclareModule;
      t.assertDeclareModuleExports = assertDeclareModuleExports;
      t.assertDeclareOpaqueType = assertDeclareOpaqueType;
      t.assertDeclareTypeAlias = assertDeclareTypeAlias;
      t.assertDeclareVariable = assertDeclareVariable;
      t.assertDeclaredPredicate = assertDeclaredPredicate;
      t.assertDecorator = assertDecorator;
      t.assertDirective = assertDirective;
      t.assertDirectiveLiteral = assertDirectiveLiteral;
      t.assertDoExpression = assertDoExpression;
      t.assertDoWhileStatement = assertDoWhileStatement;
      t.assertEmptyStatement = assertEmptyStatement;
      t.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
      t.assertEnumBody = assertEnumBody;
      t.assertEnumBooleanBody = assertEnumBooleanBody;
      t.assertEnumBooleanMember = assertEnumBooleanMember;
      t.assertEnumDeclaration = assertEnumDeclaration;
      t.assertEnumDefaultedMember = assertEnumDefaultedMember;
      t.assertEnumMember = assertEnumMember;
      t.assertEnumNumberBody = assertEnumNumberBody;
      t.assertEnumNumberMember = assertEnumNumberMember;
      t.assertEnumStringBody = assertEnumStringBody;
      t.assertEnumStringMember = assertEnumStringMember;
      t.assertEnumSymbolBody = assertEnumSymbolBody;
      t.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
      t.assertExportAllDeclaration = assertExportAllDeclaration;
      t.assertExportDeclaration = assertExportDeclaration;
      t.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
      t.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
      t.assertExportNamedDeclaration = assertExportNamedDeclaration;
      t.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
      t.assertExportSpecifier = assertExportSpecifier;
      t.assertExpression = assertExpression;
      t.assertExpressionStatement = assertExpressionStatement;
      t.assertExpressionWrapper = assertExpressionWrapper;
      t.assertFile = assertFile;
      t.assertFlow = assertFlow;
      t.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
      t.assertFlowDeclaration = assertFlowDeclaration;
      t.assertFlowPredicate = assertFlowPredicate;
      t.assertFlowType = assertFlowType;
      t.assertFor = assertFor;
      t.assertForInStatement = assertForInStatement;
      t.assertForOfStatement = assertForOfStatement;
      t.assertForStatement = assertForStatement;
      t.assertForXStatement = assertForXStatement;
      t.assertFunction = assertFunction;
      t.assertFunctionDeclaration = assertFunctionDeclaration;
      t.assertFunctionExpression = assertFunctionExpression;
      t.assertFunctionParent = assertFunctionParent;
      t.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
      t.assertFunctionTypeParam = assertFunctionTypeParam;
      t.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
      t.assertIdentifier = assertIdentifier;
      t.assertIfStatement = assertIfStatement;
      t.assertImmutable = assertImmutable;
      t.assertImport = assertImport;
      t.assertImportAttribute = assertImportAttribute;
      t.assertImportDeclaration = assertImportDeclaration;
      t.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
      t.assertImportExpression = assertImportExpression;
      t.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
      t.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
      t.assertImportSpecifier = assertImportSpecifier;
      t.assertIndexedAccessType = assertIndexedAccessType;
      t.assertInferredPredicate = assertInferredPredicate;
      t.assertInterfaceDeclaration = assertInterfaceDeclaration;
      t.assertInterfaceExtends = assertInterfaceExtends;
      t.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
      t.assertInterpreterDirective = assertInterpreterDirective;
      t.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
      t.assertJSX = assertJSX;
      t.assertJSXAttribute = assertJSXAttribute;
      t.assertJSXClosingElement = assertJSXClosingElement;
      t.assertJSXClosingFragment = assertJSXClosingFragment;
      t.assertJSXElement = assertJSXElement;
      t.assertJSXEmptyExpression = assertJSXEmptyExpression;
      t.assertJSXExpressionContainer = assertJSXExpressionContainer;
      t.assertJSXFragment = assertJSXFragment;
      t.assertJSXIdentifier = assertJSXIdentifier;
      t.assertJSXMemberExpression = assertJSXMemberExpression;
      t.assertJSXNamespacedName = assertJSXNamespacedName;
      t.assertJSXOpeningElement = assertJSXOpeningElement;
      t.assertJSXOpeningFragment = assertJSXOpeningFragment;
      t.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
      t.assertJSXSpreadChild = assertJSXSpreadChild;
      t.assertJSXText = assertJSXText;
      t.assertLVal = assertLVal;
      t.assertLabeledStatement = assertLabeledStatement;
      t.assertLiteral = assertLiteral;
      t.assertLogicalExpression = assertLogicalExpression;
      t.assertLoop = assertLoop;
      t.assertMemberExpression = assertMemberExpression;
      t.assertMetaProperty = assertMetaProperty;
      t.assertMethod = assertMethod;
      t.assertMiscellaneous = assertMiscellaneous;
      t.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
      t.assertModuleDeclaration = assertModuleDeclaration;
      t.assertModuleExpression = assertModuleExpression;
      t.assertModuleSpecifier = assertModuleSpecifier;
      t.assertNewExpression = assertNewExpression;
      t.assertNoop = assertNoop;
      t.assertNullLiteral = assertNullLiteral;
      t.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
      t.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
      t.assertNumberLiteral = assertNumberLiteral;
      t.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
      t.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
      t.assertNumericLiteral = assertNumericLiteral;
      t.assertObjectExpression = assertObjectExpression;
      t.assertObjectMember = assertObjectMember;
      t.assertObjectMethod = assertObjectMethod;
      t.assertObjectPattern = assertObjectPattern;
      t.assertObjectProperty = assertObjectProperty;
      t.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
      t.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
      t.assertObjectTypeIndexer = assertObjectTypeIndexer;
      t.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
      t.assertObjectTypeProperty = assertObjectTypeProperty;
      t.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
      t.assertOpaqueType = assertOpaqueType;
      t.assertOptionalCallExpression = assertOptionalCallExpression;
      t.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
      t.assertOptionalMemberExpression = assertOptionalMemberExpression;
      t.assertParenthesizedExpression = assertParenthesizedExpression;
      t.assertPattern = assertPattern;
      t.assertPatternLike = assertPatternLike;
      t.assertPipelineBareFunction = assertPipelineBareFunction;
      t.assertPipelinePrimaryTopicReference =
        assertPipelinePrimaryTopicReference;
      t.assertPipelineTopicExpression = assertPipelineTopicExpression;
      t.assertPlaceholder = assertPlaceholder;
      t.assertPrivate = assertPrivate;
      t.assertPrivateName = assertPrivateName;
      t.assertProgram = assertProgram;
      t.assertProperty = assertProperty;
      t.assertPureish = assertPureish;
      t.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
      t.assertRecordExpression = assertRecordExpression;
      t.assertRegExpLiteral = assertRegExpLiteral;
      t.assertRegexLiteral = assertRegexLiteral;
      t.assertRestElement = assertRestElement;
      t.assertRestProperty = assertRestProperty;
      t.assertReturnStatement = assertReturnStatement;
      t.assertScopable = assertScopable;
      t.assertSequenceExpression = assertSequenceExpression;
      t.assertSpreadElement = assertSpreadElement;
      t.assertSpreadProperty = assertSpreadProperty;
      t.assertStandardized = assertStandardized;
      t.assertStatement = assertStatement;
      t.assertStaticBlock = assertStaticBlock;
      t.assertStringLiteral = assertStringLiteral;
      t.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
      t.assertStringTypeAnnotation = assertStringTypeAnnotation;
      t.assertSuper = assertSuper;
      t.assertSwitchCase = assertSwitchCase;
      t.assertSwitchStatement = assertSwitchStatement;
      t.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
      t.assertTSAnyKeyword = assertTSAnyKeyword;
      t.assertTSArrayType = assertTSArrayType;
      t.assertTSAsExpression = assertTSAsExpression;
      t.assertTSBaseType = assertTSBaseType;
      t.assertTSBigIntKeyword = assertTSBigIntKeyword;
      t.assertTSBooleanKeyword = assertTSBooleanKeyword;
      t.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
      t.assertTSConditionalType = assertTSConditionalType;
      t.assertTSConstructSignatureDeclaration =
        assertTSConstructSignatureDeclaration;
      t.assertTSConstructorType = assertTSConstructorType;
      t.assertTSDeclareFunction = assertTSDeclareFunction;
      t.assertTSDeclareMethod = assertTSDeclareMethod;
      t.assertTSEntityName = assertTSEntityName;
      t.assertTSEnumDeclaration = assertTSEnumDeclaration;
      t.assertTSEnumMember = assertTSEnumMember;
      t.assertTSExportAssignment = assertTSExportAssignment;
      t.assertTSExpressionWithTypeArguments =
        assertTSExpressionWithTypeArguments;
      t.assertTSExternalModuleReference = assertTSExternalModuleReference;
      t.assertTSFunctionType = assertTSFunctionType;
      t.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
      t.assertTSImportType = assertTSImportType;
      t.assertTSIndexSignature = assertTSIndexSignature;
      t.assertTSIndexedAccessType = assertTSIndexedAccessType;
      t.assertTSInferType = assertTSInferType;
      t.assertTSInstantiationExpression = assertTSInstantiationExpression;
      t.assertTSInterfaceBody = assertTSInterfaceBody;
      t.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
      t.assertTSIntersectionType = assertTSIntersectionType;
      t.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
      t.assertTSLiteralType = assertTSLiteralType;
      t.assertTSMappedType = assertTSMappedType;
      t.assertTSMethodSignature = assertTSMethodSignature;
      t.assertTSModuleBlock = assertTSModuleBlock;
      t.assertTSModuleDeclaration = assertTSModuleDeclaration;
      t.assertTSNamedTupleMember = assertTSNamedTupleMember;
      t.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
      t.assertTSNeverKeyword = assertTSNeverKeyword;
      t.assertTSNonNullExpression = assertTSNonNullExpression;
      t.assertTSNullKeyword = assertTSNullKeyword;
      t.assertTSNumberKeyword = assertTSNumberKeyword;
      t.assertTSObjectKeyword = assertTSObjectKeyword;
      t.assertTSOptionalType = assertTSOptionalType;
      t.assertTSParameterProperty = assertTSParameterProperty;
      t.assertTSParenthesizedType = assertTSParenthesizedType;
      t.assertTSPropertySignature = assertTSPropertySignature;
      t.assertTSQualifiedName = assertTSQualifiedName;
      t.assertTSRestType = assertTSRestType;
      t.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
      t.assertTSStringKeyword = assertTSStringKeyword;
      t.assertTSSymbolKeyword = assertTSSymbolKeyword;
      t.assertTSThisType = assertTSThisType;
      t.assertTSTupleType = assertTSTupleType;
      t.assertTSType = assertTSType;
      t.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
      t.assertTSTypeAnnotation = assertTSTypeAnnotation;
      t.assertTSTypeAssertion = assertTSTypeAssertion;
      t.assertTSTypeElement = assertTSTypeElement;
      t.assertTSTypeLiteral = assertTSTypeLiteral;
      t.assertTSTypeOperator = assertTSTypeOperator;
      t.assertTSTypeParameter = assertTSTypeParameter;
      t.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
      t.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
      t.assertTSTypePredicate = assertTSTypePredicate;
      t.assertTSTypeQuery = assertTSTypeQuery;
      t.assertTSTypeReference = assertTSTypeReference;
      t.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
      t.assertTSUnionType = assertTSUnionType;
      t.assertTSUnknownKeyword = assertTSUnknownKeyword;
      t.assertTSVoidKeyword = assertTSVoidKeyword;
      t.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
      t.assertTemplateElement = assertTemplateElement;
      t.assertTemplateLiteral = assertTemplateLiteral;
      t.assertTerminatorless = assertTerminatorless;
      t.assertThisExpression = assertThisExpression;
      t.assertThisTypeAnnotation = assertThisTypeAnnotation;
      t.assertThrowStatement = assertThrowStatement;
      t.assertTopicReference = assertTopicReference;
      t.assertTryStatement = assertTryStatement;
      t.assertTupleExpression = assertTupleExpression;
      t.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
      t.assertTypeAlias = assertTypeAlias;
      t.assertTypeAnnotation = assertTypeAnnotation;
      t.assertTypeCastExpression = assertTypeCastExpression;
      t.assertTypeParameter = assertTypeParameter;
      t.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
      t.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
      t.assertTypeScript = assertTypeScript;
      t.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
      t.assertUnaryExpression = assertUnaryExpression;
      t.assertUnaryLike = assertUnaryLike;
      t.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
      t.assertUpdateExpression = assertUpdateExpression;
      t.assertUserWhitespacable = assertUserWhitespacable;
      t.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
      t.assertVariableDeclaration = assertVariableDeclaration;
      t.assertVariableDeclarator = assertVariableDeclarator;
      t.assertVariance = assertVariance;
      t.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
      t.assertWhile = assertWhile;
      t.assertWhileStatement = assertWhileStatement;
      t.assertWithStatement = assertWithStatement;
      t.assertYieldExpression = assertYieldExpression;
      var s = r(3685);
      var i = r(8418);
      function assert(e, t, r) {
        if (!(0, s.default)(e, t, r)) {
          throw new Error(
            `Expected type "${e}" with option ${JSON.stringify(r)}, ` +
              `but instead got "${t.type}".`,
          );
        }
      }
      function assertArrayExpression(e, t) {
        assert('ArrayExpression', e, t);
      }
      function assertAssignmentExpression(e, t) {
        assert('AssignmentExpression', e, t);
      }
      function assertBinaryExpression(e, t) {
        assert('BinaryExpression', e, t);
      }
      function assertInterpreterDirective(e, t) {
        assert('InterpreterDirective', e, t);
      }
      function assertDirective(e, t) {
        assert('Directive', e, t);
      }
      function assertDirectiveLiteral(e, t) {
        assert('DirectiveLiteral', e, t);
      }
      function assertBlockStatement(e, t) {
        assert('BlockStatement', e, t);
      }
      function assertBreakStatement(e, t) {
        assert('BreakStatement', e, t);
      }
      function assertCallExpression(e, t) {
        assert('CallExpression', e, t);
      }
      function assertCatchClause(e, t) {
        assert('CatchClause', e, t);
      }
      function assertConditionalExpression(e, t) {
        assert('ConditionalExpression', e, t);
      }
      function assertContinueStatement(e, t) {
        assert('ContinueStatement', e, t);
      }
      function assertDebuggerStatement(e, t) {
        assert('DebuggerStatement', e, t);
      }
      function assertDoWhileStatement(e, t) {
        assert('DoWhileStatement', e, t);
      }
      function assertEmptyStatement(e, t) {
        assert('EmptyStatement', e, t);
      }
      function assertExpressionStatement(e, t) {
        assert('ExpressionStatement', e, t);
      }
      function assertFile(e, t) {
        assert('File', e, t);
      }
      function assertForInStatement(e, t) {
        assert('ForInStatement', e, t);
      }
      function assertForStatement(e, t) {
        assert('ForStatement', e, t);
      }
      function assertFunctionDeclaration(e, t) {
        assert('FunctionDeclaration', e, t);
      }
      function assertFunctionExpression(e, t) {
        assert('FunctionExpression', e, t);
      }
      function assertIdentifier(e, t) {
        assert('Identifier', e, t);
      }
      function assertIfStatement(e, t) {
        assert('IfStatement', e, t);
      }
      function assertLabeledStatement(e, t) {
        assert('LabeledStatement', e, t);
      }
      function assertStringLiteral(e, t) {
        assert('StringLiteral', e, t);
      }
      function assertNumericLiteral(e, t) {
        assert('NumericLiteral', e, t);
      }
      function assertNullLiteral(e, t) {
        assert('NullLiteral', e, t);
      }
      function assertBooleanLiteral(e, t) {
        assert('BooleanLiteral', e, t);
      }
      function assertRegExpLiteral(e, t) {
        assert('RegExpLiteral', e, t);
      }
      function assertLogicalExpression(e, t) {
        assert('LogicalExpression', e, t);
      }
      function assertMemberExpression(e, t) {
        assert('MemberExpression', e, t);
      }
      function assertNewExpression(e, t) {
        assert('NewExpression', e, t);
      }
      function assertProgram(e, t) {
        assert('Program', e, t);
      }
      function assertObjectExpression(e, t) {
        assert('ObjectExpression', e, t);
      }
      function assertObjectMethod(e, t) {
        assert('ObjectMethod', e, t);
      }
      function assertObjectProperty(e, t) {
        assert('ObjectProperty', e, t);
      }
      function assertRestElement(e, t) {
        assert('RestElement', e, t);
      }
      function assertReturnStatement(e, t) {
        assert('ReturnStatement', e, t);
      }
      function assertSequenceExpression(e, t) {
        assert('SequenceExpression', e, t);
      }
      function assertParenthesizedExpression(e, t) {
        assert('ParenthesizedExpression', e, t);
      }
      function assertSwitchCase(e, t) {
        assert('SwitchCase', e, t);
      }
      function assertSwitchStatement(e, t) {
        assert('SwitchStatement', e, t);
      }
      function assertThisExpression(e, t) {
        assert('ThisExpression', e, t);
      }
      function assertThrowStatement(e, t) {
        assert('ThrowStatement', e, t);
      }
      function assertTryStatement(e, t) {
        assert('TryStatement', e, t);
      }
      function assertUnaryExpression(e, t) {
        assert('UnaryExpression', e, t);
      }
      function assertUpdateExpression(e, t) {
        assert('UpdateExpression', e, t);
      }
      function assertVariableDeclaration(e, t) {
        assert('VariableDeclaration', e, t);
      }
      function assertVariableDeclarator(e, t) {
        assert('VariableDeclarator', e, t);
      }
      function assertWhileStatement(e, t) {
        assert('WhileStatement', e, t);
      }
      function assertWithStatement(e, t) {
        assert('WithStatement', e, t);
      }
      function assertAssignmentPattern(e, t) {
        assert('AssignmentPattern', e, t);
      }
      function assertArrayPattern(e, t) {
        assert('ArrayPattern', e, t);
      }
      function assertArrowFunctionExpression(e, t) {
        assert('ArrowFunctionExpression', e, t);
      }
      function assertClassBody(e, t) {
        assert('ClassBody', e, t);
      }
      function assertClassExpression(e, t) {
        assert('ClassExpression', e, t);
      }
      function assertClassDeclaration(e, t) {
        assert('ClassDeclaration', e, t);
      }
      function assertExportAllDeclaration(e, t) {
        assert('ExportAllDeclaration', e, t);
      }
      function assertExportDefaultDeclaration(e, t) {
        assert('ExportDefaultDeclaration', e, t);
      }
      function assertExportNamedDeclaration(e, t) {
        assert('ExportNamedDeclaration', e, t);
      }
      function assertExportSpecifier(e, t) {
        assert('ExportSpecifier', e, t);
      }
      function assertForOfStatement(e, t) {
        assert('ForOfStatement', e, t);
      }
      function assertImportDeclaration(e, t) {
        assert('ImportDeclaration', e, t);
      }
      function assertImportDefaultSpecifier(e, t) {
        assert('ImportDefaultSpecifier', e, t);
      }
      function assertImportNamespaceSpecifier(e, t) {
        assert('ImportNamespaceSpecifier', e, t);
      }
      function assertImportSpecifier(e, t) {
        assert('ImportSpecifier', e, t);
      }
      function assertImportExpression(e, t) {
        assert('ImportExpression', e, t);
      }
      function assertMetaProperty(e, t) {
        assert('MetaProperty', e, t);
      }
      function assertClassMethod(e, t) {
        assert('ClassMethod', e, t);
      }
      function assertObjectPattern(e, t) {
        assert('ObjectPattern', e, t);
      }
      function assertSpreadElement(e, t) {
        assert('SpreadElement', e, t);
      }
      function assertSuper(e, t) {
        assert('Super', e, t);
      }
      function assertTaggedTemplateExpression(e, t) {
        assert('TaggedTemplateExpression', e, t);
      }
      function assertTemplateElement(e, t) {
        assert('TemplateElement', e, t);
      }
      function assertTemplateLiteral(e, t) {
        assert('TemplateLiteral', e, t);
      }
      function assertYieldExpression(e, t) {
        assert('YieldExpression', e, t);
      }
      function assertAwaitExpression(e, t) {
        assert('AwaitExpression', e, t);
      }
      function assertImport(e, t) {
        assert('Import', e, t);
      }
      function assertBigIntLiteral(e, t) {
        assert('BigIntLiteral', e, t);
      }
      function assertExportNamespaceSpecifier(e, t) {
        assert('ExportNamespaceSpecifier', e, t);
      }
      function assertOptionalMemberExpression(e, t) {
        assert('OptionalMemberExpression', e, t);
      }
      function assertOptionalCallExpression(e, t) {
        assert('OptionalCallExpression', e, t);
      }
      function assertClassProperty(e, t) {
        assert('ClassProperty', e, t);
      }
      function assertClassAccessorProperty(e, t) {
        assert('ClassAccessorProperty', e, t);
      }
      function assertClassPrivateProperty(e, t) {
        assert('ClassPrivateProperty', e, t);
      }
      function assertClassPrivateMethod(e, t) {
        assert('ClassPrivateMethod', e, t);
      }
      function assertPrivateName(e, t) {
        assert('PrivateName', e, t);
      }
      function assertStaticBlock(e, t) {
        assert('StaticBlock', e, t);
      }
      function assertAnyTypeAnnotation(e, t) {
        assert('AnyTypeAnnotation', e, t);
      }
      function assertArrayTypeAnnotation(e, t) {
        assert('ArrayTypeAnnotation', e, t);
      }
      function assertBooleanTypeAnnotation(e, t) {
        assert('BooleanTypeAnnotation', e, t);
      }
      function assertBooleanLiteralTypeAnnotation(e, t) {
        assert('BooleanLiteralTypeAnnotation', e, t);
      }
      function assertNullLiteralTypeAnnotation(e, t) {
        assert('NullLiteralTypeAnnotation', e, t);
      }
      function assertClassImplements(e, t) {
        assert('ClassImplements', e, t);
      }
      function assertDeclareClass(e, t) {
        assert('DeclareClass', e, t);
      }
      function assertDeclareFunction(e, t) {
        assert('DeclareFunction', e, t);
      }
      function assertDeclareInterface(e, t) {
        assert('DeclareInterface', e, t);
      }
      function assertDeclareModule(e, t) {
        assert('DeclareModule', e, t);
      }
      function assertDeclareModuleExports(e, t) {
        assert('DeclareModuleExports', e, t);
      }
      function assertDeclareTypeAlias(e, t) {
        assert('DeclareTypeAlias', e, t);
      }
      function assertDeclareOpaqueType(e, t) {
        assert('DeclareOpaqueType', e, t);
      }
      function assertDeclareVariable(e, t) {
        assert('DeclareVariable', e, t);
      }
      function assertDeclareExportDeclaration(e, t) {
        assert('DeclareExportDeclaration', e, t);
      }
      function assertDeclareExportAllDeclaration(e, t) {
        assert('DeclareExportAllDeclaration', e, t);
      }
      function assertDeclaredPredicate(e, t) {
        assert('DeclaredPredicate', e, t);
      }
      function assertExistsTypeAnnotation(e, t) {
        assert('ExistsTypeAnnotation', e, t);
      }
      function assertFunctionTypeAnnotation(e, t) {
        assert('FunctionTypeAnnotation', e, t);
      }
      function assertFunctionTypeParam(e, t) {
        assert('FunctionTypeParam', e, t);
      }
      function assertGenericTypeAnnotation(e, t) {
        assert('GenericTypeAnnotation', e, t);
      }
      function assertInferredPredicate(e, t) {
        assert('InferredPredicate', e, t);
      }
      function assertInterfaceExtends(e, t) {
        assert('InterfaceExtends', e, t);
      }
      function assertInterfaceDeclaration(e, t) {
        assert('InterfaceDeclaration', e, t);
      }
      function assertInterfaceTypeAnnotation(e, t) {
        assert('InterfaceTypeAnnotation', e, t);
      }
      function assertIntersectionTypeAnnotation(e, t) {
        assert('IntersectionTypeAnnotation', e, t);
      }
      function assertMixedTypeAnnotation(e, t) {
        assert('MixedTypeAnnotation', e, t);
      }
      function assertEmptyTypeAnnotation(e, t) {
        assert('EmptyTypeAnnotation', e, t);
      }
      function assertNullableTypeAnnotation(e, t) {
        assert('NullableTypeAnnotation', e, t);
      }
      function assertNumberLiteralTypeAnnotation(e, t) {
        assert('NumberLiteralTypeAnnotation', e, t);
      }
      function assertNumberTypeAnnotation(e, t) {
        assert('NumberTypeAnnotation', e, t);
      }
      function assertObjectTypeAnnotation(e, t) {
        assert('ObjectTypeAnnotation', e, t);
      }
      function assertObjectTypeInternalSlot(e, t) {
        assert('ObjectTypeInternalSlot', e, t);
      }
      function assertObjectTypeCallProperty(e, t) {
        assert('ObjectTypeCallProperty', e, t);
      }
      function assertObjectTypeIndexer(e, t) {
        assert('ObjectTypeIndexer', e, t);
      }
      function assertObjectTypeProperty(e, t) {
        assert('ObjectTypeProperty', e, t);
      }
      function assertObjectTypeSpreadProperty(e, t) {
        assert('ObjectTypeSpreadProperty', e, t);
      }
      function assertOpaqueType(e, t) {
        assert('OpaqueType', e, t);
      }
      function assertQualifiedTypeIdentifier(e, t) {
        assert('QualifiedTypeIdentifier', e, t);
      }
      function assertStringLiteralTypeAnnotation(e, t) {
        assert('StringLiteralTypeAnnotation', e, t);
      }
      function assertStringTypeAnnotation(e, t) {
        assert('StringTypeAnnotation', e, t);
      }
      function assertSymbolTypeAnnotation(e, t) {
        assert('SymbolTypeAnnotation', e, t);
      }
      function assertThisTypeAnnotation(e, t) {
        assert('ThisTypeAnnotation', e, t);
      }
      function assertTupleTypeAnnotation(e, t) {
        assert('TupleTypeAnnotation', e, t);
      }
      function assertTypeofTypeAnnotation(e, t) {
        assert('TypeofTypeAnnotation', e, t);
      }
      function assertTypeAlias(e, t) {
        assert('TypeAlias', e, t);
      }
      function assertTypeAnnotation(e, t) {
        assert('TypeAnnotation', e, t);
      }
      function assertTypeCastExpression(e, t) {
        assert('TypeCastExpression', e, t);
      }
      function assertTypeParameter(e, t) {
        assert('TypeParameter', e, t);
      }
      function assertTypeParameterDeclaration(e, t) {
        assert('TypeParameterDeclaration', e, t);
      }
      function assertTypeParameterInstantiation(e, t) {
        assert('TypeParameterInstantiation', e, t);
      }
      function assertUnionTypeAnnotation(e, t) {
        assert('UnionTypeAnnotation', e, t);
      }
      function assertVariance(e, t) {
        assert('Variance', e, t);
      }
      function assertVoidTypeAnnotation(e, t) {
        assert('VoidTypeAnnotation', e, t);
      }
      function assertEnumDeclaration(e, t) {
        assert('EnumDeclaration', e, t);
      }
      function assertEnumBooleanBody(e, t) {
        assert('EnumBooleanBody', e, t);
      }
      function assertEnumNumberBody(e, t) {
        assert('EnumNumberBody', e, t);
      }
      function assertEnumStringBody(e, t) {
        assert('EnumStringBody', e, t);
      }
      function assertEnumSymbolBody(e, t) {
        assert('EnumSymbolBody', e, t);
      }
      function assertEnumBooleanMember(e, t) {
        assert('EnumBooleanMember', e, t);
      }
      function assertEnumNumberMember(e, t) {
        assert('EnumNumberMember', e, t);
      }
      function assertEnumStringMember(e, t) {
        assert('EnumStringMember', e, t);
      }
      function assertEnumDefaultedMember(e, t) {
        assert('EnumDefaultedMember', e, t);
      }
      function assertIndexedAccessType(e, t) {
        assert('IndexedAccessType', e, t);
      }
      function assertOptionalIndexedAccessType(e, t) {
        assert('OptionalIndexedAccessType', e, t);
      }
      function assertJSXAttribute(e, t) {
        assert('JSXAttribute', e, t);
      }
      function assertJSXClosingElement(e, t) {
        assert('JSXClosingElement', e, t);
      }
      function assertJSXElement(e, t) {
        assert('JSXElement', e, t);
      }
      function assertJSXEmptyExpression(e, t) {
        assert('JSXEmptyExpression', e, t);
      }
      function assertJSXExpressionContainer(e, t) {
        assert('JSXExpressionContainer', e, t);
      }
      function assertJSXSpreadChild(e, t) {
        assert('JSXSpreadChild', e, t);
      }
      function assertJSXIdentifier(e, t) {
        assert('JSXIdentifier', e, t);
      }
      function assertJSXMemberExpression(e, t) {
        assert('JSXMemberExpression', e, t);
      }
      function assertJSXNamespacedName(e, t) {
        assert('JSXNamespacedName', e, t);
      }
      function assertJSXOpeningElement(e, t) {
        assert('JSXOpeningElement', e, t);
      }
      function assertJSXSpreadAttribute(e, t) {
        assert('JSXSpreadAttribute', e, t);
      }
      function assertJSXText(e, t) {
        assert('JSXText', e, t);
      }
      function assertJSXFragment(e, t) {
        assert('JSXFragment', e, t);
      }
      function assertJSXOpeningFragment(e, t) {
        assert('JSXOpeningFragment', e, t);
      }
      function assertJSXClosingFragment(e, t) {
        assert('JSXClosingFragment', e, t);
      }
      function assertNoop(e, t) {
        assert('Noop', e, t);
      }
      function assertPlaceholder(e, t) {
        assert('Placeholder', e, t);
      }
      function assertV8IntrinsicIdentifier(e, t) {
        assert('V8IntrinsicIdentifier', e, t);
      }
      function assertArgumentPlaceholder(e, t) {
        assert('ArgumentPlaceholder', e, t);
      }
      function assertBindExpression(e, t) {
        assert('BindExpression', e, t);
      }
      function assertImportAttribute(e, t) {
        assert('ImportAttribute', e, t);
      }
      function assertDecorator(e, t) {
        assert('Decorator', e, t);
      }
      function assertDoExpression(e, t) {
        assert('DoExpression', e, t);
      }
      function assertExportDefaultSpecifier(e, t) {
        assert('ExportDefaultSpecifier', e, t);
      }
      function assertRecordExpression(e, t) {
        assert('RecordExpression', e, t);
      }
      function assertTupleExpression(e, t) {
        assert('TupleExpression', e, t);
      }
      function assertDecimalLiteral(e, t) {
        assert('DecimalLiteral', e, t);
      }
      function assertModuleExpression(e, t) {
        assert('ModuleExpression', e, t);
      }
      function assertTopicReference(e, t) {
        assert('TopicReference', e, t);
      }
      function assertPipelineTopicExpression(e, t) {
        assert('PipelineTopicExpression', e, t);
      }
      function assertPipelineBareFunction(e, t) {
        assert('PipelineBareFunction', e, t);
      }
      function assertPipelinePrimaryTopicReference(e, t) {
        assert('PipelinePrimaryTopicReference', e, t);
      }
      function assertTSParameterProperty(e, t) {
        assert('TSParameterProperty', e, t);
      }
      function assertTSDeclareFunction(e, t) {
        assert('TSDeclareFunction', e, t);
      }
      function assertTSDeclareMethod(e, t) {
        assert('TSDeclareMethod', e, t);
      }
      function assertTSQualifiedName(e, t) {
        assert('TSQualifiedName', e, t);
      }
      function assertTSCallSignatureDeclaration(e, t) {
        assert('TSCallSignatureDeclaration', e, t);
      }
      function assertTSConstructSignatureDeclaration(e, t) {
        assert('TSConstructSignatureDeclaration', e, t);
      }
      function assertTSPropertySignature(e, t) {
        assert('TSPropertySignature', e, t);
      }
      function assertTSMethodSignature(e, t) {
        assert('TSMethodSignature', e, t);
      }
      function assertTSIndexSignature(e, t) {
        assert('TSIndexSignature', e, t);
      }
      function assertTSAnyKeyword(e, t) {
        assert('TSAnyKeyword', e, t);
      }
      function assertTSBooleanKeyword(e, t) {
        assert('TSBooleanKeyword', e, t);
      }
      function assertTSBigIntKeyword(e, t) {
        assert('TSBigIntKeyword', e, t);
      }
      function assertTSIntrinsicKeyword(e, t) {
        assert('TSIntrinsicKeyword', e, t);
      }
      function assertTSNeverKeyword(e, t) {
        assert('TSNeverKeyword', e, t);
      }
      function assertTSNullKeyword(e, t) {
        assert('TSNullKeyword', e, t);
      }
      function assertTSNumberKeyword(e, t) {
        assert('TSNumberKeyword', e, t);
      }
      function assertTSObjectKeyword(e, t) {
        assert('TSObjectKeyword', e, t);
      }
      function assertTSStringKeyword(e, t) {
        assert('TSStringKeyword', e, t);
      }
      function assertTSSymbolKeyword(e, t) {
        assert('TSSymbolKeyword', e, t);
      }
      function assertTSUndefinedKeyword(e, t) {
        assert('TSUndefinedKeyword', e, t);
      }
      function assertTSUnknownKeyword(e, t) {
        assert('TSUnknownKeyword', e, t);
      }
      function assertTSVoidKeyword(e, t) {
        assert('TSVoidKeyword', e, t);
      }
      function assertTSThisType(e, t) {
        assert('TSThisType', e, t);
      }
      function assertTSFunctionType(e, t) {
        assert('TSFunctionType', e, t);
      }
      function assertTSConstructorType(e, t) {
        assert('TSConstructorType', e, t);
      }
      function assertTSTypeReference(e, t) {
        assert('TSTypeReference', e, t);
      }
      function assertTSTypePredicate(e, t) {
        assert('TSTypePredicate', e, t);
      }
      function assertTSTypeQuery(e, t) {
        assert('TSTypeQuery', e, t);
      }
      function assertTSTypeLiteral(e, t) {
        assert('TSTypeLiteral', e, t);
      }
      function assertTSArrayType(e, t) {
        assert('TSArrayType', e, t);
      }
      function assertTSTupleType(e, t) {
        assert('TSTupleType', e, t);
      }
      function assertTSOptionalType(e, t) {
        assert('TSOptionalType', e, t);
      }
      function assertTSRestType(e, t) {
        assert('TSRestType', e, t);
      }
      function assertTSNamedTupleMember(e, t) {
        assert('TSNamedTupleMember', e, t);
      }
      function assertTSUnionType(e, t) {
        assert('TSUnionType', e, t);
      }
      function assertTSIntersectionType(e, t) {
        assert('TSIntersectionType', e, t);
      }
      function assertTSConditionalType(e, t) {
        assert('TSConditionalType', e, t);
      }
      function assertTSInferType(e, t) {
        assert('TSInferType', e, t);
      }
      function assertTSParenthesizedType(e, t) {
        assert('TSParenthesizedType', e, t);
      }
      function assertTSTypeOperator(e, t) {
        assert('TSTypeOperator', e, t);
      }
      function assertTSIndexedAccessType(e, t) {
        assert('TSIndexedAccessType', e, t);
      }
      function assertTSMappedType(e, t) {
        assert('TSMappedType', e, t);
      }
      function assertTSLiteralType(e, t) {
        assert('TSLiteralType', e, t);
      }
      function assertTSExpressionWithTypeArguments(e, t) {
        assert('TSExpressionWithTypeArguments', e, t);
      }
      function assertTSInterfaceDeclaration(e, t) {
        assert('TSInterfaceDeclaration', e, t);
      }
      function assertTSInterfaceBody(e, t) {
        assert('TSInterfaceBody', e, t);
      }
      function assertTSTypeAliasDeclaration(e, t) {
        assert('TSTypeAliasDeclaration', e, t);
      }
      function assertTSInstantiationExpression(e, t) {
        assert('TSInstantiationExpression', e, t);
      }
      function assertTSAsExpression(e, t) {
        assert('TSAsExpression', e, t);
      }
      function assertTSSatisfiesExpression(e, t) {
        assert('TSSatisfiesExpression', e, t);
      }
      function assertTSTypeAssertion(e, t) {
        assert('TSTypeAssertion', e, t);
      }
      function assertTSEnumDeclaration(e, t) {
        assert('TSEnumDeclaration', e, t);
      }
      function assertTSEnumMember(e, t) {
        assert('TSEnumMember', e, t);
      }
      function assertTSModuleDeclaration(e, t) {
        assert('TSModuleDeclaration', e, t);
      }
      function assertTSModuleBlock(e, t) {
        assert('TSModuleBlock', e, t);
      }
      function assertTSImportType(e, t) {
        assert('TSImportType', e, t);
      }
      function assertTSImportEqualsDeclaration(e, t) {
        assert('TSImportEqualsDeclaration', e, t);
      }
      function assertTSExternalModuleReference(e, t) {
        assert('TSExternalModuleReference', e, t);
      }
      function assertTSNonNullExpression(e, t) {
        assert('TSNonNullExpression', e, t);
      }
      function assertTSExportAssignment(e, t) {
        assert('TSExportAssignment', e, t);
      }
      function assertTSNamespaceExportDeclaration(e, t) {
        assert('TSNamespaceExportDeclaration', e, t);
      }
      function assertTSTypeAnnotation(e, t) {
        assert('TSTypeAnnotation', e, t);
      }
      function assertTSTypeParameterInstantiation(e, t) {
        assert('TSTypeParameterInstantiation', e, t);
      }
      function assertTSTypeParameterDeclaration(e, t) {
        assert('TSTypeParameterDeclaration', e, t);
      }
      function assertTSTypeParameter(e, t) {
        assert('TSTypeParameter', e, t);
      }
      function assertStandardized(e, t) {
        assert('Standardized', e, t);
      }
      function assertExpression(e, t) {
        assert('Expression', e, t);
      }
      function assertBinary(e, t) {
        assert('Binary', e, t);
      }
      function assertScopable(e, t) {
        assert('Scopable', e, t);
      }
      function assertBlockParent(e, t) {
        assert('BlockParent', e, t);
      }
      function assertBlock(e, t) {
        assert('Block', e, t);
      }
      function assertStatement(e, t) {
        assert('Statement', e, t);
      }
      function assertTerminatorless(e, t) {
        assert('Terminatorless', e, t);
      }
      function assertCompletionStatement(e, t) {
        assert('CompletionStatement', e, t);
      }
      function assertConditional(e, t) {
        assert('Conditional', e, t);
      }
      function assertLoop(e, t) {
        assert('Loop', e, t);
      }
      function assertWhile(e, t) {
        assert('While', e, t);
      }
      function assertExpressionWrapper(e, t) {
        assert('ExpressionWrapper', e, t);
      }
      function assertFor(e, t) {
        assert('For', e, t);
      }
      function assertForXStatement(e, t) {
        assert('ForXStatement', e, t);
      }
      function assertFunction(e, t) {
        assert('Function', e, t);
      }
      function assertFunctionParent(e, t) {
        assert('FunctionParent', e, t);
      }
      function assertPureish(e, t) {
        assert('Pureish', e, t);
      }
      function assertDeclaration(e, t) {
        assert('Declaration', e, t);
      }
      function assertPatternLike(e, t) {
        assert('PatternLike', e, t);
      }
      function assertLVal(e, t) {
        assert('LVal', e, t);
      }
      function assertTSEntityName(e, t) {
        assert('TSEntityName', e, t);
      }
      function assertLiteral(e, t) {
        assert('Literal', e, t);
      }
      function assertImmutable(e, t) {
        assert('Immutable', e, t);
      }
      function assertUserWhitespacable(e, t) {
        assert('UserWhitespacable', e, t);
      }
      function assertMethod(e, t) {
        assert('Method', e, t);
      }
      function assertObjectMember(e, t) {
        assert('ObjectMember', e, t);
      }
      function assertProperty(e, t) {
        assert('Property', e, t);
      }
      function assertUnaryLike(e, t) {
        assert('UnaryLike', e, t);
      }
      function assertPattern(e, t) {
        assert('Pattern', e, t);
      }
      function assertClass(e, t) {
        assert('Class', e, t);
      }
      function assertImportOrExportDeclaration(e, t) {
        assert('ImportOrExportDeclaration', e, t);
      }
      function assertExportDeclaration(e, t) {
        assert('ExportDeclaration', e, t);
      }
      function assertModuleSpecifier(e, t) {
        assert('ModuleSpecifier', e, t);
      }
      function assertAccessor(e, t) {
        assert('Accessor', e, t);
      }
      function assertPrivate(e, t) {
        assert('Private', e, t);
      }
      function assertFlow(e, t) {
        assert('Flow', e, t);
      }
      function assertFlowType(e, t) {
        assert('FlowType', e, t);
      }
      function assertFlowBaseAnnotation(e, t) {
        assert('FlowBaseAnnotation', e, t);
      }
      function assertFlowDeclaration(e, t) {
        assert('FlowDeclaration', e, t);
      }
      function assertFlowPredicate(e, t) {
        assert('FlowPredicate', e, t);
      }
      function assertEnumBody(e, t) {
        assert('EnumBody', e, t);
      }
      function assertEnumMember(e, t) {
        assert('EnumMember', e, t);
      }
      function assertJSX(e, t) {
        assert('JSX', e, t);
      }
      function assertMiscellaneous(e, t) {
        assert('Miscellaneous', e, t);
      }
      function assertTypeScript(e, t) {
        assert('TypeScript', e, t);
      }
      function assertTSTypeElement(e, t) {
        assert('TSTypeElement', e, t);
      }
      function assertTSType(e, t) {
        assert('TSType', e, t);
      }
      function assertTSBaseType(e, t) {
        assert('TSBaseType', e, t);
      }
      function assertNumberLiteral(e, t) {
        (0, i.default)('assertNumberLiteral', 'assertNumericLiteral');
        assert('NumberLiteral', e, t);
      }
      function assertRegexLiteral(e, t) {
        (0, i.default)('assertRegexLiteral', 'assertRegExpLiteral');
        assert('RegexLiteral', e, t);
      }
      function assertRestProperty(e, t) {
        (0, i.default)('assertRestProperty', 'assertRestElement');
        assert('RestProperty', e, t);
      }
      function assertSpreadProperty(e, t) {
        (0, i.default)('assertSpreadProperty', 'assertSpreadElement');
        assert('SpreadProperty', e, t);
      }
      function assertModuleDeclaration(e, t) {
        (0, i.default)(
          'assertModuleDeclaration',
          'assertImportOrExportDeclaration',
        );
        assert('ModuleDeclaration', e, t);
      }
    },
    2814: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = createFlowUnionType;
      var s = r(397);
      var i = r(3864);
      function createFlowUnionType(e) {
        const t = (0, i.default)(e);
        if (t.length === 1) {
          return t[0];
        } else {
          return (0, s.unionTypeAnnotation)(t);
        }
      }
    },
    8276: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = void 0;
      var s = r(397);
      var i = (t['default'] = createTypeAnnotationBasedOnTypeof);
      function createTypeAnnotationBasedOnTypeof(e) {
        switch (e) {
          case 'string':
            return (0, s.stringTypeAnnotation)();
          case 'number':
            return (0, s.numberTypeAnnotation)();
          case 'undefined':
            return (0, s.voidTypeAnnotation)();
          case 'boolean':
            return (0, s.booleanTypeAnnotation)();
          case 'function':
            return (0, s.genericTypeAnnotation)((0, s.identifier)('Function'));
          case 'object':
            return (0, s.genericTypeAnnotation)((0, s.identifier)('Object'));
          case 'symbol':
            return (0, s.genericTypeAnnotation)((0, s.identifier)('Symbol'));
          case 'bigint':
            return (0, s.anyTypeAnnotation)();
        }
        throw new Error('Invalid typeof value: ' + e);
      }
    },
    397: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.anyTypeAnnotation = anyTypeAnnotation;
      t.argumentPlaceholder = argumentPlaceholder;
      t.arrayExpression = arrayExpression;
      t.arrayPattern = arrayPattern;
      t.arrayTypeAnnotation = arrayTypeAnnotation;
      t.arrowFunctionExpression = arrowFunctionExpression;
      t.assignmentExpression = assignmentExpression;
      t.assignmentPattern = assignmentPattern;
      t.awaitExpression = awaitExpression;
      t.bigIntLiteral = bigIntLiteral;
      t.binaryExpression = binaryExpression;
      t.bindExpression = bindExpression;
      t.blockStatement = blockStatement;
      t.booleanLiteral = booleanLiteral;
      t.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
      t.booleanTypeAnnotation = booleanTypeAnnotation;
      t.breakStatement = breakStatement;
      t.callExpression = callExpression;
      t.catchClause = catchClause;
      t.classAccessorProperty = classAccessorProperty;
      t.classBody = classBody;
      t.classDeclaration = classDeclaration;
      t.classExpression = classExpression;
      t.classImplements = classImplements;
      t.classMethod = classMethod;
      t.classPrivateMethod = classPrivateMethod;
      t.classPrivateProperty = classPrivateProperty;
      t.classProperty = classProperty;
      t.conditionalExpression = conditionalExpression;
      t.continueStatement = continueStatement;
      t.debuggerStatement = debuggerStatement;
      t.decimalLiteral = decimalLiteral;
      t.declareClass = declareClass;
      t.declareExportAllDeclaration = declareExportAllDeclaration;
      t.declareExportDeclaration = declareExportDeclaration;
      t.declareFunction = declareFunction;
      t.declareInterface = declareInterface;
      t.declareModule = declareModule;
      t.declareModuleExports = declareModuleExports;
      t.declareOpaqueType = declareOpaqueType;
      t.declareTypeAlias = declareTypeAlias;
      t.declareVariable = declareVariable;
      t.declaredPredicate = declaredPredicate;
      t.decorator = decorator;
      t.directive = directive;
      t.directiveLiteral = directiveLiteral;
      t.doExpression = doExpression;
      t.doWhileStatement = doWhileStatement;
      t.emptyStatement = emptyStatement;
      t.emptyTypeAnnotation = emptyTypeAnnotation;
      t.enumBooleanBody = enumBooleanBody;
      t.enumBooleanMember = enumBooleanMember;
      t.enumDeclaration = enumDeclaration;
      t.enumDefaultedMember = enumDefaultedMember;
      t.enumNumberBody = enumNumberBody;
      t.enumNumberMember = enumNumberMember;
      t.enumStringBody = enumStringBody;
      t.enumStringMember = enumStringMember;
      t.enumSymbolBody = enumSymbolBody;
      t.existsTypeAnnotation = existsTypeAnnotation;
      t.exportAllDeclaration = exportAllDeclaration;
      t.exportDefaultDeclaration = exportDefaultDeclaration;
      t.exportDefaultSpecifier = exportDefaultSpecifier;
      t.exportNamedDeclaration = exportNamedDeclaration;
      t.exportNamespaceSpecifier = exportNamespaceSpecifier;
      t.exportSpecifier = exportSpecifier;
      t.expressionStatement = expressionStatement;
      t.file = file;
      t.forInStatement = forInStatement;
      t.forOfStatement = forOfStatement;
      t.forStatement = forStatement;
      t.functionDeclaration = functionDeclaration;
      t.functionExpression = functionExpression;
      t.functionTypeAnnotation = functionTypeAnnotation;
      t.functionTypeParam = functionTypeParam;
      t.genericTypeAnnotation = genericTypeAnnotation;
      t.identifier = identifier;
      t.ifStatement = ifStatement;
      t['import'] = _import;
      t.importAttribute = importAttribute;
      t.importDeclaration = importDeclaration;
      t.importDefaultSpecifier = importDefaultSpecifier;
      t.importExpression = importExpression;
      t.importNamespaceSpecifier = importNamespaceSpecifier;
      t.importSpecifier = importSpecifier;
      t.indexedAccessType = indexedAccessType;
      t.inferredPredicate = inferredPredicate;
      t.interfaceDeclaration = interfaceDeclaration;
      t.interfaceExtends = interfaceExtends;
      t.interfaceTypeAnnotation = interfaceTypeAnnotation;
      t.interpreterDirective = interpreterDirective;
      t.intersectionTypeAnnotation = intersectionTypeAnnotation;
      t.jSXAttribute = t.jsxAttribute = jsxAttribute;
      t.jSXClosingElement = t.jsxClosingElement = jsxClosingElement;
      t.jSXClosingFragment = t.jsxClosingFragment = jsxClosingFragment;
      t.jSXElement = t.jsxElement = jsxElement;
      t.jSXEmptyExpression = t.jsxEmptyExpression = jsxEmptyExpression;
      t.jSXExpressionContainer = t.jsxExpressionContainer =
        jsxExpressionContainer;
      t.jSXFragment = t.jsxFragment = jsxFragment;
      t.jSXIdentifier = t.jsxIdentifier = jsxIdentifier;
      t.jSXMemberExpression = t.jsxMemberExpression = jsxMemberExpression;
      t.jSXNamespacedName = t.jsxNamespacedName = jsxNamespacedName;
      t.jSXOpeningElement = t.jsxOpeningElement = jsxOpeningElement;
      t.jSXOpeningFragment = t.jsxOpeningFragment = jsxOpeningFragment;
      t.jSXSpreadAttribute = t.jsxSpreadAttribute = jsxSpreadAttribute;
      t.jSXSpreadChild = t.jsxSpreadChild = jsxSpreadChild;
      t.jSXText = t.jsxText = jsxText;
      t.labeledStatement = labeledStatement;
      t.logicalExpression = logicalExpression;
      t.memberExpression = memberExpression;
      t.metaProperty = metaProperty;
      t.mixedTypeAnnotation = mixedTypeAnnotation;
      t.moduleExpression = moduleExpression;
      t.newExpression = newExpression;
      t.noop = noop;
      t.nullLiteral = nullLiteral;
      t.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
      t.nullableTypeAnnotation = nullableTypeAnnotation;
      t.numberLiteral = NumberLiteral;
      t.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
      t.numberTypeAnnotation = numberTypeAnnotation;
      t.numericLiteral = numericLiteral;
      t.objectExpression = objectExpression;
      t.objectMethod = objectMethod;
      t.objectPattern = objectPattern;
      t.objectProperty = objectProperty;
      t.objectTypeAnnotation = objectTypeAnnotation;
      t.objectTypeCallProperty = objectTypeCallProperty;
      t.objectTypeIndexer = objectTypeIndexer;
      t.objectTypeInternalSlot = objectTypeInternalSlot;
      t.objectTypeProperty = objectTypeProperty;
      t.objectTypeSpreadProperty = objectTypeSpreadProperty;
      t.opaqueType = opaqueType;
      t.optionalCallExpression = optionalCallExpression;
      t.optionalIndexedAccessType = optionalIndexedAccessType;
      t.optionalMemberExpression = optionalMemberExpression;
      t.parenthesizedExpression = parenthesizedExpression;
      t.pipelineBareFunction = pipelineBareFunction;
      t.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
      t.pipelineTopicExpression = pipelineTopicExpression;
      t.placeholder = placeholder;
      t.privateName = privateName;
      t.program = program;
      t.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
      t.recordExpression = recordExpression;
      t.regExpLiteral = regExpLiteral;
      t.regexLiteral = RegexLiteral;
      t.restElement = restElement;
      t.restProperty = RestProperty;
      t.returnStatement = returnStatement;
      t.sequenceExpression = sequenceExpression;
      t.spreadElement = spreadElement;
      t.spreadProperty = SpreadProperty;
      t.staticBlock = staticBlock;
      t.stringLiteral = stringLiteral;
      t.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
      t.stringTypeAnnotation = stringTypeAnnotation;
      t['super'] = _super;
      t.switchCase = switchCase;
      t.switchStatement = switchStatement;
      t.symbolTypeAnnotation = symbolTypeAnnotation;
      t.taggedTemplateExpression = taggedTemplateExpression;
      t.templateElement = templateElement;
      t.templateLiteral = templateLiteral;
      t.thisExpression = thisExpression;
      t.thisTypeAnnotation = thisTypeAnnotation;
      t.throwStatement = throwStatement;
      t.topicReference = topicReference;
      t.tryStatement = tryStatement;
      t.tSAnyKeyword = t.tsAnyKeyword = tsAnyKeyword;
      t.tSArrayType = t.tsArrayType = tsArrayType;
      t.tSAsExpression = t.tsAsExpression = tsAsExpression;
      t.tSBigIntKeyword = t.tsBigIntKeyword = tsBigIntKeyword;
      t.tSBooleanKeyword = t.tsBooleanKeyword = tsBooleanKeyword;
      t.tSCallSignatureDeclaration = t.tsCallSignatureDeclaration =
        tsCallSignatureDeclaration;
      t.tSConditionalType = t.tsConditionalType = tsConditionalType;
      t.tSConstructSignatureDeclaration = t.tsConstructSignatureDeclaration =
        tsConstructSignatureDeclaration;
      t.tSConstructorType = t.tsConstructorType = tsConstructorType;
      t.tSDeclareFunction = t.tsDeclareFunction = tsDeclareFunction;
      t.tSDeclareMethod = t.tsDeclareMethod = tsDeclareMethod;
      t.tSEnumDeclaration = t.tsEnumDeclaration = tsEnumDeclaration;
      t.tSEnumMember = t.tsEnumMember = tsEnumMember;
      t.tSExportAssignment = t.tsExportAssignment = tsExportAssignment;
      t.tSExpressionWithTypeArguments = t.tsExpressionWithTypeArguments =
        tsExpressionWithTypeArguments;
      t.tSExternalModuleReference = t.tsExternalModuleReference =
        tsExternalModuleReference;
      t.tSFunctionType = t.tsFunctionType = tsFunctionType;
      t.tSImportEqualsDeclaration = t.tsImportEqualsDeclaration =
        tsImportEqualsDeclaration;
      t.tSImportType = t.tsImportType = tsImportType;
      t.tSIndexSignature = t.tsIndexSignature = tsIndexSignature;
      t.tSIndexedAccessType = t.tsIndexedAccessType = tsIndexedAccessType;
      t.tSInferType = t.tsInferType = tsInferType;
      t.tSInstantiationExpression = t.tsInstantiationExpression =
        tsInstantiationExpression;
      t.tSInterfaceBody = t.tsInterfaceBody = tsInterfaceBody;
      t.tSInterfaceDeclaration = t.tsInterfaceDeclaration =
        tsInterfaceDeclaration;
      t.tSIntersectionType = t.tsIntersectionType = tsIntersectionType;
      t.tSIntrinsicKeyword = t.tsIntrinsicKeyword = tsIntrinsicKeyword;
      t.tSLiteralType = t.tsLiteralType = tsLiteralType;
      t.tSMappedType = t.tsMappedType = tsMappedType;
      t.tSMethodSignature = t.tsMethodSignature = tsMethodSignature;
      t.tSModuleBlock = t.tsModuleBlock = tsModuleBlock;
      t.tSModuleDeclaration = t.tsModuleDeclaration = tsModuleDeclaration;
      t.tSNamedTupleMember = t.tsNamedTupleMember = tsNamedTupleMember;
      t.tSNamespaceExportDeclaration = t.tsNamespaceExportDeclaration =
        tsNamespaceExportDeclaration;
      t.tSNeverKeyword = t.tsNeverKeyword = tsNeverKeyword;
      t.tSNonNullExpression = t.tsNonNullExpression = tsNonNullExpression;
      t.tSNullKeyword = t.tsNullKeyword = tsNullKeyword;
      t.tSNumberKeyword = t.tsNumberKeyword = tsNumberKeyword;
      t.tSObjectKeyword = t.tsObjectKeyword = tsObjectKeyword;
      t.tSOptionalType = t.tsOptionalType = tsOptionalType;
      t.tSParameterProperty = t.tsParameterProperty = tsParameterProperty;
      t.tSParenthesizedType = t.tsParenthesizedType = tsParenthesizedType;
      t.tSPropertySignature = t.tsPropertySignature = tsPropertySignature;
      t.tSQualifiedName = t.tsQualifiedName = tsQualifiedName;
      t.tSRestType = t.tsRestType = tsRestType;
      t.tSSatisfiesExpression = t.tsSatisfiesExpression = tsSatisfiesExpression;
      t.tSStringKeyword = t.tsStringKeyword = tsStringKeyword;
      t.tSSymbolKeyword = t.tsSymbolKeyword = tsSymbolKeyword;
      t.tSThisType = t.tsThisType = tsThisType;
      t.tSTupleType = t.tsTupleType = tsTupleType;
      t.tSTypeAliasDeclaration = t.tsTypeAliasDeclaration =
        tsTypeAliasDeclaration;
      t.tSTypeAnnotation = t.tsTypeAnnotation = tsTypeAnnotation;
      t.tSTypeAssertion = t.tsTypeAssertion = tsTypeAssertion;
      t.tSTypeLiteral = t.tsTypeLiteral = tsTypeLiteral;
      t.tSTypeOperator = t.tsTypeOperator = tsTypeOperator;
      t.tSTypeParameter = t.tsTypeParameter = tsTypeParameter;
      t.tSTypeParameterDeclaration = t.tsTypeParameterDeclaration =
        tsTypeParameterDeclaration;
      t.tSTypeParameterInstantiation = t.tsTypeParameterInstantiation =
        tsTypeParameterInstantiation;
      t.tSTypePredicate = t.tsTypePredicate = tsTypePredicate;
      t.tSTypeQuery = t.tsTypeQuery = tsTypeQuery;
      t.tSTypeReference = t.tsTypeReference = tsTypeReference;
      t.tSUndefinedKeyword = t.tsUndefinedKeyword = tsUndefinedKeyword;
      t.tSUnionType = t.tsUnionType = tsUnionType;
      t.tSUnknownKeyword = t.tsUnknownKeyword = tsUnknownKeyword;
      t.tSVoidKeyword = t.tsVoidKeyword = tsVoidKeyword;
      t.tupleExpression = tupleExpression;
      t.tupleTypeAnnotation = tupleTypeAnnotation;
      t.typeAlias = typeAlias;
      t.typeAnnotation = typeAnnotation;
      t.typeCastExpression = typeCastExpression;
      t.typeParameter = typeParameter;
      t.typeParameterDeclaration = typeParameterDeclaration;
      t.typeParameterInstantiation = typeParameterInstantiation;
      t.typeofTypeAnnotation = typeofTypeAnnotation;
      t.unaryExpression = unaryExpression;
      t.unionTypeAnnotation = unionTypeAnnotation;
      t.updateExpression = updateExpression;
      t.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
      t.variableDeclaration = variableDeclaration;
      t.variableDeclarator = variableDeclarator;
      t.variance = variance;
      t.voidTypeAnnotation = voidTypeAnnotation;
      t.whileStatement = whileStatement;
      t.withStatement = withStatement;
      t.yieldExpression = yieldExpression;
      var s = r(9836);
      var i = r(8418);
      function arrayExpression(e = []) {
        return (0, s.default)({ type: 'ArrayExpression', elements: e });
      }
      function assignmentExpression(e, t, r) {
        return (0, s.default)({
          type: 'AssignmentExpression',
          operator: e,
          left: t,
          right: r,
        });
      }
      function binaryExpression(e, t, r) {
        return (0, s.default)({
          type: 'BinaryExpression',
          operator: e,
          left: t,
          right: r,
        });
      }
      function interpreterDirective(e) {
        return (0, s.default)({ type: 'InterpreterDirective', value: e });
      }
      function directive(e) {
        return (0, s.default)({ type: 'Directive', value: e });
      }
      function directiveLiteral(e) {
        return (0, s.default)({ type: 'DirectiveLiteral', value: e });
      }
      function blockStatement(e, t = []) {
        return (0, s.default)({
          type: 'BlockStatement',
          body: e,
          directives: t,
        });
      }
      function breakStatement(e = null) {
        return (0, s.default)({ type: 'BreakStatement', label: e });
      }
      function callExpression(e, t) {
        return (0, s.default)({
          type: 'CallExpression',
          callee: e,
          arguments: t,
        });
      }
      function catchClause(e = null, t) {
        return (0, s.default)({ type: 'CatchClause', param: e, body: t });
      }
      function conditionalExpression(e, t, r) {
        return (0, s.default)({
          type: 'ConditionalExpression',
          test: e,
          consequent: t,
          alternate: r,
        });
      }
      function continueStatement(e = null) {
        return (0, s.default)({ type: 'ContinueStatement', label: e });
      }
      function debuggerStatement() {
        return { type: 'DebuggerStatement' };
      }
      function doWhileStatement(e, t) {
        return (0, s.default)({ type: 'DoWhileStatement', test: e, body: t });
      }
      function emptyStatement() {
        return { type: 'EmptyStatement' };
      }
      function expressionStatement(e) {
        return (0, s.default)({ type: 'ExpressionStatement', expression: e });
      }
      function file(e, t = null, r = null) {
        return (0, s.default)({
          type: 'File',
          program: e,
          comments: t,
          tokens: r,
        });
      }
      function forInStatement(e, t, r) {
        return (0, s.default)({
          type: 'ForInStatement',
          left: e,
          right: t,
          body: r,
        });
      }
      function forStatement(e = null, t = null, r = null, i) {
        return (0, s.default)({
          type: 'ForStatement',
          init: e,
          test: t,
          update: r,
          body: i,
        });
      }
      function functionDeclaration(e = null, t, r, i = false, n = false) {
        return (0, s.default)({
          type: 'FunctionDeclaration',
          id: e,
          params: t,
          body: r,
          generator: i,
          async: n,
        });
      }
      function functionExpression(e = null, t, r, i = false, n = false) {
        return (0, s.default)({
          type: 'FunctionExpression',
          id: e,
          params: t,
          body: r,
          generator: i,
          async: n,
        });
      }
      function identifier(e) {
        return (0, s.default)({ type: 'Identifier', name: e });
      }
      function ifStatement(e, t, r = null) {
        return (0, s.default)({
          type: 'IfStatement',
          test: e,
          consequent: t,
          alternate: r,
        });
      }
      function labeledStatement(e, t) {
        return (0, s.default)({ type: 'LabeledStatement', label: e, body: t });
      }
      function stringLiteral(e) {
        return (0, s.default)({ type: 'StringLiteral', value: e });
      }
      function numericLiteral(e) {
        return (0, s.default)({ type: 'NumericLiteral', value: e });
      }
      function nullLiteral() {
        return { type: 'NullLiteral' };
      }
      function booleanLiteral(e) {
        return (0, s.default)({ type: 'BooleanLiteral', value: e });
      }
      function regExpLiteral(e, t = '') {
        return (0, s.default)({ type: 'RegExpLiteral', pattern: e, flags: t });
      }
      function logicalExpression(e, t, r) {
        return (0, s.default)({
          type: 'LogicalExpression',
          operator: e,
          left: t,
          right: r,
        });
      }
      function memberExpression(e, t, r = false, i = null) {
        return (0, s.default)({
          type: 'MemberExpression',
          object: e,
          property: t,
          computed: r,
          optional: i,
        });
      }
      function newExpression(e, t) {
        return (0, s.default)({
          type: 'NewExpression',
          callee: e,
          arguments: t,
        });
      }
      function program(e, t = [], r = 'script', i = null) {
        return (0, s.default)({
          type: 'Program',
          body: e,
          directives: t,
          sourceType: r,
          interpreter: i,
          sourceFile: null,
        });
      }
      function objectExpression(e) {
        return (0, s.default)({ type: 'ObjectExpression', properties: e });
      }
      function objectMethod(
        e = 'method',
        t,
        r,
        i,
        n = false,
        a = false,
        o = false,
      ) {
        return (0, s.default)({
          type: 'ObjectMethod',
          kind: e,
          key: t,
          params: r,
          body: i,
          computed: n,
          generator: a,
          async: o,
        });
      }
      function objectProperty(e, t, r = false, i = false, n = null) {
        return (0, s.default)({
          type: 'ObjectProperty',
          key: e,
          value: t,
          computed: r,
          shorthand: i,
          decorators: n,
        });
      }
      function restElement(e) {
        return (0, s.default)({ type: 'RestElement', argument: e });
      }
      function returnStatement(e = null) {
        return (0, s.default)({ type: 'ReturnStatement', argument: e });
      }
      function sequenceExpression(e) {
        return (0, s.default)({ type: 'SequenceExpression', expressions: e });
      }
      function parenthesizedExpression(e) {
        return (0, s.default)({
          type: 'ParenthesizedExpression',
          expression: e,
        });
      }
      function switchCase(e = null, t) {
        return (0, s.default)({ type: 'SwitchCase', test: e, consequent: t });
      }
      function switchStatement(e, t) {
        return (0, s.default)({
          type: 'SwitchStatement',
          discriminant: e,
          cases: t,
        });
      }
      function thisExpression() {
        return { type: 'ThisExpression' };
      }
      function throwStatement(e) {
        return (0, s.default)({ type: 'ThrowStatement', argument: e });
      }
      function tryStatement(e, t = null, r = null) {
        return (0, s.default)({
          type: 'TryStatement',
          block: e,
          handler: t,
          finalizer: r,
        });
      }
      function unaryExpression(e, t, r = true) {
        return (0, s.default)({
          type: 'UnaryExpression',
          operator: e,
          argument: t,
          prefix: r,
        });
      }
      function updateExpression(e, t, r = false) {
        return (0, s.default)({
          type: 'UpdateExpression',
          operator: e,
          argument: t,
          prefix: r,
        });
      }
      function variableDeclaration(e, t) {
        return (0, s.default)({
          type: 'VariableDeclaration',
          kind: e,
          declarations: t,
        });
      }
      function variableDeclarator(e, t = null) {
        return (0, s.default)({ type: 'VariableDeclarator', id: e, init: t });
      }
      function whileStatement(e, t) {
        return (0, s.default)({ type: 'WhileStatement', test: e, body: t });
      }
      function withStatement(e, t) {
        return (0, s.default)({ type: 'WithStatement', object: e, body: t });
      }
      function assignmentPattern(e, t) {
        return (0, s.default)({ type: 'AssignmentPattern', left: e, right: t });
      }
      function arrayPattern(e) {
        return (0, s.default)({ type: 'ArrayPattern', elements: e });
      }
      function arrowFunctionExpression(e, t, r = false) {
        return (0, s.default)({
          type: 'ArrowFunctionExpression',
          params: e,
          body: t,
          async: r,
          expression: null,
        });
      }
      function classBody(e) {
        return (0, s.default)({ type: 'ClassBody', body: e });
      }
      function classExpression(e = null, t = null, r, i = null) {
        return (0, s.default)({
          type: 'ClassExpression',
          id: e,
          superClass: t,
          body: r,
          decorators: i,
        });
      }
      function classDeclaration(e = null, t = null, r, i = null) {
        return (0, s.default)({
          type: 'ClassDeclaration',
          id: e,
          superClass: t,
          body: r,
          decorators: i,
        });
      }
      function exportAllDeclaration(e) {
        return (0, s.default)({ type: 'ExportAllDeclaration', source: e });
      }
      function exportDefaultDeclaration(e) {
        return (0, s.default)({
          type: 'ExportDefaultDeclaration',
          declaration: e,
        });
      }
      function exportNamedDeclaration(e = null, t = [], r = null) {
        return (0, s.default)({
          type: 'ExportNamedDeclaration',
          declaration: e,
          specifiers: t,
          source: r,
        });
      }
      function exportSpecifier(e, t) {
        return (0, s.default)({
          type: 'ExportSpecifier',
          local: e,
          exported: t,
        });
      }
      function forOfStatement(e, t, r, i = false) {
        return (0, s.default)({
          type: 'ForOfStatement',
          left: e,
          right: t,
          body: r,
          await: i,
        });
      }
      function importDeclaration(e, t) {
        return (0, s.default)({
          type: 'ImportDeclaration',
          specifiers: e,
          source: t,
        });
      }
      function importDefaultSpecifier(e) {
        return (0, s.default)({ type: 'ImportDefaultSpecifier', local: e });
      }
      function importNamespaceSpecifier(e) {
        return (0, s.default)({ type: 'ImportNamespaceSpecifier', local: e });
      }
      function importSpecifier(e, t) {
        return (0, s.default)({
          type: 'ImportSpecifier',
          local: e,
          imported: t,
        });
      }
      function importExpression(e, t = null) {
        return (0, s.default)({
          type: 'ImportExpression',
          source: e,
          options: t,
        });
      }
      function metaProperty(e, t) {
        return (0, s.default)({ type: 'MetaProperty', meta: e, property: t });
      }
      function classMethod(
        e = 'method',
        t,
        r,
        i,
        n = false,
        a = false,
        o = false,
        l = false,
      ) {
        return (0, s.default)({
          type: 'ClassMethod',
          kind: e,
          key: t,
          params: r,
          body: i,
          computed: n,
          static: a,
          generator: o,
          async: l,
        });
      }
      function objectPattern(e) {
        return (0, s.default)({ type: 'ObjectPattern', properties: e });
      }
      function spreadElement(e) {
        return (0, s.default)({ type: 'SpreadElement', argument: e });
      }
      function _super() {
        return { type: 'Super' };
      }
      function taggedTemplateExpression(e, t) {
        return (0, s.default)({
          type: 'TaggedTemplateExpression',
          tag: e,
          quasi: t,
        });
      }
      function templateElement(e, t = false) {
        return (0, s.default)({ type: 'TemplateElement', value: e, tail: t });
      }
      function templateLiteral(e, t) {
        return (0, s.default)({
          type: 'TemplateLiteral',
          quasis: e,
          expressions: t,
        });
      }
      function yieldExpression(e = null, t = false) {
        return (0, s.default)({
          type: 'YieldExpression',
          argument: e,
          delegate: t,
        });
      }
      function awaitExpression(e) {
        return (0, s.default)({ type: 'AwaitExpression', argument: e });
      }
      function _import() {
        return { type: 'Import' };
      }
      function bigIntLiteral(e) {
        return (0, s.default)({ type: 'BigIntLiteral', value: e });
      }
      function exportNamespaceSpecifier(e) {
        return (0, s.default)({
          type: 'ExportNamespaceSpecifier',
          exported: e,
        });
      }
      function optionalMemberExpression(e, t, r = false, i) {
        return (0, s.default)({
          type: 'OptionalMemberExpression',
          object: e,
          property: t,
          computed: r,
          optional: i,
        });
      }
      function optionalCallExpression(e, t, r) {
        return (0, s.default)({
          type: 'OptionalCallExpression',
          callee: e,
          arguments: t,
          optional: r,
        });
      }
      function classProperty(
        e,
        t = null,
        r = null,
        i = null,
        n = false,
        a = false,
      ) {
        return (0, s.default)({
          type: 'ClassProperty',
          key: e,
          value: t,
          typeAnnotation: r,
          decorators: i,
          computed: n,
          static: a,
        });
      }
      function classAccessorProperty(
        e,
        t = null,
        r = null,
        i = null,
        n = false,
        a = false,
      ) {
        return (0, s.default)({
          type: 'ClassAccessorProperty',
          key: e,
          value: t,
          typeAnnotation: r,
          decorators: i,
          computed: n,
          static: a,
        });
      }
      function classPrivateProperty(e, t = null, r = null, i = false) {
        return (0, s.default)({
          type: 'ClassPrivateProperty',
          key: e,
          value: t,
          decorators: r,
          static: i,
        });
      }
      function classPrivateMethod(e = 'method', t, r, i, n = false) {
        return (0, s.default)({
          type: 'ClassPrivateMethod',
          kind: e,
          key: t,
          params: r,
          body: i,
          static: n,
        });
      }
      function privateName(e) {
        return (0, s.default)({ type: 'PrivateName', id: e });
      }
      function staticBlock(e) {
        return (0, s.default)({ type: 'StaticBlock', body: e });
      }
      function anyTypeAnnotation() {
        return { type: 'AnyTypeAnnotation' };
      }
      function arrayTypeAnnotation(e) {
        return (0, s.default)({ type: 'ArrayTypeAnnotation', elementType: e });
      }
      function booleanTypeAnnotation() {
        return { type: 'BooleanTypeAnnotation' };
      }
      function booleanLiteralTypeAnnotation(e) {
        return (0, s.default)({
          type: 'BooleanLiteralTypeAnnotation',
          value: e,
        });
      }
      function nullLiteralTypeAnnotation() {
        return { type: 'NullLiteralTypeAnnotation' };
      }
      function classImplements(e, t = null) {
        return (0, s.default)({
          type: 'ClassImplements',
          id: e,
          typeParameters: t,
        });
      }
      function declareClass(e, t = null, r = null, i) {
        return (0, s.default)({
          type: 'DeclareClass',
          id: e,
          typeParameters: t,
          extends: r,
          body: i,
        });
      }
      function declareFunction(e) {
        return (0, s.default)({ type: 'DeclareFunction', id: e });
      }
      function declareInterface(e, t = null, r = null, i) {
        return (0, s.default)({
          type: 'DeclareInterface',
          id: e,
          typeParameters: t,
          extends: r,
          body: i,
        });
      }
      function declareModule(e, t, r = null) {
        return (0, s.default)({
          type: 'DeclareModule',
          id: e,
          body: t,
          kind: r,
        });
      }
      function declareModuleExports(e) {
        return (0, s.default)({
          type: 'DeclareModuleExports',
          typeAnnotation: e,
        });
      }
      function declareTypeAlias(e, t = null, r) {
        return (0, s.default)({
          type: 'DeclareTypeAlias',
          id: e,
          typeParameters: t,
          right: r,
        });
      }
      function declareOpaqueType(e, t = null, r = null) {
        return (0, s.default)({
          type: 'DeclareOpaqueType',
          id: e,
          typeParameters: t,
          supertype: r,
        });
      }
      function declareVariable(e) {
        return (0, s.default)({ type: 'DeclareVariable', id: e });
      }
      function declareExportDeclaration(e = null, t = null, r = null) {
        return (0, s.default)({
          type: 'DeclareExportDeclaration',
          declaration: e,
          specifiers: t,
          source: r,
        });
      }
      function declareExportAllDeclaration(e) {
        return (0, s.default)({
          type: 'DeclareExportAllDeclaration',
          source: e,
        });
      }
      function declaredPredicate(e) {
        return (0, s.default)({ type: 'DeclaredPredicate', value: e });
      }
      function existsTypeAnnotation() {
        return { type: 'ExistsTypeAnnotation' };
      }
      function functionTypeAnnotation(e = null, t, r = null, i) {
        return (0, s.default)({
          type: 'FunctionTypeAnnotation',
          typeParameters: e,
          params: t,
          rest: r,
          returnType: i,
        });
      }
      function functionTypeParam(e = null, t) {
        return (0, s.default)({
          type: 'FunctionTypeParam',
          name: e,
          typeAnnotation: t,
        });
      }
      function genericTypeAnnotation(e, t = null) {
        return (0, s.default)({
          type: 'GenericTypeAnnotation',
          id: e,
          typeParameters: t,
        });
      }
      function inferredPredicate() {
        return { type: 'InferredPredicate' };
      }
      function interfaceExtends(e, t = null) {
        return (0, s.default)({
          type: 'InterfaceExtends',
          id: e,
          typeParameters: t,
        });
      }
      function interfaceDeclaration(e, t = null, r = null, i) {
        return (0, s.default)({
          type: 'InterfaceDeclaration',
          id: e,
          typeParameters: t,
          extends: r,
          body: i,
        });
      }
      function interfaceTypeAnnotation(e = null, t) {
        return (0, s.default)({
          type: 'InterfaceTypeAnnotation',
          extends: e,
          body: t,
        });
      }
      function intersectionTypeAnnotation(e) {
        return (0, s.default)({ type: 'IntersectionTypeAnnotation', types: e });
      }
      function mixedTypeAnnotation() {
        return { type: 'MixedTypeAnnotation' };
      }
      function emptyTypeAnnotation() {
        return { type: 'EmptyTypeAnnotation' };
      }
      function nullableTypeAnnotation(e) {
        return (0, s.default)({
          type: 'NullableTypeAnnotation',
          typeAnnotation: e,
        });
      }
      function numberLiteralTypeAnnotation(e) {
        return (0, s.default)({
          type: 'NumberLiteralTypeAnnotation',
          value: e,
        });
      }
      function numberTypeAnnotation() {
        return { type: 'NumberTypeAnnotation' };
      }
      function objectTypeAnnotation(e, t = [], r = [], i = [], n = false) {
        return (0, s.default)({
          type: 'ObjectTypeAnnotation',
          properties: e,
          indexers: t,
          callProperties: r,
          internalSlots: i,
          exact: n,
        });
      }
      function objectTypeInternalSlot(e, t, r, i, n) {
        return (0, s.default)({
          type: 'ObjectTypeInternalSlot',
          id: e,
          value: t,
          optional: r,
          static: i,
          method: n,
        });
      }
      function objectTypeCallProperty(e) {
        return (0, s.default)({
          type: 'ObjectTypeCallProperty',
          value: e,
          static: null,
        });
      }
      function objectTypeIndexer(e = null, t, r, i = null) {
        return (0, s.default)({
          type: 'ObjectTypeIndexer',
          id: e,
          key: t,
          value: r,
          variance: i,
          static: null,
        });
      }
      function objectTypeProperty(e, t, r = null) {
        return (0, s.default)({
          type: 'ObjectTypeProperty',
          key: e,
          value: t,
          variance: r,
          kind: null,
          method: null,
          optional: null,
          proto: null,
          static: null,
        });
      }
      function objectTypeSpreadProperty(e) {
        return (0, s.default)({
          type: 'ObjectTypeSpreadProperty',
          argument: e,
        });
      }
      function opaqueType(e, t = null, r = null, i) {
        return (0, s.default)({
          type: 'OpaqueType',
          id: e,
          typeParameters: t,
          supertype: r,
          impltype: i,
        });
      }
      function qualifiedTypeIdentifier(e, t) {
        return (0, s.default)({
          type: 'QualifiedTypeIdentifier',
          id: e,
          qualification: t,
        });
      }
      function stringLiteralTypeAnnotation(e) {
        return (0, s.default)({
          type: 'StringLiteralTypeAnnotation',
          value: e,
        });
      }
      function stringTypeAnnotation() {
        return { type: 'StringTypeAnnotation' };
      }
      function symbolTypeAnnotation() {
        return { type: 'SymbolTypeAnnotation' };
      }
      function thisTypeAnnotation() {
        return { type: 'ThisTypeAnnotation' };
      }
      function tupleTypeAnnotation(e) {
        return (0, s.default)({ type: 'TupleTypeAnnotation', types: e });
      }
      function typeofTypeAnnotation(e) {
        return (0, s.default)({ type: 'TypeofTypeAnnotation', argument: e });
      }
      function typeAlias(e, t = null, r) {
        return (0, s.default)({
          type: 'TypeAlias',
          id: e,
          typeParameters: t,
          right: r,
        });
      }
      function typeAnnotation(e) {
        return (0, s.default)({ type: 'TypeAnnotation', typeAnnotation: e });
      }
      function typeCastExpression(e, t) {
        return (0, s.default)({
          type: 'TypeCastExpression',
          expression: e,
          typeAnnotation: t,
        });
      }
      function typeParameter(e = null, t = null, r = null) {
        return (0, s.default)({
          type: 'TypeParameter',
          bound: e,
          default: t,
          variance: r,
          name: null,
        });
      }
      function typeParameterDeclaration(e) {
        return (0, s.default)({ type: 'TypeParameterDeclaration', params: e });
      }
      function typeParameterInstantiation(e) {
        return (0, s.default)({
          type: 'TypeParameterInstantiation',
          params: e,
        });
      }
      function unionTypeAnnotation(e) {
        return (0, s.default)({ type: 'UnionTypeAnnotation', types: e });
      }
      function variance(e) {
        return (0, s.default)({ type: 'Variance', kind: e });
      }
      function voidTypeAnnotation() {
        return { type: 'VoidTypeAnnotation' };
      }
      function enumDeclaration(e, t) {
        return (0, s.default)({ type: 'EnumDeclaration', id: e, body: t });
      }
      function enumBooleanBody(e) {
        return (0, s.default)({
          type: 'EnumBooleanBody',
          members: e,
          explicitType: null,
          hasUnknownMembers: null,
        });
      }
      function enumNumberBody(e) {
        return (0, s.default)({
          type: 'EnumNumberBody',
          members: e,
          explicitType: null,
          hasUnknownMembers: null,
        });
      }
      function enumStringBody(e) {
        return (0, s.default)({
          type: 'EnumStringBody',
          members: e,
          explicitType: null,
          hasUnknownMembers: null,
        });
      }
      function enumSymbolBody(e) {
        return (0, s.default)({
          type: 'EnumSymbolBody',
          members: e,
          hasUnknownMembers: null,
        });
      }
      function enumBooleanMember(e) {
        return (0, s.default)({ type: 'EnumBooleanMember', id: e, init: null });
      }
      function enumNumberMember(e, t) {
        return (0, s.default)({ type: 'EnumNumberMember', id: e, init: t });
      }
      function enumStringMember(e, t) {
        return (0, s.default)({ type: 'EnumStringMember', id: e, init: t });
      }
      function enumDefaultedMember(e) {
        return (0, s.default)({ type: 'EnumDefaultedMember', id: e });
      }
      function indexedAccessType(e, t) {
        return (0, s.default)({
          type: 'IndexedAccessType',
          objectType: e,
          indexType: t,
        });
      }
      function optionalIndexedAccessType(e, t) {
        return (0, s.default)({
          type: 'OptionalIndexedAccessType',
          objectType: e,
          indexType: t,
          optional: null,
        });
      }
      function jsxAttribute(e, t = null) {
        return (0, s.default)({ type: 'JSXAttribute', name: e, value: t });
      }
      function jsxClosingElement(e) {
        return (0, s.default)({ type: 'JSXClosingElement', name: e });
      }
      function jsxElement(e, t = null, r, i = null) {
        return (0, s.default)({
          type: 'JSXElement',
          openingElement: e,
          closingElement: t,
          children: r,
          selfClosing: i,
        });
      }
      function jsxEmptyExpression() {
        return { type: 'JSXEmptyExpression' };
      }
      function jsxExpressionContainer(e) {
        return (0, s.default)({
          type: 'JSXExpressionContainer',
          expression: e,
        });
      }
      function jsxSpreadChild(e) {
        return (0, s.default)({ type: 'JSXSpreadChild', expression: e });
      }
      function jsxIdentifier(e) {
        return (0, s.default)({ type: 'JSXIdentifier', name: e });
      }
      function jsxMemberExpression(e, t) {
        return (0, s.default)({
          type: 'JSXMemberExpression',
          object: e,
          property: t,
        });
      }
      function jsxNamespacedName(e, t) {
        return (0, s.default)({
          type: 'JSXNamespacedName',
          namespace: e,
          name: t,
        });
      }
      function jsxOpeningElement(e, t, r = false) {
        return (0, s.default)({
          type: 'JSXOpeningElement',
          name: e,
          attributes: t,
          selfClosing: r,
        });
      }
      function jsxSpreadAttribute(e) {
        return (0, s.default)({ type: 'JSXSpreadAttribute', argument: e });
      }
      function jsxText(e) {
        return (0, s.default)({ type: 'JSXText', value: e });
      }
      function jsxFragment(e, t, r) {
        return (0, s.default)({
          type: 'JSXFragment',
          openingFragment: e,
          closingFragment: t,
          children: r,
        });
      }
      function jsxOpeningFragment() {
        return { type: 'JSXOpeningFragment' };
      }
      function jsxClosingFragment() {
        return { type: 'JSXClosingFragment' };
      }
      function noop() {
        return { type: 'Noop' };
      }
      function placeholder(e, t) {
        return (0, s.default)({
          type: 'Placeholder',
          expectedNode: e,
          name: t,
        });
      }
      function v8IntrinsicIdentifier(e) {
        return (0, s.default)({ type: 'V8IntrinsicIdentifier', name: e });
      }
      function argumentPlaceholder() {
        return { type: 'ArgumentPlaceholder' };
      }
      function bindExpression(e, t) {
        return (0, s.default)({ type: 'BindExpression', object: e, callee: t });
      }
      function importAttribute(e, t) {
        return (0, s.default)({ type: 'ImportAttribute', key: e, value: t });
      }
      function decorator(e) {
        return (0, s.default)({ type: 'Decorator', expression: e });
      }
      function doExpression(e, t = false) {
        return (0, s.default)({ type: 'DoExpression', body: e, async: t });
      }
      function exportDefaultSpecifier(e) {
        return (0, s.default)({ type: 'ExportDefaultSpecifier', exported: e });
      }
      function recordExpression(e) {
        return (0, s.default)({ type: 'RecordExpression', properties: e });
      }
      function tupleExpression(e = []) {
        return (0, s.default)({ type: 'TupleExpression', elements: e });
      }
      function decimalLiteral(e) {
        return (0, s.default)({ type: 'DecimalLiteral', value: e });
      }
      function moduleExpression(e) {
        return (0, s.default)({ type: 'ModuleExpression', body: e });
      }
      function topicReference() {
        return { type: 'TopicReference' };
      }
      function pipelineTopicExpression(e) {
        return (0, s.default)({
          type: 'PipelineTopicExpression',
          expression: e,
        });
      }
      function pipelineBareFunction(e) {
        return (0, s.default)({ type: 'PipelineBareFunction', callee: e });
      }
      function pipelinePrimaryTopicReference() {
        return { type: 'PipelinePrimaryTopicReference' };
      }
      function tsParameterProperty(e) {
        return (0, s.default)({ type: 'TSParameterProperty', parameter: e });
      }
      function tsDeclareFunction(e = null, t = null, r, i = null) {
        return (0, s.default)({
          type: 'TSDeclareFunction',
          id: e,
          typeParameters: t,
          params: r,
          returnType: i,
        });
      }
      function tsDeclareMethod(e = null, t, r = null, i, n = null) {
        return (0, s.default)({
          type: 'TSDeclareMethod',
          decorators: e,
          key: t,
          typeParameters: r,
          params: i,
          returnType: n,
        });
      }
      function tsQualifiedName(e, t) {
        return (0, s.default)({ type: 'TSQualifiedName', left: e, right: t });
      }
      function tsCallSignatureDeclaration(e = null, t, r = null) {
        return (0, s.default)({
          type: 'TSCallSignatureDeclaration',
          typeParameters: e,
          parameters: t,
          typeAnnotation: r,
        });
      }
      function tsConstructSignatureDeclaration(e = null, t, r = null) {
        return (0, s.default)({
          type: 'TSConstructSignatureDeclaration',
          typeParameters: e,
          parameters: t,
          typeAnnotation: r,
        });
      }
      function tsPropertySignature(e, t = null, r = null) {
        return (0, s.default)({
          type: 'TSPropertySignature',
          key: e,
          typeAnnotation: t,
          initializer: r,
          kind: null,
        });
      }
      function tsMethodSignature(e, t = null, r, i = null) {
        return (0, s.default)({
          type: 'TSMethodSignature',
          key: e,
          typeParameters: t,
          parameters: r,
          typeAnnotation: i,
          kind: null,
        });
      }
      function tsIndexSignature(e, t = null) {
        return (0, s.default)({
          type: 'TSIndexSignature',
          parameters: e,
          typeAnnotation: t,
        });
      }
      function tsAnyKeyword() {
        return { type: 'TSAnyKeyword' };
      }
      function tsBooleanKeyword() {
        return { type: 'TSBooleanKeyword' };
      }
      function tsBigIntKeyword() {
        return { type: 'TSBigIntKeyword' };
      }
      function tsIntrinsicKeyword() {
        return { type: 'TSIntrinsicKeyword' };
      }
      function tsNeverKeyword() {
        return { type: 'TSNeverKeyword' };
      }
      function tsNullKeyword() {
        return { type: 'TSNullKeyword' };
      }
      function tsNumberKeyword() {
        return { type: 'TSNumberKeyword' };
      }
      function tsObjectKeyword() {
        return { type: 'TSObjectKeyword' };
      }
      function tsStringKeyword() {
        return { type: 'TSStringKeyword' };
      }
      function tsSymbolKeyword() {
        return { type: 'TSSymbolKeyword' };
      }
      function tsUndefinedKeyword() {
        return { type: 'TSUndefinedKeyword' };
      }
      function tsUnknownKeyword() {
        return { type: 'TSUnknownKeyword' };
      }
      function tsVoidKeyword() {
        return { type: 'TSVoidKeyword' };
      }
      function tsThisType() {
        return { type: 'TSThisType' };
      }
      function tsFunctionType(e = null, t, r = null) {
        return (0, s.default)({
          type: 'TSFunctionType',
          typeParameters: e,
          parameters: t,
          typeAnnotation: r,
        });
      }
      function tsConstructorType(e = null, t, r = null) {
        return (0, s.default)({
          type: 'TSConstructorType',
          typeParameters: e,
          parameters: t,
          typeAnnotation: r,
        });
      }
      function tsTypeReference(e, t = null) {
        return (0, s.default)({
          type: 'TSTypeReference',
          typeName: e,
          typeParameters: t,
        });
      }
      function tsTypePredicate(e, t = null, r = null) {
        return (0, s.default)({
          type: 'TSTypePredicate',
          parameterName: e,
          typeAnnotation: t,
          asserts: r,
        });
      }
      function tsTypeQuery(e, t = null) {
        return (0, s.default)({
          type: 'TSTypeQuery',
          exprName: e,
          typeParameters: t,
        });
      }
      function tsTypeLiteral(e) {
        return (0, s.default)({ type: 'TSTypeLiteral', members: e });
      }
      function tsArrayType(e) {
        return (0, s.default)({ type: 'TSArrayType', elementType: e });
      }
      function tsTupleType(e) {
        return (0, s.default)({ type: 'TSTupleType', elementTypes: e });
      }
      function tsOptionalType(e) {
        return (0, s.default)({ type: 'TSOptionalType', typeAnnotation: e });
      }
      function tsRestType(e) {
        return (0, s.default)({ type: 'TSRestType', typeAnnotation: e });
      }
      function tsNamedTupleMember(e, t, r = false) {
        return (0, s.default)({
          type: 'TSNamedTupleMember',
          label: e,
          elementType: t,
          optional: r,
        });
      }
      function tsUnionType(e) {
        return (0, s.default)({ type: 'TSUnionType', types: e });
      }
      function tsIntersectionType(e) {
        return (0, s.default)({ type: 'TSIntersectionType', types: e });
      }
      function tsConditionalType(e, t, r, i) {
        return (0, s.default)({
          type: 'TSConditionalType',
          checkType: e,
          extendsType: t,
          trueType: r,
          falseType: i,
        });
      }
      function tsInferType(e) {
        return (0, s.default)({ type: 'TSInferType', typeParameter: e });
      }
      function tsParenthesizedType(e) {
        return (0, s.default)({
          type: 'TSParenthesizedType',
          typeAnnotation: e,
        });
      }
      function tsTypeOperator(e) {
        return (0, s.default)({
          type: 'TSTypeOperator',
          typeAnnotation: e,
          operator: null,
        });
      }
      function tsIndexedAccessType(e, t) {
        return (0, s.default)({
          type: 'TSIndexedAccessType',
          objectType: e,
          indexType: t,
        });
      }
      function tsMappedType(e, t = null, r = null) {
        return (0, s.default)({
          type: 'TSMappedType',
          typeParameter: e,
          typeAnnotation: t,
          nameType: r,
        });
      }
      function tsLiteralType(e) {
        return (0, s.default)({ type: 'TSLiteralType', literal: e });
      }
      function tsExpressionWithTypeArguments(e, t = null) {
        return (0, s.default)({
          type: 'TSExpressionWithTypeArguments',
          expression: e,
          typeParameters: t,
        });
      }
      function tsInterfaceDeclaration(e, t = null, r = null, i) {
        return (0, s.default)({
          type: 'TSInterfaceDeclaration',
          id: e,
          typeParameters: t,
          extends: r,
          body: i,
        });
      }
      function tsInterfaceBody(e) {
        return (0, s.default)({ type: 'TSInterfaceBody', body: e });
      }
      function tsTypeAliasDeclaration(e, t = null, r) {
        return (0, s.default)({
          type: 'TSTypeAliasDeclaration',
          id: e,
          typeParameters: t,
          typeAnnotation: r,
        });
      }
      function tsInstantiationExpression(e, t = null) {
        return (0, s.default)({
          type: 'TSInstantiationExpression',
          expression: e,
          typeParameters: t,
        });
      }
      function tsAsExpression(e, t) {
        return (0, s.default)({
          type: 'TSAsExpression',
          expression: e,
          typeAnnotation: t,
        });
      }
      function tsSatisfiesExpression(e, t) {
        return (0, s.default)({
          type: 'TSSatisfiesExpression',
          expression: e,
          typeAnnotation: t,
        });
      }
      function tsTypeAssertion(e, t) {
        return (0, s.default)({
          type: 'TSTypeAssertion',
          typeAnnotation: e,
          expression: t,
        });
      }
      function tsEnumDeclaration(e, t) {
        return (0, s.default)({ type: 'TSEnumDeclaration', id: e, members: t });
      }
      function tsEnumMember(e, t = null) {
        return (0, s.default)({ type: 'TSEnumMember', id: e, initializer: t });
      }
      function tsModuleDeclaration(e, t) {
        return (0, s.default)({ type: 'TSModuleDeclaration', id: e, body: t });
      }
      function tsModuleBlock(e) {
        return (0, s.default)({ type: 'TSModuleBlock', body: e });
      }
      function tsImportType(e, t = null, r = null) {
        return (0, s.default)({
          type: 'TSImportType',
          argument: e,
          qualifier: t,
          typeParameters: r,
        });
      }
      function tsImportEqualsDeclaration(e, t) {
        return (0, s.default)({
          type: 'TSImportEqualsDeclaration',
          id: e,
          moduleReference: t,
          isExport: null,
        });
      }
      function tsExternalModuleReference(e) {
        return (0, s.default)({
          type: 'TSExternalModuleReference',
          expression: e,
        });
      }
      function tsNonNullExpression(e) {
        return (0, s.default)({ type: 'TSNonNullExpression', expression: e });
      }
      function tsExportAssignment(e) {
        return (0, s.default)({ type: 'TSExportAssignment', expression: e });
      }
      function tsNamespaceExportDeclaration(e) {
        return (0, s.default)({ type: 'TSNamespaceExportDeclaration', id: e });
      }
      function tsTypeAnnotation(e) {
        return (0, s.default)({ type: 'TSTypeAnnotation', typeAnnotation: e });
      }
      function tsTypeParameterInstantiation(e) {
        return (0, s.default)({
          type: 'TSTypeParameterInstantiation',
          params: e,
        });
      }
      function tsTypeParameterDeclaration(e) {
        return (0, s.default)({
          type: 'TSTypeParameterDeclaration',
          params: e,
        });
      }
      function tsTypeParameter(e = null, t = null, r) {
        return (0, s.default)({
          type: 'TSTypeParameter',
          constraint: e,
          default: t,
          name: r,
        });
      }
      function NumberLiteral(e) {
        (0, i.default)('NumberLiteral', 'NumericLiteral', 'The node type ');
        return numericLiteral(e);
      }
      function RegexLiteral(e, t = '') {
        (0, i.default)('RegexLiteral', 'RegExpLiteral', 'The node type ');
        return regExpLiteral(e, t);
      }
      function RestProperty(e) {
        (0, i.default)('RestProperty', 'RestElement', 'The node type ');
        return restElement(e);
      }
      function SpreadProperty(e) {
        (0, i.default)('SpreadProperty', 'SpreadElement', 'The node type ');
        return spreadElement(e);
      }
    },
    6503: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      Object.defineProperty(t, 'AnyTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.anyTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'ArgumentPlaceholder', {
        enumerable: true,
        get: function () {
          return s.argumentPlaceholder;
        },
      });
      Object.defineProperty(t, 'ArrayExpression', {
        enumerable: true,
        get: function () {
          return s.arrayExpression;
        },
      });
      Object.defineProperty(t, 'ArrayPattern', {
        enumerable: true,
        get: function () {
          return s.arrayPattern;
        },
      });
      Object.defineProperty(t, 'ArrayTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.arrayTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'ArrowFunctionExpression', {
        enumerable: true,
        get: function () {
          return s.arrowFunctionExpression;
        },
      });
      Object.defineProperty(t, 'AssignmentExpression', {
        enumerable: true,
        get: function () {
          return s.assignmentExpression;
        },
      });
      Object.defineProperty(t, 'AssignmentPattern', {
        enumerable: true,
        get: function () {
          return s.assignmentPattern;
        },
      });
      Object.defineProperty(t, 'AwaitExpression', {
        enumerable: true,
        get: function () {
          return s.awaitExpression;
        },
      });
      Object.defineProperty(t, 'BigIntLiteral', {
        enumerable: true,
        get: function () {
          return s.bigIntLiteral;
        },
      });
      Object.defineProperty(t, 'BinaryExpression', {
        enumerable: true,
        get: function () {
          return s.binaryExpression;
        },
      });
      Object.defineProperty(t, 'BindExpression', {
        enumerable: true,
        get: function () {
          return s.bindExpression;
        },
      });
      Object.defineProperty(t, 'BlockStatement', {
        enumerable: true,
        get: function () {
          return s.blockStatement;
        },
      });
      Object.defineProperty(t, 'BooleanLiteral', {
        enumerable: true,
        get: function () {
          return s.booleanLiteral;
        },
      });
      Object.defineProperty(t, 'BooleanLiteralTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.booleanLiteralTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'BooleanTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.booleanTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'BreakStatement', {
        enumerable: true,
        get: function () {
          return s.breakStatement;
        },
      });
      Object.defineProperty(t, 'CallExpression', {
        enumerable: true,
        get: function () {
          return s.callExpression;
        },
      });
      Object.defineProperty(t, 'CatchClause', {
        enumerable: true,
        get: function () {
          return s.catchClause;
        },
      });
      Object.defineProperty(t, 'ClassAccessorProperty', {
        enumerable: true,
        get: function () {
          return s.classAccessorProperty;
        },
      });
      Object.defineProperty(t, 'ClassBody', {
        enumerable: true,
        get: function () {
          return s.classBody;
        },
      });
      Object.defineProperty(t, 'ClassDeclaration', {
        enumerable: true,
        get: function () {
          return s.classDeclaration;
        },
      });
      Object.defineProperty(t, 'ClassExpression', {
        enumerable: true,
        get: function () {
          return s.classExpression;
        },
      });
      Object.defineProperty(t, 'ClassImplements', {
        enumerable: true,
        get: function () {
          return s.classImplements;
        },
      });
      Object.defineProperty(t, 'ClassMethod', {
        enumerable: true,
        get: function () {
          return s.classMethod;
        },
      });
      Object.defineProperty(t, 'ClassPrivateMethod', {
        enumerable: true,
        get: function () {
          return s.classPrivateMethod;
        },
      });
      Object.defineProperty(t, 'ClassPrivateProperty', {
        enumerable: true,
        get: function () {
          return s.classPrivateProperty;
        },
      });
      Object.defineProperty(t, 'ClassProperty', {
        enumerable: true,
        get: function () {
          return s.classProperty;
        },
      });
      Object.defineProperty(t, 'ConditionalExpression', {
        enumerable: true,
        get: function () {
          return s.conditionalExpression;
        },
      });
      Object.defineProperty(t, 'ContinueStatement', {
        enumerable: true,
        get: function () {
          return s.continueStatement;
        },
      });
      Object.defineProperty(t, 'DebuggerStatement', {
        enumerable: true,
        get: function () {
          return s.debuggerStatement;
        },
      });
      Object.defineProperty(t, 'DecimalLiteral', {
        enumerable: true,
        get: function () {
          return s.decimalLiteral;
        },
      });
      Object.defineProperty(t, 'DeclareClass', {
        enumerable: true,
        get: function () {
          return s.declareClass;
        },
      });
      Object.defineProperty(t, 'DeclareExportAllDeclaration', {
        enumerable: true,
        get: function () {
          return s.declareExportAllDeclaration;
        },
      });
      Object.defineProperty(t, 'DeclareExportDeclaration', {
        enumerable: true,
        get: function () {
          return s.declareExportDeclaration;
        },
      });
      Object.defineProperty(t, 'DeclareFunction', {
        enumerable: true,
        get: function () {
          return s.declareFunction;
        },
      });
      Object.defineProperty(t, 'DeclareInterface', {
        enumerable: true,
        get: function () {
          return s.declareInterface;
        },
      });
      Object.defineProperty(t, 'DeclareModule', {
        enumerable: true,
        get: function () {
          return s.declareModule;
        },
      });
      Object.defineProperty(t, 'DeclareModuleExports', {
        enumerable: true,
        get: function () {
          return s.declareModuleExports;
        },
      });
      Object.defineProperty(t, 'DeclareOpaqueType', {
        enumerable: true,
        get: function () {
          return s.declareOpaqueType;
        },
      });
      Object.defineProperty(t, 'DeclareTypeAlias', {
        enumerable: true,
        get: function () {
          return s.declareTypeAlias;
        },
      });
      Object.defineProperty(t, 'DeclareVariable', {
        enumerable: true,
        get: function () {
          return s.declareVariable;
        },
      });
      Object.defineProperty(t, 'DeclaredPredicate', {
        enumerable: true,
        get: function () {
          return s.declaredPredicate;
        },
      });
      Object.defineProperty(t, 'Decorator', {
        enumerable: true,
        get: function () {
          return s.decorator;
        },
      });
      Object.defineProperty(t, 'Directive', {
        enumerable: true,
        get: function () {
          return s.directive;
        },
      });
      Object.defineProperty(t, 'DirectiveLiteral', {
        enumerable: true,
        get: function () {
          return s.directiveLiteral;
        },
      });
      Object.defineProperty(t, 'DoExpression', {
        enumerable: true,
        get: function () {
          return s.doExpression;
        },
      });
      Object.defineProperty(t, 'DoWhileStatement', {
        enumerable: true,
        get: function () {
          return s.doWhileStatement;
        },
      });
      Object.defineProperty(t, 'EmptyStatement', {
        enumerable: true,
        get: function () {
          return s.emptyStatement;
        },
      });
      Object.defineProperty(t, 'EmptyTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.emptyTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'EnumBooleanBody', {
        enumerable: true,
        get: function () {
          return s.enumBooleanBody;
        },
      });
      Object.defineProperty(t, 'EnumBooleanMember', {
        enumerable: true,
        get: function () {
          return s.enumBooleanMember;
        },
      });
      Object.defineProperty(t, 'EnumDeclaration', {
        enumerable: true,
        get: function () {
          return s.enumDeclaration;
        },
      });
      Object.defineProperty(t, 'EnumDefaultedMember', {
        enumerable: true,
        get: function () {
          return s.enumDefaultedMember;
        },
      });
      Object.defineProperty(t, 'EnumNumberBody', {
        enumerable: true,
        get: function () {
          return s.enumNumberBody;
        },
      });
      Object.defineProperty(t, 'EnumNumberMember', {
        enumerable: true,
        get: function () {
          return s.enumNumberMember;
        },
      });
      Object.defineProperty(t, 'EnumStringBody', {
        enumerable: true,
        get: function () {
          return s.enumStringBody;
        },
      });
      Object.defineProperty(t, 'EnumStringMember', {
        enumerable: true,
        get: function () {
          return s.enumStringMember;
        },
      });
      Object.defineProperty(t, 'EnumSymbolBody', {
        enumerable: true,
        get: function () {
          return s.enumSymbolBody;
        },
      });
      Object.defineProperty(t, 'ExistsTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.existsTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'ExportAllDeclaration', {
        enumerable: true,
        get: function () {
          return s.exportAllDeclaration;
        },
      });
      Object.defineProperty(t, 'ExportDefaultDeclaration', {
        enumerable: true,
        get: function () {
          return s.exportDefaultDeclaration;
        },
      });
      Object.defineProperty(t, 'ExportDefaultSpecifier', {
        enumerable: true,
        get: function () {
          return s.exportDefaultSpecifier;
        },
      });
      Object.defineProperty(t, 'ExportNamedDeclaration', {
        enumerable: true,
        get: function () {
          return s.exportNamedDeclaration;
        },
      });
      Object.defineProperty(t, 'ExportNamespaceSpecifier', {
        enumerable: true,
        get: function () {
          return s.exportNamespaceSpecifier;
        },
      });
      Object.defineProperty(t, 'ExportSpecifier', {
        enumerable: true,
        get: function () {
          return s.exportSpecifier;
        },
      });
      Object.defineProperty(t, 'ExpressionStatement', {
        enumerable: true,
        get: function () {
          return s.expressionStatement;
        },
      });
      Object.defineProperty(t, 'File', {
        enumerable: true,
        get: function () {
          return s.file;
        },
      });
      Object.defineProperty(t, 'ForInStatement', {
        enumerable: true,
        get: function () {
          return s.forInStatement;
        },
      });
      Object.defineProperty(t, 'ForOfStatement', {
        enumerable: true,
        get: function () {
          return s.forOfStatement;
        },
      });
      Object.defineProperty(t, 'ForStatement', {
        enumerable: true,
        get: function () {
          return s.forStatement;
        },
      });
      Object.defineProperty(t, 'FunctionDeclaration', {
        enumerable: true,
        get: function () {
          return s.functionDeclaration;
        },
      });
      Object.defineProperty(t, 'FunctionExpression', {
        enumerable: true,
        get: function () {
          return s.functionExpression;
        },
      });
      Object.defineProperty(t, 'FunctionTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.functionTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'FunctionTypeParam', {
        enumerable: true,
        get: function () {
          return s.functionTypeParam;
        },
      });
      Object.defineProperty(t, 'GenericTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.genericTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'Identifier', {
        enumerable: true,
        get: function () {
          return s.identifier;
        },
      });
      Object.defineProperty(t, 'IfStatement', {
        enumerable: true,
        get: function () {
          return s.ifStatement;
        },
      });
      Object.defineProperty(t, 'Import', {
        enumerable: true,
        get: function () {
          return s.import;
        },
      });
      Object.defineProperty(t, 'ImportAttribute', {
        enumerable: true,
        get: function () {
          return s.importAttribute;
        },
      });
      Object.defineProperty(t, 'ImportDeclaration', {
        enumerable: true,
        get: function () {
          return s.importDeclaration;
        },
      });
      Object.defineProperty(t, 'ImportDefaultSpecifier', {
        enumerable: true,
        get: function () {
          return s.importDefaultSpecifier;
        },
      });
      Object.defineProperty(t, 'ImportExpression', {
        enumerable: true,
        get: function () {
          return s.importExpression;
        },
      });
      Object.defineProperty(t, 'ImportNamespaceSpecifier', {
        enumerable: true,
        get: function () {
          return s.importNamespaceSpecifier;
        },
      });
      Object.defineProperty(t, 'ImportSpecifier', {
        enumerable: true,
        get: function () {
          return s.importSpecifier;
        },
      });
      Object.defineProperty(t, 'IndexedAccessType', {
        enumerable: true,
        get: function () {
          return s.indexedAccessType;
        },
      });
      Object.defineProperty(t, 'InferredPredicate', {
        enumerable: true,
        get: function () {
          return s.inferredPredicate;
        },
      });
      Object.defineProperty(t, 'InterfaceDeclaration', {
        enumerable: true,
        get: function () {
          return s.interfaceDeclaration;
        },
      });
      Object.defineProperty(t, 'InterfaceExtends', {
        enumerable: true,
        get: function () {
          return s.interfaceExtends;
        },
      });
      Object.defineProperty(t, 'InterfaceTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.interfaceTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'InterpreterDirective', {
        enumerable: true,
        get: function () {
          return s.interpreterDirective;
        },
      });
      Object.defineProperty(t, 'IntersectionTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.intersectionTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'JSXAttribute', {
        enumerable: true,
        get: function () {
          return s.jsxAttribute;
        },
      });
      Object.defineProperty(t, 'JSXClosingElement', {
        enumerable: true,
        get: function () {
          return s.jsxClosingElement;
        },
      });
      Object.defineProperty(t, 'JSXClosingFragment', {
        enumerable: true,
        get: function () {
          return s.jsxClosingFragment;
        },
      });
      Object.defineProperty(t, 'JSXElement', {
        enumerable: true,
        get: function () {
          return s.jsxElement;
        },
      });
      Object.defineProperty(t, 'JSXEmptyExpression', {
        enumerable: true,
        get: function () {
          return s.jsxEmptyExpression;
        },
      });
      Object.defineProperty(t, 'JSXExpressionContainer', {
        enumerable: true,
        get: function () {
          return s.jsxExpressionContainer;
        },
      });
      Object.defineProperty(t, 'JSXFragment', {
        enumerable: true,
        get: function () {
          return s.jsxFragment;
        },
      });
      Object.defineProperty(t, 'JSXIdentifier', {
        enumerable: true,
        get: function () {
          return s.jsxIdentifier;
        },
      });
      Object.defineProperty(t, 'JSXMemberExpression', {
        enumerable: true,
        get: function () {
          return s.jsxMemberExpression;
        },
      });
      Object.defineProperty(t, 'JSXNamespacedName', {
        enumerable: true,
        get: function () {
          return s.jsxNamespacedName;
        },
      });
      Object.defineProperty(t, 'JSXOpeningElement', {
        enumerable: true,
        get: function () {
          return s.jsxOpeningElement;
        },
      });
      Object.defineProperty(t, 'JSXOpeningFragment', {
        enumerable: true,
        get: function () {
          return s.jsxOpeningFragment;
        },
      });
      Object.defineProperty(t, 'JSXSpreadAttribute', {
        enumerable: true,
        get: function () {
          return s.jsxSpreadAttribute;
        },
      });
      Object.defineProperty(t, 'JSXSpreadChild', {
        enumerable: true,
        get: function () {
          return s.jsxSpreadChild;
        },
      });
      Object.defineProperty(t, 'JSXText', {
        enumerable: true,
        get: function () {
          return s.jsxText;
        },
      });
      Object.defineProperty(t, 'LabeledStatement', {
        enumerable: true,
        get: function () {
          return s.labeledStatement;
        },
      });
      Object.defineProperty(t, 'LogicalExpression', {
        enumerable: true,
        get: function () {
          return s.logicalExpression;
        },
      });
      Object.defineProperty(t, 'MemberExpression', {
        enumerable: true,
        get: function () {
          return s.memberExpression;
        },
      });
      Object.defineProperty(t, 'MetaProperty', {
        enumerable: true,
        get: function () {
          return s.metaProperty;
        },
      });
      Object.defineProperty(t, 'MixedTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.mixedTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'ModuleExpression', {
        enumerable: true,
        get: function () {
          return s.moduleExpression;
        },
      });
      Object.defineProperty(t, 'NewExpression', {
        enumerable: true,
        get: function () {
          return s.newExpression;
        },
      });
      Object.defineProperty(t, 'Noop', {
        enumerable: true,
        get: function () {
          return s.noop;
        },
      });
      Object.defineProperty(t, 'NullLiteral', {
        enumerable: true,
        get: function () {
          return s.nullLiteral;
        },
      });
      Object.defineProperty(t, 'NullLiteralTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.nullLiteralTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'NullableTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.nullableTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'NumberLiteral', {
        enumerable: true,
        get: function () {
          return s.numberLiteral;
        },
      });
      Object.defineProperty(t, 'NumberLiteralTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.numberLiteralTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'NumberTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.numberTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'NumericLiteral', {
        enumerable: true,
        get: function () {
          return s.numericLiteral;
        },
      });
      Object.defineProperty(t, 'ObjectExpression', {
        enumerable: true,
        get: function () {
          return s.objectExpression;
        },
      });
      Object.defineProperty(t, 'ObjectMethod', {
        enumerable: true,
        get: function () {
          return s.objectMethod;
        },
      });
      Object.defineProperty(t, 'ObjectPattern', {
        enumerable: true,
        get: function () {
          return s.objectPattern;
        },
      });
      Object.defineProperty(t, 'ObjectProperty', {
        enumerable: true,
        get: function () {
          return s.objectProperty;
        },
      });
      Object.defineProperty(t, 'ObjectTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.objectTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'ObjectTypeCallProperty', {
        enumerable: true,
        get: function () {
          return s.objectTypeCallProperty;
        },
      });
      Object.defineProperty(t, 'ObjectTypeIndexer', {
        enumerable: true,
        get: function () {
          return s.objectTypeIndexer;
        },
      });
      Object.defineProperty(t, 'ObjectTypeInternalSlot', {
        enumerable: true,
        get: function () {
          return s.objectTypeInternalSlot;
        },
      });
      Object.defineProperty(t, 'ObjectTypeProperty', {
        enumerable: true,
        get: function () {
          return s.objectTypeProperty;
        },
      });
      Object.defineProperty(t, 'ObjectTypeSpreadProperty', {
        enumerable: true,
        get: function () {
          return s.objectTypeSpreadProperty;
        },
      });
      Object.defineProperty(t, 'OpaqueType', {
        enumerable: true,
        get: function () {
          return s.opaqueType;
        },
      });
      Object.defineProperty(t, 'OptionalCallExpression', {
        enumerable: true,
        get: function () {
          return s.optionalCallExpression;
        },
      });
      Object.defineProperty(t, 'OptionalIndexedAccessType', {
        enumerable: true,
        get: function () {
          return s.optionalIndexedAccessType;
        },
      });
      Object.defineProperty(t, 'OptionalMemberExpression', {
        enumerable: true,
        get: function () {
          return s.optionalMemberExpression;
        },
      });
      Object.defineProperty(t, 'ParenthesizedExpression', {
        enumerable: true,
        get: function () {
          return s.parenthesizedExpression;
        },
      });
      Object.defineProperty(t, 'PipelineBareFunction', {
        enumerable: true,
        get: function () {
          return s.pipelineBareFunction;
        },
      });
      Object.defineProperty(t, 'PipelinePrimaryTopicReference', {
        enumerable: true,
        get: function () {
          return s.pipelinePrimaryTopicReference;
        },
      });
      Object.defineProperty(t, 'PipelineTopicExpression', {
        enumerable: true,
        get: function () {
          return s.pipelineTopicExpression;
        },
      });
      Object.defineProperty(t, 'Placeholder', {
        enumerable: true,
        get: function () {
          return s.placeholder;
        },
      });
      Object.defineProperty(t, 'PrivateName', {
        enumerable: true,
        get: function () {
          return s.privateName;
        },
      });
      Object.defineProperty(t, 'Program', {
        enumerable: true,
        get: function () {
          return s.program;
        },
      });
      Object.defineProperty(t, 'QualifiedTypeIdentifier', {
        enumerable: true,
        get: function () {
          return s.qualifiedTypeIdentifier;
        },
      });
      Object.defineProperty(t, 'RecordExpression', {
        enumerable: true,
        get: function () {
          return s.recordExpression;
        },
      });
      Object.defineProperty(t, 'RegExpLiteral', {
        enumerable: true,
        get: function () {
          return s.regExpLiteral;
        },
      });
      Object.defineProperty(t, 'RegexLiteral', {
        enumerable: true,
        get: function () {
          return s.regexLiteral;
        },
      });
      Object.defineProperty(t, 'RestElement', {
        enumerable: true,
        get: function () {
          return s.restElement;
        },
      });
      Object.defineProperty(t, 'RestProperty', {
        enumerable: true,
        get: function () {
          return s.restProperty;
        },
      });
      Object.defineProperty(t, 'ReturnStatement', {
        enumerable: true,
        get: function () {
          return s.returnStatement;
        },
      });
      Object.defineProperty(t, 'SequenceExpression', {
        enumerable: true,
        get: function () {
          return s.sequenceExpression;
        },
      });
      Object.defineProperty(t, 'SpreadElement', {
        enumerable: true,
        get: function () {
          return s.spreadElement;
        },
      });
      Object.defineProperty(t, 'SpreadProperty', {
        enumerable: true,
        get: function () {
          return s.spreadProperty;
        },
      });
      Object.defineProperty(t, 'StaticBlock', {
        enumerable: true,
        get: function () {
          return s.staticBlock;
        },
      });
      Object.defineProperty(t, 'StringLiteral', {
        enumerable: true,
        get: function () {
          return s.stringLiteral;
        },
      });
      Object.defineProperty(t, 'StringLiteralTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.stringLiteralTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'StringTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.stringTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'Super', {
        enumerable: true,
        get: function () {
          return s.super;
        },
      });
      Object.defineProperty(t, 'SwitchCase', {
        enumerable: true,
        get: function () {
          return s.switchCase;
        },
      });
      Object.defineProperty(t, 'SwitchStatement', {
        enumerable: true,
        get: function () {
          return s.switchStatement;
        },
      });
      Object.defineProperty(t, 'SymbolTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.symbolTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'TSAnyKeyword', {
        enumerable: true,
        get: function () {
          return s.tsAnyKeyword;
        },
      });
      Object.defineProperty(t, 'TSArrayType', {
        enumerable: true,
        get: function () {
          return s.tsArrayType;
        },
      });
      Object.defineProperty(t, 'TSAsExpression', {
        enumerable: true,
        get: function () {
          return s.tsAsExpression;
        },
      });
      Object.defineProperty(t, 'TSBigIntKeyword', {
        enumerable: true,
        get: function () {
          return s.tsBigIntKeyword;
        },
      });
      Object.defineProperty(t, 'TSBooleanKeyword', {
        enumerable: true,
        get: function () {
          return s.tsBooleanKeyword;
        },
      });
      Object.defineProperty(t, 'TSCallSignatureDeclaration', {
        enumerable: true,
        get: function () {
          return s.tsCallSignatureDeclaration;
        },
      });
      Object.defineProperty(t, 'TSConditionalType', {
        enumerable: true,
        get: function () {
          return s.tsConditionalType;
        },
      });
      Object.defineProperty(t, 'TSConstructSignatureDeclaration', {
        enumerable: true,
        get: function () {
          return s.tsConstructSignatureDeclaration;
        },
      });
      Object.defineProperty(t, 'TSConstructorType', {
        enumerable: true,
        get: function () {
          return s.tsConstructorType;
        },
      });
      Object.defineProperty(t, 'TSDeclareFunction', {
        enumerable: true,
        get: function () {
          return s.tsDeclareFunction;
        },
      });
      Object.defineProperty(t, 'TSDeclareMethod', {
        enumerable: true,
        get: function () {
          return s.tsDeclareMethod;
        },
      });
      Object.defineProperty(t, 'TSEnumDeclaration', {
        enumerable: true,
        get: function () {
          return s.tsEnumDeclaration;
        },
      });
      Object.defineProperty(t, 'TSEnumMember', {
        enumerable: true,
        get: function () {
          return s.tsEnumMember;
        },
      });
      Object.defineProperty(t, 'TSExportAssignment', {
        enumerable: true,
        get: function () {
          return s.tsExportAssignment;
        },
      });
      Object.defineProperty(t, 'TSExpressionWithTypeArguments', {
        enumerable: true,
        get: function () {
          return s.tsExpressionWithTypeArguments;
        },
      });
      Object.defineProperty(t, 'TSExternalModuleReference', {
        enumerable: true,
        get: function () {
          return s.tsExternalModuleReference;
        },
      });
      Object.defineProperty(t, 'TSFunctionType', {
        enumerable: true,
        get: function () {
          return s.tsFunctionType;
        },
      });
      Object.defineProperty(t, 'TSImportEqualsDeclaration', {
        enumerable: true,
        get: function () {
          return s.tsImportEqualsDeclaration;
        },
      });
      Object.defineProperty(t, 'TSImportType', {
        enumerable: true,
        get: function () {
          return s.tsImportType;
        },
      });
      Object.defineProperty(t, 'TSIndexSignature', {
        enumerable: true,
        get: function () {
          return s.tsIndexSignature;
        },
      });
      Object.defineProperty(t, 'TSIndexedAccessType', {
        enumerable: true,
        get: function () {
          return s.tsIndexedAccessType;
        },
      });
      Object.defineProperty(t, 'TSInferType', {
        enumerable: true,
        get: function () {
          return s.tsInferType;
        },
      });
      Object.defineProperty(t, 'TSInstantiationExpression', {
        enumerable: true,
        get: function () {
          return s.tsInstantiationExpression;
        },
      });
      Object.defineProperty(t, 'TSInterfaceBody', {
        enumerable: true,
        get: function () {
          return s.tsInterfaceBody;
        },
      });
      Object.defineProperty(t, 'TSInterfaceDeclaration', {
        enumerable: true,
        get: function () {
          return s.tsInterfaceDeclaration;
        },
      });
      Object.defineProperty(t, 'TSIntersectionType', {
        enumerable: true,
        get: function () {
          return s.tsIntersectionType;
        },
      });
      Object.defineProperty(t, 'TSIntrinsicKeyword', {
        enumerable: true,
        get: function () {
          return s.tsIntrinsicKeyword;
        },
      });
      Object.defineProperty(t, 'TSLiteralType', {
        enumerable: true,
        get: function () {
          return s.tsLiteralType;
        },
      });
      Object.defineProperty(t, 'TSMappedType', {
        enumerable: true,
        get: function () {
          return s.tsMappedType;
        },
      });
      Object.defineProperty(t, 'TSMethodSignature', {
        enumerable: true,
        get: function () {
          return s.tsMethodSignature;
        },
      });
      Object.defineProperty(t, 'TSModuleBlock', {
        enumerable: true,
        get: function () {
          return s.tsModuleBlock;
        },
      });
      Object.defineProperty(t, 'TSModuleDeclaration', {
        enumerable: true,
        get: function () {
          return s.tsModuleDeclaration;
        },
      });
      Object.defineProperty(t, 'TSNamedTupleMember', {
        enumerable: true,
        get: function () {
          return s.tsNamedTupleMember;
        },
      });
      Object.defineProperty(t, 'TSNamespaceExportDeclaration', {
        enumerable: true,
        get: function () {
          return s.tsNamespaceExportDeclaration;
        },
      });
      Object.defineProperty(t, 'TSNeverKeyword', {
        enumerable: true,
        get: function () {
          return s.tsNeverKeyword;
        },
      });
      Object.defineProperty(t, 'TSNonNullExpression', {
        enumerable: true,
        get: function () {
          return s.tsNonNullExpression;
        },
      });
      Object.defineProperty(t, 'TSNullKeyword', {
        enumerable: true,
        get: function () {
          return s.tsNullKeyword;
        },
      });
      Object.defineProperty(t, 'TSNumberKeyword', {
        enumerable: true,
        get: function () {
          return s.tsNumberKeyword;
        },
      });
      Object.defineProperty(t, 'TSObjectKeyword', {
        enumerable: true,
        get: function () {
          return s.tsObjectKeyword;
        },
      });
      Object.defineProperty(t, 'TSOptionalType', {
        enumerable: true,
        get: function () {
          return s.tsOptionalType;
        },
      });
      Object.defineProperty(t, 'TSParameterProperty', {
        enumerable: true,
        get: function () {
          return s.tsParameterProperty;
        },
      });
      Object.defineProperty(t, 'TSParenthesizedType', {
        enumerable: true,
        get: function () {
          return s.tsParenthesizedType;
        },
      });
      Object.defineProperty(t, 'TSPropertySignature', {
        enumerable: true,
        get: function () {
          return s.tsPropertySignature;
        },
      });
      Object.defineProperty(t, 'TSQualifiedName', {
        enumerable: true,
        get: function () {
          return s.tsQualifiedName;
        },
      });
      Object.defineProperty(t, 'TSRestType', {
        enumerable: true,
        get: function () {
          return s.tsRestType;
        },
      });
      Object.defineProperty(t, 'TSSatisfiesExpression', {
        enumerable: true,
        get: function () {
          return s.tsSatisfiesExpression;
        },
      });
      Object.defineProperty(t, 'TSStringKeyword', {
        enumerable: true,
        get: function () {
          return s.tsStringKeyword;
        },
      });
      Object.defineProperty(t, 'TSSymbolKeyword', {
        enumerable: true,
        get: function () {
          return s.tsSymbolKeyword;
        },
      });
      Object.defineProperty(t, 'TSThisType', {
        enumerable: true,
        get: function () {
          return s.tsThisType;
        },
      });
      Object.defineProperty(t, 'TSTupleType', {
        enumerable: true,
        get: function () {
          return s.tsTupleType;
        },
      });
      Object.defineProperty(t, 'TSTypeAliasDeclaration', {
        enumerable: true,
        get: function () {
          return s.tsTypeAliasDeclaration;
        },
      });
      Object.defineProperty(t, 'TSTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.tsTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'TSTypeAssertion', {
        enumerable: true,
        get: function () {
          return s.tsTypeAssertion;
        },
      });
      Object.defineProperty(t, 'TSTypeLiteral', {
        enumerable: true,
        get: function () {
          return s.tsTypeLiteral;
        },
      });
      Object.defineProperty(t, 'TSTypeOperator', {
        enumerable: true,
        get: function () {
          return s.tsTypeOperator;
        },
      });
      Object.defineProperty(t, 'TSTypeParameter', {
        enumerable: true,
        get: function () {
          return s.tsTypeParameter;
        },
      });
      Object.defineProperty(t, 'TSTypeParameterDeclaration', {
        enumerable: true,
        get: function () {
          return s.tsTypeParameterDeclaration;
        },
      });
      Object.defineProperty(t, 'TSTypeParameterInstantiation', {
        enumerable: true,
        get: function () {
          return s.tsTypeParameterInstantiation;
        },
      });
      Object.defineProperty(t, 'TSTypePredicate', {
        enumerable: true,
        get: function () {
          return s.tsTypePredicate;
        },
      });
      Object.defineProperty(t, 'TSTypeQuery', {
        enumerable: true,
        get: function () {
          return s.tsTypeQuery;
        },
      });
      Object.defineProperty(t, 'TSTypeReference', {
        enumerable: true,
        get: function () {
          return s.tsTypeReference;
        },
      });
      Object.defineProperty(t, 'TSUndefinedKeyword', {
        enumerable: true,
        get: function () {
          return s.tsUndefinedKeyword;
        },
      });
      Object.defineProperty(t, 'TSUnionType', {
        enumerable: true,
        get: function () {
          return s.tsUnionType;
        },
      });
      Object.defineProperty(t, 'TSUnknownKeyword', {
        enumerable: true,
        get: function () {
          return s.tsUnknownKeyword;
        },
      });
      Object.defineProperty(t, 'TSVoidKeyword', {
        enumerable: true,
        get: function () {
          return s.tsVoidKeyword;
        },
      });
      Object.defineProperty(t, 'TaggedTemplateExpression', {
        enumerable: true,
        get: function () {
          return s.taggedTemplateExpression;
        },
      });
      Object.defineProperty(t, 'TemplateElement', {
        enumerable: true,
        get: function () {
          return s.templateElement;
        },
      });
      Object.defineProperty(t, 'TemplateLiteral', {
        enumerable: true,
        get: function () {
          return s.templateLiteral;
        },
      });
      Object.defineProperty(t, 'ThisExpression', {
        enumerable: true,
        get: function () {
          return s.thisExpression;
        },
      });
      Object.defineProperty(t, 'ThisTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.thisTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'ThrowStatement', {
        enumerable: true,
        get: function () {
          return s.throwStatement;
        },
      });
      Object.defineProperty(t, 'TopicReference', {
        enumerable: true,
        get: function () {
          return s.topicReference;
        },
      });
      Object.defineProperty(t, 'TryStatement', {
        enumerable: true,
        get: function () {
          return s.tryStatement;
        },
      });
      Object.defineProperty(t, 'TupleExpression', {
        enumerable: true,
        get: function () {
          return s.tupleExpression;
        },
      });
      Object.defineProperty(t, 'TupleTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.tupleTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'TypeAlias', {
        enumerable: true,
        get: function () {
          return s.typeAlias;
        },
      });
      Object.defineProperty(t, 'TypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.typeAnnotation;
        },
      });
      Object.defineProperty(t, 'TypeCastExpression', {
        enumerable: true,
        get: function () {
          return s.typeCastExpression;
        },
      });
      Object.defineProperty(t, 'TypeParameter', {
        enumerable: true,
        get: function () {
          return s.typeParameter;
        },
      });
      Object.defineProperty(t, 'TypeParameterDeclaration', {
        enumerable: true,
        get: function () {
          return s.typeParameterDeclaration;
        },
      });
      Object.defineProperty(t, 'TypeParameterInstantiation', {
        enumerable: true,
        get: function () {
          return s.typeParameterInstantiation;
        },
      });
      Object.defineProperty(t, 'TypeofTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.typeofTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'UnaryExpression', {
        enumerable: true,
        get: function () {
          return s.unaryExpression;
        },
      });
      Object.defineProperty(t, 'UnionTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.unionTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'UpdateExpression', {
        enumerable: true,
        get: function () {
          return s.updateExpression;
        },
      });
      Object.defineProperty(t, 'V8IntrinsicIdentifier', {
        enumerable: true,
        get: function () {
          return s.v8IntrinsicIdentifier;
        },
      });
      Object.defineProperty(t, 'VariableDeclaration', {
        enumerable: true,
        get: function () {
          return s.variableDeclaration;
        },
      });
      Object.defineProperty(t, 'VariableDeclarator', {
        enumerable: true,
        get: function () {
          return s.variableDeclarator;
        },
      });
      Object.defineProperty(t, 'Variance', {
        enumerable: true,
        get: function () {
          return s.variance;
        },
      });
      Object.defineProperty(t, 'VoidTypeAnnotation', {
        enumerable: true,
        get: function () {
          return s.voidTypeAnnotation;
        },
      });
      Object.defineProperty(t, 'WhileStatement', {
        enumerable: true,
        get: function () {
          return s.whileStatement;
        },
      });
      Object.defineProperty(t, 'WithStatement', {
        enumerable: true,
        get: function () {
          return s.withStatement;
        },
      });
      Object.defineProperty(t, 'YieldExpression', {
        enumerable: true,
        get: function () {
          return s.yieldExpression;
        },
      });
      var s = r(397);
    },
    5673: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.buildUndefinedNode = buildUndefinedNode;
      var s = r(397);
      function buildUndefinedNode() {
        return (0, s.unaryExpression)('void', (0, s.numericLiteral)(0), true);
      }
    },
    3718: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = buildChildren;
      var s = r(6428);
      var i = r(485);
      function buildChildren(e) {
        const t = [];
        for (let r = 0; r < e.children.length; r++) {
          let n = e.children[r];
          if ((0, s.isJSXText)(n)) {
            (0, i.default)(n, t);
            continue;
          }
          if ((0, s.isJSXExpressionContainer)(n)) n = n.expression;
          if ((0, s.isJSXEmptyExpression)(n)) continue;
          t.push(n);
        }
        return t;
      }
    },
    1094: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = createTSUnionType;
      var s = r(397);
      var i = r(2832);
      var n = r(6428);
      function createTSUnionType(e) {
        const t = e.map((e) =>
          (0, n.isTSTypeAnnotation)(e) ? e.typeAnnotation : e,
        );
        const r = (0, i.default)(t);
        if (r.length === 1) {
          return r[0];
        } else {
          return (0, s.tsUnionType)(r);
        }
      }
    },
    9836: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = validateNode;
      var s = r(7159);
      var i = r(4739);
      function validateNode(e) {
        const t = i.BUILDER_KEYS[e.type];
        for (const r of t) {
          (0, s.default)(e, r, e[r]);
        }
        return e;
      }
    },
    9906: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = clone;
      var s = r(7421);
      function clone(e) {
        return (0, s.default)(e, false);
      }
    },
    6719: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = cloneDeep;
      var s = r(7421);
      function cloneDeep(e) {
        return (0, s.default)(e);
      }
    },
    6489: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = cloneDeepWithoutLoc;
      var s = r(7421);
      function cloneDeepWithoutLoc(e) {
        return (0, s.default)(e, true, true);
      }
    },
    7421: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = cloneNode;
      var s = r(7405);
      var i = r(6428);
      const n = Function.call.bind(Object.prototype.hasOwnProperty);
      function cloneIfNode(e, t, r, s) {
        if (e && typeof e.type === 'string') {
          return cloneNodeInternal(e, t, r, s);
        }
        return e;
      }
      function cloneIfNodeOrArray(e, t, r, s) {
        if (Array.isArray(e)) {
          return e.map((e) => cloneIfNode(e, t, r, s));
        }
        return cloneIfNode(e, t, r, s);
      }
      function cloneNode(e, t = true, r = false) {
        return cloneNodeInternal(e, t, r, new Map());
      }
      function cloneNodeInternal(e, t = true, r = false, a) {
        if (!e) return e;
        const { type: o } = e;
        const l = { type: e.type };
        if ((0, i.isIdentifier)(e)) {
          l.name = e.name;
          if (n(e, 'optional') && typeof e.optional === 'boolean') {
            l.optional = e.optional;
          }
          if (n(e, 'typeAnnotation')) {
            l.typeAnnotation = t
              ? cloneIfNodeOrArray(e.typeAnnotation, true, r, a)
              : e.typeAnnotation;
          }
        } else if (!n(s.NODE_FIELDS, o)) {
          throw new Error(`Unknown node type: "${o}"`);
        } else {
          for (const c of Object.keys(s.NODE_FIELDS[o])) {
            if (n(e, c)) {
              if (t) {
                l[c] =
                  (0, i.isFile)(e) && c === 'comments'
                    ? maybeCloneComments(e.comments, t, r, a)
                    : cloneIfNodeOrArray(e[c], true, r, a);
              } else {
                l[c] = e[c];
              }
            }
          }
        }
        if (n(e, 'loc')) {
          if (r) {
            l.loc = null;
          } else {
            l.loc = e.loc;
          }
        }
        if (n(e, 'leadingComments')) {
          l.leadingComments = maybeCloneComments(e.leadingComments, t, r, a);
        }
        if (n(e, 'innerComments')) {
          l.innerComments = maybeCloneComments(e.innerComments, t, r, a);
        }
        if (n(e, 'trailingComments')) {
          l.trailingComments = maybeCloneComments(e.trailingComments, t, r, a);
        }
        if (n(e, 'extra')) {
          l.extra = Object.assign({}, e.extra);
        }
        return l;
      }
      function maybeCloneComments(e, t, r, s) {
        if (!e || !t) {
          return e;
        }
        return e.map((e) => {
          const t = s.get(e);
          if (t) return t;
          const { type: i, value: n, loc: a } = e;
          const o = { type: i, value: n, loc: a };
          if (r) {
            o.loc = null;
          }
          s.set(e, o);
          return o;
        });
      }
    },
    1260: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = cloneWithoutLoc;
      var s = r(7421);
      function cloneWithoutLoc(e) {
        return (0, s.default)(e, false, true);
      }
    },
    2227: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = addComment;
      var s = r(9534);
      function addComment(e, t, r, i) {
        return (0, s.default)(e, t, [
          { type: i ? 'CommentLine' : 'CommentBlock', value: r },
        ]);
      }
    },
    9534: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = addComments;
      function addComments(e, t, r) {
        if (!r || !e) return e;
        const s = `${t}Comments`;
        if (e[s]) {
          if (t === 'leading') {
            e[s] = r.concat(e[s]);
          } else {
            e[s].push(...r);
          }
        } else {
          e[s] = r;
        }
        return e;
      }
    },
    8898: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = inheritInnerComments;
      var s = r(778);
      function inheritInnerComments(e, t) {
        (0, s.default)('innerComments', e, t);
      }
    },
    5689: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = inheritLeadingComments;
      var s = r(778);
      function inheritLeadingComments(e, t) {
        (0, s.default)('leadingComments', e, t);
      }
    },
    3146: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = inheritTrailingComments;
      var s = r(778);
      function inheritTrailingComments(e, t) {
        (0, s.default)('trailingComments', e, t);
      }
    },
    8237: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = inheritsComments;
      var s = r(3146);
      var i = r(5689);
      var n = r(8898);
      function inheritsComments(e, t) {
        (0, s.default)(e, t);
        (0, i.default)(e, t);
        (0, n.default)(e, t);
        return e;
      }
    },
    6267: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = removeComments;
      var s = r(1227);
      function removeComments(e) {
        s.COMMENT_KEYS.forEach((t) => {
          e[t] = null;
        });
        return e;
      }
    },
    8178: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.WHILE_TYPES =
        t.USERWHITESPACABLE_TYPES =
        t.UNARYLIKE_TYPES =
        t.TYPESCRIPT_TYPES =
        t.TSTYPE_TYPES =
        t.TSTYPEELEMENT_TYPES =
        t.TSENTITYNAME_TYPES =
        t.TSBASETYPE_TYPES =
        t.TERMINATORLESS_TYPES =
        t.STATEMENT_TYPES =
        t.STANDARDIZED_TYPES =
        t.SCOPABLE_TYPES =
        t.PUREISH_TYPES =
        t.PROPERTY_TYPES =
        t.PRIVATE_TYPES =
        t.PATTERN_TYPES =
        t.PATTERNLIKE_TYPES =
        t.OBJECTMEMBER_TYPES =
        t.MODULESPECIFIER_TYPES =
        t.MODULEDECLARATION_TYPES =
        t.MISCELLANEOUS_TYPES =
        t.METHOD_TYPES =
        t.LVAL_TYPES =
        t.LOOP_TYPES =
        t.LITERAL_TYPES =
        t.JSX_TYPES =
        t.IMPORTOREXPORTDECLARATION_TYPES =
        t.IMMUTABLE_TYPES =
        t.FUNCTION_TYPES =
        t.FUNCTIONPARENT_TYPES =
        t.FOR_TYPES =
        t.FORXSTATEMENT_TYPES =
        t.FLOW_TYPES =
        t.FLOWTYPE_TYPES =
        t.FLOWPREDICATE_TYPES =
        t.FLOWDECLARATION_TYPES =
        t.FLOWBASEANNOTATION_TYPES =
        t.EXPRESSION_TYPES =
        t.EXPRESSIONWRAPPER_TYPES =
        t.EXPORTDECLARATION_TYPES =
        t.ENUMMEMBER_TYPES =
        t.ENUMBODY_TYPES =
        t.DECLARATION_TYPES =
        t.CONDITIONAL_TYPES =
        t.COMPLETIONSTATEMENT_TYPES =
        t.CLASS_TYPES =
        t.BLOCK_TYPES =
        t.BLOCKPARENT_TYPES =
        t.BINARY_TYPES =
        t.ACCESSOR_TYPES =
          void 0;
      var s = r(7405);
      const i = (t.STANDARDIZED_TYPES = s.FLIPPED_ALIAS_KEYS['Standardized']);
      const n = (t.EXPRESSION_TYPES = s.FLIPPED_ALIAS_KEYS['Expression']);
      const a = (t.BINARY_TYPES = s.FLIPPED_ALIAS_KEYS['Binary']);
      const o = (t.SCOPABLE_TYPES = s.FLIPPED_ALIAS_KEYS['Scopable']);
      const l = (t.BLOCKPARENT_TYPES = s.FLIPPED_ALIAS_KEYS['BlockParent']);
      const c = (t.BLOCK_TYPES = s.FLIPPED_ALIAS_KEYS['Block']);
      const p = (t.STATEMENT_TYPES = s.FLIPPED_ALIAS_KEYS['Statement']);
      const u = (t.TERMINATORLESS_TYPES =
        s.FLIPPED_ALIAS_KEYS['Terminatorless']);
      const d = (t.COMPLETIONSTATEMENT_TYPES =
        s.FLIPPED_ALIAS_KEYS['CompletionStatement']);
      const f = (t.CONDITIONAL_TYPES = s.FLIPPED_ALIAS_KEYS['Conditional']);
      const h = (t.LOOP_TYPES = s.FLIPPED_ALIAS_KEYS['Loop']);
      const y = (t.WHILE_TYPES = s.FLIPPED_ALIAS_KEYS['While']);
      const m = (t.EXPRESSIONWRAPPER_TYPES =
        s.FLIPPED_ALIAS_KEYS['ExpressionWrapper']);
      const T = (t.FOR_TYPES = s.FLIPPED_ALIAS_KEYS['For']);
      const S = (t.FORXSTATEMENT_TYPES = s.FLIPPED_ALIAS_KEYS['ForXStatement']);
      const x = (t.FUNCTION_TYPES = s.FLIPPED_ALIAS_KEYS['Function']);
      const b = (t.FUNCTIONPARENT_TYPES =
        s.FLIPPED_ALIAS_KEYS['FunctionParent']);
      const E = (t.PUREISH_TYPES = s.FLIPPED_ALIAS_KEYS['Pureish']);
      const P = (t.DECLARATION_TYPES = s.FLIPPED_ALIAS_KEYS['Declaration']);
      const g = (t.PATTERNLIKE_TYPES = s.FLIPPED_ALIAS_KEYS['PatternLike']);
      const A = (t.LVAL_TYPES = s.FLIPPED_ALIAS_KEYS['LVal']);
      const v = (t.TSENTITYNAME_TYPES = s.FLIPPED_ALIAS_KEYS['TSEntityName']);
      const I = (t.LITERAL_TYPES = s.FLIPPED_ALIAS_KEYS['Literal']);
      const w = (t.IMMUTABLE_TYPES = s.FLIPPED_ALIAS_KEYS['Immutable']);
      const N = (t.USERWHITESPACABLE_TYPES =
        s.FLIPPED_ALIAS_KEYS['UserWhitespacable']);
      const O = (t.METHOD_TYPES = s.FLIPPED_ALIAS_KEYS['Method']);
      const C = (t.OBJECTMEMBER_TYPES = s.FLIPPED_ALIAS_KEYS['ObjectMember']);
      const D = (t.PROPERTY_TYPES = s.FLIPPED_ALIAS_KEYS['Property']);
      const k = (t.UNARYLIKE_TYPES = s.FLIPPED_ALIAS_KEYS['UnaryLike']);
      const L = (t.PATTERN_TYPES = s.FLIPPED_ALIAS_KEYS['Pattern']);
      const M = (t.CLASS_TYPES = s.FLIPPED_ALIAS_KEYS['Class']);
      const j = (t.IMPORTOREXPORTDECLARATION_TYPES =
        s.FLIPPED_ALIAS_KEYS['ImportOrExportDeclaration']);
      const B = (t.EXPORTDECLARATION_TYPES =
        s.FLIPPED_ALIAS_KEYS['ExportDeclaration']);
      const F = (t.MODULESPECIFIER_TYPES =
        s.FLIPPED_ALIAS_KEYS['ModuleSpecifier']);
      const _ = (t.ACCESSOR_TYPES = s.FLIPPED_ALIAS_KEYS['Accessor']);
      const R = (t.PRIVATE_TYPES = s.FLIPPED_ALIAS_KEYS['Private']);
      const K = (t.FLOW_TYPES = s.FLIPPED_ALIAS_KEYS['Flow']);
      const U = (t.FLOWTYPE_TYPES = s.FLIPPED_ALIAS_KEYS['FlowType']);
      const V = (t.FLOWBASEANNOTATION_TYPES =
        s.FLIPPED_ALIAS_KEYS['FlowBaseAnnotation']);
      const X = (t.FLOWDECLARATION_TYPES =
        s.FLIPPED_ALIAS_KEYS['FlowDeclaration']);
      const J = (t.FLOWPREDICATE_TYPES = s.FLIPPED_ALIAS_KEYS['FlowPredicate']);
      const Y = (t.ENUMBODY_TYPES = s.FLIPPED_ALIAS_KEYS['EnumBody']);
      const W = (t.ENUMMEMBER_TYPES = s.FLIPPED_ALIAS_KEYS['EnumMember']);
      const q = (t.JSX_TYPES = s.FLIPPED_ALIAS_KEYS['JSX']);
      const $ = (t.MISCELLANEOUS_TYPES = s.FLIPPED_ALIAS_KEYS['Miscellaneous']);
      const z = (t.TYPESCRIPT_TYPES = s.FLIPPED_ALIAS_KEYS['TypeScript']);
      const H = (t.TSTYPEELEMENT_TYPES = s.FLIPPED_ALIAS_KEYS['TSTypeElement']);
      const G = (t.TSTYPE_TYPES = s.FLIPPED_ALIAS_KEYS['TSType']);
      const Q = (t.TSBASETYPE_TYPES = s.FLIPPED_ALIAS_KEYS['TSBaseType']);
      const Z = (t.MODULEDECLARATION_TYPES = j);
    },
    1227: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.UPDATE_OPERATORS =
        t.UNARY_OPERATORS =
        t.STRING_UNARY_OPERATORS =
        t.STATEMENT_OR_BLOCK_KEYS =
        t.NUMBER_UNARY_OPERATORS =
        t.NUMBER_BINARY_OPERATORS =
        t.NOT_LOCAL_BINDING =
        t.LOGICAL_OPERATORS =
        t.INHERIT_KEYS =
        t.FOR_INIT_KEYS =
        t.FLATTENABLE_KEYS =
        t.EQUALITY_BINARY_OPERATORS =
        t.COMPARISON_BINARY_OPERATORS =
        t.COMMENT_KEYS =
        t.BOOLEAN_UNARY_OPERATORS =
        t.BOOLEAN_NUMBER_BINARY_OPERATORS =
        t.BOOLEAN_BINARY_OPERATORS =
        t.BLOCK_SCOPED_SYMBOL =
        t.BINARY_OPERATORS =
        t.ASSIGNMENT_OPERATORS =
          void 0;
      const r = (t.STATEMENT_OR_BLOCK_KEYS = [
        'consequent',
        'body',
        'alternate',
      ]);
      const s = (t.FLATTENABLE_KEYS = ['body', 'expressions']);
      const i = (t.FOR_INIT_KEYS = ['left', 'init']);
      const n = (t.COMMENT_KEYS = [
        'leadingComments',
        'trailingComments',
        'innerComments',
      ]);
      const a = (t.LOGICAL_OPERATORS = ['||', '&&', '??']);
      const o = (t.UPDATE_OPERATORS = ['++', '--']);
      const l = (t.BOOLEAN_NUMBER_BINARY_OPERATORS = ['>', '<', '>=', '<=']);
      const c = (t.EQUALITY_BINARY_OPERATORS = ['==', '===', '!=', '!==']);
      const p = (t.COMPARISON_BINARY_OPERATORS = [...c, 'in', 'instanceof']);
      const u = (t.BOOLEAN_BINARY_OPERATORS = [...p, ...l]);
      const d = (t.NUMBER_BINARY_OPERATORS = [
        '-',
        '/',
        '%',
        '*',
        '**',
        '&',
        '|',
        '>>',
        '>>>',
        '<<',
        '^',
      ]);
      const f = (t.BINARY_OPERATORS = ['+', ...d, ...u, '|>']);
      const h = (t.ASSIGNMENT_OPERATORS = [
        '=',
        '+=',
        ...d.map((e) => e + '='),
        ...a.map((e) => e + '='),
      ]);
      const y = (t.BOOLEAN_UNARY_OPERATORS = ['delete', '!']);
      const m = (t.NUMBER_UNARY_OPERATORS = ['+', '-', '~']);
      const T = (t.STRING_UNARY_OPERATORS = ['typeof']);
      const S = (t.UNARY_OPERATORS = ['void', 'throw', ...y, ...m, ...T]);
      const x = (t.INHERIT_KEYS = {
        optional: ['typeAnnotation', 'typeParameters', 'returnType'],
        force: ['start', 'loc', 'end'],
      });
      const b = (t.BLOCK_SCOPED_SYMBOL = Symbol.for(
        'var used to be block scoped',
      ));
      const E = (t.NOT_LOCAL_BINDING = Symbol.for(
        'should not be considered a local binding',
      ));
    },
    7158: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = ensureBlock;
      var s = r(5013);
      function ensureBlock(e, t = 'body') {
        const r = (0, s.default)(e[t], e);
        e[t] = r;
        return r;
      }
    },
    1357: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = gatherSequenceExpressions;
      var s = r(6675);
      var i = r(6428);
      var n = r(397);
      var a = r(7421);
      function gatherSequenceExpressions(e, t, r) {
        const o = [];
        let l = true;
        for (const c of e) {
          if (!(0, i.isEmptyStatement)(c)) {
            l = false;
          }
          if ((0, i.isExpression)(c)) {
            o.push(c);
          } else if ((0, i.isExpressionStatement)(c)) {
            o.push(c.expression);
          } else if ((0, i.isVariableDeclaration)(c)) {
            if (c.kind !== 'var') return;
            for (const e of c.declarations) {
              const t = (0, s.default)(e);
              for (const e of Object.keys(t)) {
                r.push({ kind: c.kind, id: (0, a.default)(t[e]) });
              }
              if (e.init) {
                o.push((0, n.assignmentExpression)('=', e.id, e.init));
              }
            }
            l = true;
          } else if ((0, i.isIfStatement)(c)) {
            const e = c.consequent
              ? gatherSequenceExpressions([c.consequent], t, r)
              : t.buildUndefinedNode();
            const s = c.alternate
              ? gatherSequenceExpressions([c.alternate], t, r)
              : t.buildUndefinedNode();
            if (!e || !s) return;
            o.push((0, n.conditionalExpression)(c.test, e, s));
          } else if ((0, i.isBlockStatement)(c)) {
            const e = gatherSequenceExpressions(c.body, t, r);
            if (!e) return;
            o.push(e);
          } else if ((0, i.isEmptyStatement)(c)) {
            if (e.indexOf(c) === 0) {
              l = true;
            }
          } else {
            return;
          }
        }
        if (l) {
          o.push(t.buildUndefinedNode());
        }
        if (o.length === 1) {
          return o[0];
        } else {
          return (0, n.sequenceExpression)(o);
        }
      }
    },
    5999: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = toBindingIdentifierName;
      var s = r(1868);
      function toBindingIdentifierName(e) {
        e = (0, s.default)(e);
        if (e === 'eval' || e === 'arguments') e = '_' + e;
        return e;
      }
    },
    5013: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = toBlock;
      var s = r(6428);
      var i = r(397);
      function toBlock(e, t) {
        if ((0, s.isBlockStatement)(e)) {
          return e;
        }
        let r = [];
        if ((0, s.isEmptyStatement)(e)) {
          r = [];
        } else {
          if (!(0, s.isStatement)(e)) {
            if ((0, s.isFunction)(t)) {
              e = (0, i.returnStatement)(e);
            } else {
              e = (0, i.expressionStatement)(e);
            }
          }
          r = [e];
        }
        return (0, i.blockStatement)(r);
      }
    },
    3317: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = toComputedKey;
      var s = r(6428);
      var i = r(397);
      function toComputedKey(e, t = e.key || e.property) {
        if (!e.computed && (0, s.isIdentifier)(t))
          t = (0, i.stringLiteral)(t.name);
        return t;
      }
    },
    9132: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = void 0;
      var s = r(6428);
      var i = (t['default'] = toExpression);
      function toExpression(e) {
        if ((0, s.isExpressionStatement)(e)) {
          e = e.expression;
        }
        if ((0, s.isExpression)(e)) {
          return e;
        }
        if ((0, s.isClass)(e)) {
          e.type = 'ClassExpression';
        } else if ((0, s.isFunction)(e)) {
          e.type = 'FunctionExpression';
        }
        if (!(0, s.isExpression)(e)) {
          throw new Error(`cannot turn ${e.type} to an expression`);
        }
        return e;
      }
    },
    1868: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = toIdentifier;
      var s = r(9994);
      var i = r(3442);
      function toIdentifier(e) {
        e = e + '';
        let t = '';
        for (const r of e) {
          t += (0, i.isIdentifierChar)(r.codePointAt(0)) ? r : '-';
        }
        t = t.replace(/^[-0-9]+/, '');
        t = t.replace(/[-\s]+(.)?/g, function (e, t) {
          return t ? t.toUpperCase() : '';
        });
        if (!(0, s.default)(t)) {
          t = `_${t}`;
        }
        return t || '_';
      }
    },
    1873: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = toKeyAlias;
      var s = r(6428);
      var i = r(7421);
      var n = r(2735);
      function toKeyAlias(e, t = e.key) {
        let r;
        if (e.kind === 'method') {
          return toKeyAlias.increment() + '';
        } else if ((0, s.isIdentifier)(t)) {
          r = t.name;
        } else if ((0, s.isStringLiteral)(t)) {
          r = JSON.stringify(t.value);
        } else {
          r = JSON.stringify((0, n.default)((0, i.default)(t)));
        }
        if (e.computed) {
          r = `[${r}]`;
        }
        if (e.static) {
          r = `static:${r}`;
        }
        return r;
      }
      toKeyAlias.uid = 0;
      toKeyAlias.increment = function () {
        if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
          return (toKeyAlias.uid = 0);
        } else {
          return toKeyAlias.uid++;
        }
      };
    },
    6906: function (e, t, r) {
      'use strict';
      var s;
      s = { value: true };
      t['default'] = toSequenceExpression;
      var i = r(1357);
      function toSequenceExpression(e, t) {
        if (!(e != null && e.length)) return;
        const r = [];
        const s = (0, i.default)(e, t, r);
        if (!s) return;
        for (const e of r) {
          t.push(e);
        }
        return s;
      }
    },
    4570: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = void 0;
      var s = r(6428);
      var i = r(397);
      var n = (t['default'] = toStatement);
      function toStatement(e, t) {
        if ((0, s.isStatement)(e)) {
          return e;
        }
        let r = false;
        let n;
        if ((0, s.isClass)(e)) {
          r = true;
          n = 'ClassDeclaration';
        } else if ((0, s.isFunction)(e)) {
          r = true;
          n = 'FunctionDeclaration';
        } else if ((0, s.isAssignmentExpression)(e)) {
          return (0, i.expressionStatement)(e);
        }
        if (r && !e.id) {
          n = false;
        }
        if (!n) {
          if (t) {
            return false;
          } else {
            throw new Error(`cannot turn ${e.type} to a statement`);
          }
        }
        e.type = n;
        return e;
      }
    },
    1382: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = void 0;
      var s = r(9994);
      var i = r(397);
      var n = (t['default'] = valueToNode);
      const a = Function.call.bind(Object.prototype.toString);
      function isRegExp(e) {
        return a(e) === '[object RegExp]';
      }
      function isPlainObject(e) {
        if (
          typeof e !== 'object' ||
          e === null ||
          Object.prototype.toString.call(e) !== '[object Object]'
        ) {
          return false;
        }
        const t = Object.getPrototypeOf(e);
        return t === null || Object.getPrototypeOf(t) === null;
      }
      function valueToNode(e) {
        if (e === undefined) {
          return (0, i.identifier)('undefined');
        }
        if (e === true || e === false) {
          return (0, i.booleanLiteral)(e);
        }
        if (e === null) {
          return (0, i.nullLiteral)();
        }
        if (typeof e === 'string') {
          return (0, i.stringLiteral)(e);
        }
        if (typeof e === 'number') {
          let t;
          if (Number.isFinite(e)) {
            t = (0, i.numericLiteral)(Math.abs(e));
          } else {
            let r;
            if (Number.isNaN(e)) {
              r = (0, i.numericLiteral)(0);
            } else {
              r = (0, i.numericLiteral)(1);
            }
            t = (0, i.binaryExpression)('/', r, (0, i.numericLiteral)(0));
          }
          if (e < 0 || Object.is(e, -0)) {
            t = (0, i.unaryExpression)('-', t);
          }
          return t;
        }
        if (isRegExp(e)) {
          const t = e.source;
          const r = e.toString().match(/\/([a-z]+|)$/)[1];
          return (0, i.regExpLiteral)(t, r);
        }
        if (Array.isArray(e)) {
          return (0, i.arrayExpression)(e.map(valueToNode));
        }
        if (isPlainObject(e)) {
          const t = [];
          for (const r of Object.keys(e)) {
            let n;
            if ((0, s.default)(r)) {
              n = (0, i.identifier)(r);
            } else {
              n = (0, i.stringLiteral)(r);
            }
            t.push((0, i.objectProperty)(n, valueToNode(e[r])));
          }
          return (0, i.objectExpression)(t);
        }
        throw new Error("don't know how to turn this value into a node");
      }
    },
    5967: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.patternLikeCommon =
        t.functionTypeAnnotationCommon =
        t.functionDeclarationCommon =
        t.functionCommon =
        t.classMethodOrPropertyCommon =
        t.classMethodOrDeclareMethodCommon =
          void 0;
      var s = r(3685);
      var i = r(9994);
      var n = r(3442);
      var a = r(2776);
      var o = r(1227);
      var l = r(1903);
      const c = (0, l.defineAliasedType)('Standardized');
      c('ArrayExpression', {
        fields: {
          elements: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)(
                (0, l.assertNodeOrValueType)(
                  'null',
                  'Expression',
                  'SpreadElement',
                ),
              ),
            ),
            default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined,
          },
        },
        visitor: ['elements'],
        aliases: ['Expression'],
      });
      c('AssignmentExpression', {
        fields: {
          operator: {
            validate: (function () {
              if (!process.env.BABEL_TYPES_8_BREAKING) {
                return (0, l.assertValueType)('string');
              }
              const e = (0, l.assertOneOf)(...o.ASSIGNMENT_OPERATORS);
              const t = (0, l.assertOneOf)('=');
              return function (r, i, n) {
                const a = (0, s.default)('Pattern', r.left) ? t : e;
                a(r, i, n);
              };
            })(),
          },
          left: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, l.assertNodeType)('LVal', 'OptionalMemberExpression')
              : (0, l.assertNodeType)(
                  'Identifier',
                  'MemberExpression',
                  'OptionalMemberExpression',
                  'ArrayPattern',
                  'ObjectPattern',
                  'TSAsExpression',
                  'TSSatisfiesExpression',
                  'TSTypeAssertion',
                  'TSNonNullExpression',
                ),
          },
          right: { validate: (0, l.assertNodeType)('Expression') },
        },
        builder: ['operator', 'left', 'right'],
        visitor: ['left', 'right'],
        aliases: ['Expression'],
      });
      c('BinaryExpression', {
        builder: ['operator', 'left', 'right'],
        fields: {
          operator: { validate: (0, l.assertOneOf)(...o.BINARY_OPERATORS) },
          left: {
            validate: (function () {
              const e = (0, l.assertNodeType)('Expression');
              const t = (0, l.assertNodeType)('Expression', 'PrivateName');
              const r = Object.assign(
                function (r, s, i) {
                  const n = r.operator === 'in' ? t : e;
                  n(r, s, i);
                },
                { oneOfNodeTypes: ['Expression', 'PrivateName'] },
              );
              return r;
            })(),
          },
          right: { validate: (0, l.assertNodeType)('Expression') },
        },
        visitor: ['left', 'right'],
        aliases: ['Binary', 'Expression'],
      });
      c('InterpreterDirective', {
        builder: ['value'],
        fields: { value: { validate: (0, l.assertValueType)('string') } },
      });
      c('Directive', {
        visitor: ['value'],
        fields: {
          value: { validate: (0, l.assertNodeType)('DirectiveLiteral') },
        },
      });
      c('DirectiveLiteral', {
        builder: ['value'],
        fields: { value: { validate: (0, l.assertValueType)('string') } },
      });
      c('BlockStatement', {
        builder: ['body', 'directives'],
        visitor: ['directives', 'body'],
        fields: {
          directives: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Directive')),
            ),
            default: [],
          },
          body: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Statement')),
            ),
          },
        },
        aliases: ['Scopable', 'BlockParent', 'Block', 'Statement'],
      });
      c('BreakStatement', {
        visitor: ['label'],
        fields: {
          label: {
            validate: (0, l.assertNodeType)('Identifier'),
            optional: true,
          },
        },
        aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
      });
      c('CallExpression', {
        visitor: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
        builder: ['callee', 'arguments'],
        aliases: ['Expression'],
        fields: Object.assign(
          {
            callee: {
              validate: (0, l.assertNodeType)(
                'Expression',
                'Super',
                'V8IntrinsicIdentifier',
              ),
            },
            arguments: {
              validate: (0, l.chain)(
                (0, l.assertValueType)('array'),
                (0, l.assertEach)(
                  (0, l.assertNodeType)(
                    'Expression',
                    'SpreadElement',
                    'JSXNamespacedName',
                    'ArgumentPlaceholder',
                  ),
                ),
              ),
            },
          },
          !process.env.BABEL_TYPES_8_BREAKING
            ? {
                optional: {
                  validate: (0, l.assertOneOf)(true, false),
                  optional: true,
                },
              }
            : {},
          {
            typeArguments: {
              validate: (0, l.assertNodeType)('TypeParameterInstantiation'),
              optional: true,
            },
            typeParameters: {
              validate: (0, l.assertNodeType)('TSTypeParameterInstantiation'),
              optional: true,
            },
          },
        ),
      });
      c('CatchClause', {
        visitor: ['param', 'body'],
        fields: {
          param: {
            validate: (0, l.assertNodeType)(
              'Identifier',
              'ArrayPattern',
              'ObjectPattern',
            ),
            optional: true,
          },
          body: { validate: (0, l.assertNodeType)('BlockStatement') },
        },
        aliases: ['Scopable', 'BlockParent'],
      });
      c('ConditionalExpression', {
        visitor: ['test', 'consequent', 'alternate'],
        fields: {
          test: { validate: (0, l.assertNodeType)('Expression') },
          consequent: { validate: (0, l.assertNodeType)('Expression') },
          alternate: { validate: (0, l.assertNodeType)('Expression') },
        },
        aliases: ['Expression', 'Conditional'],
      });
      c('ContinueStatement', {
        visitor: ['label'],
        fields: {
          label: {
            validate: (0, l.assertNodeType)('Identifier'),
            optional: true,
          },
        },
        aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
      });
      c('DebuggerStatement', { aliases: ['Statement'] });
      c('DoWhileStatement', {
        visitor: ['test', 'body'],
        fields: {
          test: { validate: (0, l.assertNodeType)('Expression') },
          body: { validate: (0, l.assertNodeType)('Statement') },
        },
        aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
      });
      c('EmptyStatement', { aliases: ['Statement'] });
      c('ExpressionStatement', {
        visitor: ['expression'],
        fields: {
          expression: { validate: (0, l.assertNodeType)('Expression') },
        },
        aliases: ['Statement', 'ExpressionWrapper'],
      });
      c('File', {
        builder: ['program', 'comments', 'tokens'],
        visitor: ['program'],
        fields: {
          program: { validate: (0, l.assertNodeType)('Program') },
          comments: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? Object.assign(() => {}, {
                  each: { oneOfNodeTypes: ['CommentBlock', 'CommentLine'] },
                })
              : (0, l.assertEach)(
                  (0, l.assertNodeType)('CommentBlock', 'CommentLine'),
                ),
            optional: true,
          },
          tokens: {
            validate: (0, l.assertEach)(
              Object.assign(() => {}, { type: 'any' }),
            ),
            optional: true,
          },
        },
      });
      c('ForInStatement', {
        visitor: ['left', 'right', 'body'],
        aliases: [
          'Scopable',
          'Statement',
          'For',
          'BlockParent',
          'Loop',
          'ForXStatement',
        ],
        fields: {
          left: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, l.assertNodeType)('VariableDeclaration', 'LVal')
              : (0, l.assertNodeType)(
                  'VariableDeclaration',
                  'Identifier',
                  'MemberExpression',
                  'ArrayPattern',
                  'ObjectPattern',
                  'TSAsExpression',
                  'TSSatisfiesExpression',
                  'TSTypeAssertion',
                  'TSNonNullExpression',
                ),
          },
          right: { validate: (0, l.assertNodeType)('Expression') },
          body: { validate: (0, l.assertNodeType)('Statement') },
        },
      });
      c('ForStatement', {
        visitor: ['init', 'test', 'update', 'body'],
        aliases: ['Scopable', 'Statement', 'For', 'BlockParent', 'Loop'],
        fields: {
          init: {
            validate: (0, l.assertNodeType)(
              'VariableDeclaration',
              'Expression',
            ),
            optional: true,
          },
          test: {
            validate: (0, l.assertNodeType)('Expression'),
            optional: true,
          },
          update: {
            validate: (0, l.assertNodeType)('Expression'),
            optional: true,
          },
          body: { validate: (0, l.assertNodeType)('Statement') },
        },
      });
      const functionCommon = () => ({
        params: {
          validate: (0, l.chain)(
            (0, l.assertValueType)('array'),
            (0, l.assertEach)(
              (0, l.assertNodeType)('Identifier', 'Pattern', 'RestElement'),
            ),
          ),
        },
        generator: { default: false },
        async: { default: false },
      });
      t.functionCommon = functionCommon;
      const functionTypeAnnotationCommon = () => ({
        returnType: {
          validate: (0, l.assertNodeType)(
            'TypeAnnotation',
            'TSTypeAnnotation',
            'Noop',
          ),
          optional: true,
        },
        typeParameters: {
          validate: (0, l.assertNodeType)(
            'TypeParameterDeclaration',
            'TSTypeParameterDeclaration',
            'Noop',
          ),
          optional: true,
        },
      });
      t.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
      const functionDeclarationCommon = () =>
        Object.assign({}, functionCommon(), {
          declare: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
          id: { validate: (0, l.assertNodeType)('Identifier'), optional: true },
        });
      t.functionDeclarationCommon = functionDeclarationCommon;
      c('FunctionDeclaration', {
        builder: ['id', 'params', 'body', 'generator', 'async'],
        visitor: ['id', 'params', 'body', 'returnType', 'typeParameters'],
        fields: Object.assign(
          {},
          functionDeclarationCommon(),
          functionTypeAnnotationCommon(),
          {
            body: { validate: (0, l.assertNodeType)('BlockStatement') },
            predicate: {
              validate: (0, l.assertNodeType)(
                'DeclaredPredicate',
                'InferredPredicate',
              ),
              optional: true,
            },
          },
        ),
        aliases: [
          'Scopable',
          'Function',
          'BlockParent',
          'FunctionParent',
          'Statement',
          'Pureish',
          'Declaration',
        ],
        validate: (function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};
          const e = (0, l.assertNodeType)('Identifier');
          return function (t, r, i) {
            if (!(0, s.default)('ExportDefaultDeclaration', t)) {
              e(i, 'id', i.id);
            }
          };
        })(),
      });
      c('FunctionExpression', {
        inherits: 'FunctionDeclaration',
        aliases: [
          'Scopable',
          'Function',
          'BlockParent',
          'FunctionParent',
          'Expression',
          'Pureish',
        ],
        fields: Object.assign(
          {},
          functionCommon(),
          functionTypeAnnotationCommon(),
          {
            id: {
              validate: (0, l.assertNodeType)('Identifier'),
              optional: true,
            },
            body: { validate: (0, l.assertNodeType)('BlockStatement') },
            predicate: {
              validate: (0, l.assertNodeType)(
                'DeclaredPredicate',
                'InferredPredicate',
              ),
              optional: true,
            },
          },
        ),
      });
      const patternLikeCommon = () => ({
        typeAnnotation: {
          validate: (0, l.assertNodeType)(
            'TypeAnnotation',
            'TSTypeAnnotation',
            'Noop',
          ),
          optional: true,
        },
        optional: {
          validate: (0, l.assertValueType)('boolean'),
          optional: true,
        },
        decorators: {
          validate: (0, l.chain)(
            (0, l.assertValueType)('array'),
            (0, l.assertEach)((0, l.assertNodeType)('Decorator')),
          ),
          optional: true,
        },
      });
      t.patternLikeCommon = patternLikeCommon;
      c('Identifier', {
        builder: ['name'],
        visitor: ['typeAnnotation', 'decorators'],
        aliases: ['Expression', 'PatternLike', 'LVal', 'TSEntityName'],
        fields: Object.assign({}, patternLikeCommon(), {
          name: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('string'),
              Object.assign(
                function (e, t, r) {
                  if (!process.env.BABEL_TYPES_8_BREAKING) return;
                  if (!(0, i.default)(r, false)) {
                    throw new TypeError(
                      `"${r}" is not a valid identifier name`,
                    );
                  }
                },
                { type: 'string' },
              ),
            ),
          },
        }),
        validate(e, t, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          const i = /\.(\w+)$/.exec(t);
          if (!i) return;
          const [, a] = i;
          const o = { computed: false };
          if (a === 'property') {
            if ((0, s.default)('MemberExpression', e, o)) return;
            if ((0, s.default)('OptionalMemberExpression', e, o)) return;
          } else if (a === 'key') {
            if ((0, s.default)('Property', e, o)) return;
            if ((0, s.default)('Method', e, o)) return;
          } else if (a === 'exported') {
            if ((0, s.default)('ExportSpecifier', e)) return;
          } else if (a === 'imported') {
            if ((0, s.default)('ImportSpecifier', e, { imported: r })) return;
          } else if (a === 'meta') {
            if ((0, s.default)('MetaProperty', e, { meta: r })) return;
          }
          if (
            ((0, n.isKeyword)(r.name) ||
              (0, n.isReservedWord)(r.name, false)) &&
            r.name !== 'this'
          ) {
            throw new TypeError(`"${r.name}" is not a valid identifier`);
          }
        },
      });
      c('IfStatement', {
        visitor: ['test', 'consequent', 'alternate'],
        aliases: ['Statement', 'Conditional'],
        fields: {
          test: { validate: (0, l.assertNodeType)('Expression') },
          consequent: { validate: (0, l.assertNodeType)('Statement') },
          alternate: {
            optional: true,
            validate: (0, l.assertNodeType)('Statement'),
          },
        },
      });
      c('LabeledStatement', {
        visitor: ['label', 'body'],
        aliases: ['Statement'],
        fields: {
          label: { validate: (0, l.assertNodeType)('Identifier') },
          body: { validate: (0, l.assertNodeType)('Statement') },
        },
      });
      c('StringLiteral', {
        builder: ['value'],
        fields: { value: { validate: (0, l.assertValueType)('string') } },
        aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
      });
      c('NumericLiteral', {
        builder: ['value'],
        deprecatedAlias: 'NumberLiteral',
        fields: {
          value: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('number'),
              Object.assign(
                function (e, t, r) {
                  if (1 / r < 0 || !Number.isFinite(r)) {
                    const e = new Error(
                      'NumericLiterals must be non-negative finite numbers. ' +
                        `You can use t.valueToNode(${r}) instead.`,
                    );
                    {
                    }
                  }
                },
                { type: 'number' },
              ),
            ),
          },
        },
        aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
      });
      c('NullLiteral', {
        aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
      });
      c('BooleanLiteral', {
        builder: ['value'],
        fields: { value: { validate: (0, l.assertValueType)('boolean') } },
        aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
      });
      c('RegExpLiteral', {
        builder: ['pattern', 'flags'],
        deprecatedAlias: 'RegexLiteral',
        aliases: ['Expression', 'Pureish', 'Literal'],
        fields: {
          pattern: { validate: (0, l.assertValueType)('string') },
          flags: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('string'),
              Object.assign(
                function (e, t, r) {
                  if (!process.env.BABEL_TYPES_8_BREAKING) return;
                  const s = /[^gimsuy]/.exec(r);
                  if (s) {
                    throw new TypeError(`"${s[0]}" is not a valid RegExp flag`);
                  }
                },
                { type: 'string' },
              ),
            ),
            default: '',
          },
        },
      });
      c('LogicalExpression', {
        builder: ['operator', 'left', 'right'],
        visitor: ['left', 'right'],
        aliases: ['Binary', 'Expression'],
        fields: {
          operator: { validate: (0, l.assertOneOf)(...o.LOGICAL_OPERATORS) },
          left: { validate: (0, l.assertNodeType)('Expression') },
          right: { validate: (0, l.assertNodeType)('Expression') },
        },
      });
      c('MemberExpression', {
        builder: [
          'object',
          'property',
          'computed',
          ...(!process.env.BABEL_TYPES_8_BREAKING ? ['optional'] : []),
        ],
        visitor: ['object', 'property'],
        aliases: ['Expression', 'LVal'],
        fields: Object.assign(
          {
            object: { validate: (0, l.assertNodeType)('Expression', 'Super') },
            property: {
              validate: (function () {
                const e = (0, l.assertNodeType)('Identifier', 'PrivateName');
                const t = (0, l.assertNodeType)('Expression');
                const validator = function (r, s, i) {
                  const n = r.computed ? t : e;
                  n(r, s, i);
                };
                validator.oneOfNodeTypes = [
                  'Expression',
                  'Identifier',
                  'PrivateName',
                ];
                return validator;
              })(),
            },
            computed: { default: false },
          },
          !process.env.BABEL_TYPES_8_BREAKING
            ? {
                optional: {
                  validate: (0, l.assertOneOf)(true, false),
                  optional: true,
                },
              }
            : {},
        ),
      });
      c('NewExpression', { inherits: 'CallExpression' });
      c('Program', {
        visitor: ['directives', 'body'],
        builder: ['body', 'directives', 'sourceType', 'interpreter'],
        fields: {
          sourceFile: { validate: (0, l.assertValueType)('string') },
          sourceType: {
            validate: (0, l.assertOneOf)('script', 'module'),
            default: 'script',
          },
          interpreter: {
            validate: (0, l.assertNodeType)('InterpreterDirective'),
            default: null,
            optional: true,
          },
          directives: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Directive')),
            ),
            default: [],
          },
          body: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Statement')),
            ),
          },
        },
        aliases: ['Scopable', 'BlockParent', 'Block'],
      });
      c('ObjectExpression', {
        visitor: ['properties'],
        aliases: ['Expression'],
        fields: {
          properties: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)(
                (0, l.assertNodeType)(
                  'ObjectMethod',
                  'ObjectProperty',
                  'SpreadElement',
                ),
              ),
            ),
          },
        },
      });
      c('ObjectMethod', {
        builder: [
          'kind',
          'key',
          'params',
          'body',
          'computed',
          'generator',
          'async',
        ],
        fields: Object.assign(
          {},
          functionCommon(),
          functionTypeAnnotationCommon(),
          {
            kind: Object.assign(
              { validate: (0, l.assertOneOf)('method', 'get', 'set') },
              !process.env.BABEL_TYPES_8_BREAKING ? { default: 'method' } : {},
            ),
            computed: { default: false },
            key: {
              validate: (function () {
                const e = (0, l.assertNodeType)(
                  'Identifier',
                  'StringLiteral',
                  'NumericLiteral',
                  'BigIntLiteral',
                );
                const t = (0, l.assertNodeType)('Expression');
                const validator = function (r, s, i) {
                  const n = r.computed ? t : e;
                  n(r, s, i);
                };
                validator.oneOfNodeTypes = [
                  'Expression',
                  'Identifier',
                  'StringLiteral',
                  'NumericLiteral',
                  'BigIntLiteral',
                ];
                return validator;
              })(),
            },
            decorators: {
              validate: (0, l.chain)(
                (0, l.assertValueType)('array'),
                (0, l.assertEach)((0, l.assertNodeType)('Decorator')),
              ),
              optional: true,
            },
            body: { validate: (0, l.assertNodeType)('BlockStatement') },
          },
        ),
        visitor: [
          'key',
          'params',
          'body',
          'decorators',
          'returnType',
          'typeParameters',
        ],
        aliases: [
          'UserWhitespacable',
          'Function',
          'Scopable',
          'BlockParent',
          'FunctionParent',
          'Method',
          'ObjectMember',
        ],
      });
      c('ObjectProperty', {
        builder: [
          'key',
          'value',
          'computed',
          'shorthand',
          ...(!process.env.BABEL_TYPES_8_BREAKING ? ['decorators'] : []),
        ],
        fields: {
          computed: { default: false },
          key: {
            validate: (function () {
              const e = (0, l.assertNodeType)(
                'Identifier',
                'StringLiteral',
                'NumericLiteral',
                'BigIntLiteral',
                'DecimalLiteral',
                'PrivateName',
              );
              const t = (0, l.assertNodeType)('Expression');
              const r = Object.assign(
                function (r, s, i) {
                  const n = r.computed ? t : e;
                  n(r, s, i);
                },
                {
                  oneOfNodeTypes: [
                    'Expression',
                    'Identifier',
                    'StringLiteral',
                    'NumericLiteral',
                    'BigIntLiteral',
                    'DecimalLiteral',
                    'PrivateName',
                  ],
                },
              );
              return r;
            })(),
          },
          value: {
            validate: (0, l.assertNodeType)('Expression', 'PatternLike'),
          },
          shorthand: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('boolean'),
              Object.assign(
                function (e, t, r) {
                  if (!process.env.BABEL_TYPES_8_BREAKING) return;
                  if (r && e.computed) {
                    throw new TypeError(
                      'Property shorthand of ObjectProperty cannot be true if computed is true',
                    );
                  }
                },
                { type: 'boolean' },
              ),
              function (e, t, r) {
                if (!process.env.BABEL_TYPES_8_BREAKING) return;
                if (r && !(0, s.default)('Identifier', e.key)) {
                  throw new TypeError(
                    'Property shorthand of ObjectProperty cannot be true if key is not an Identifier',
                  );
                }
              },
            ),
            default: false,
          },
          decorators: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Decorator')),
            ),
            optional: true,
          },
        },
        visitor: ['key', 'value', 'decorators'],
        aliases: ['UserWhitespacable', 'Property', 'ObjectMember'],
        validate: (function () {
          const e = (0, l.assertNodeType)(
            'Identifier',
            'Pattern',
            'TSAsExpression',
            'TSSatisfiesExpression',
            'TSNonNullExpression',
            'TSTypeAssertion',
          );
          const t = (0, l.assertNodeType)('Expression');
          return function (r, i, n) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;
            const a = (0, s.default)('ObjectPattern', r) ? e : t;
            a(n, 'value', n.value);
          };
        })(),
      });
      c('RestElement', {
        visitor: ['argument', 'typeAnnotation'],
        builder: ['argument'],
        aliases: ['LVal', 'PatternLike'],
        deprecatedAlias: 'RestProperty',
        fields: Object.assign({}, patternLikeCommon(), {
          argument: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, l.assertNodeType)('LVal')
              : (0, l.assertNodeType)(
                  'Identifier',
                  'ArrayPattern',
                  'ObjectPattern',
                  'MemberExpression',
                  'TSAsExpression',
                  'TSSatisfiesExpression',
                  'TSTypeAssertion',
                  'TSNonNullExpression',
                ),
          },
        }),
        validate(e, t) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          const r = /(\w+)\[(\d+)\]/.exec(t);
          if (!r) throw new Error('Internal Babel error: malformed key.');
          const [, s, i] = r;
          if (e[s].length > +i + 1) {
            throw new TypeError(`RestElement must be last element of ${s}`);
          }
        },
      });
      c('ReturnStatement', {
        visitor: ['argument'],
        aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
        fields: {
          argument: {
            validate: (0, l.assertNodeType)('Expression'),
            optional: true,
          },
        },
      });
      c('SequenceExpression', {
        visitor: ['expressions'],
        fields: {
          expressions: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Expression')),
            ),
          },
        },
        aliases: ['Expression'],
      });
      c('ParenthesizedExpression', {
        visitor: ['expression'],
        aliases: ['Expression', 'ExpressionWrapper'],
        fields: {
          expression: { validate: (0, l.assertNodeType)('Expression') },
        },
      });
      c('SwitchCase', {
        visitor: ['test', 'consequent'],
        fields: {
          test: {
            validate: (0, l.assertNodeType)('Expression'),
            optional: true,
          },
          consequent: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Statement')),
            ),
          },
        },
      });
      c('SwitchStatement', {
        visitor: ['discriminant', 'cases'],
        aliases: ['Statement', 'BlockParent', 'Scopable'],
        fields: {
          discriminant: { validate: (0, l.assertNodeType)('Expression') },
          cases: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('SwitchCase')),
            ),
          },
        },
      });
      c('ThisExpression', { aliases: ['Expression'] });
      c('ThrowStatement', {
        visitor: ['argument'],
        aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
        fields: { argument: { validate: (0, l.assertNodeType)('Expression') } },
      });
      c('TryStatement', {
        visitor: ['block', 'handler', 'finalizer'],
        aliases: ['Statement'],
        fields: {
          block: {
            validate: (0, l.chain)(
              (0, l.assertNodeType)('BlockStatement'),
              Object.assign(
                function (e) {
                  if (!process.env.BABEL_TYPES_8_BREAKING) return;
                  if (!e.handler && !e.finalizer) {
                    throw new TypeError(
                      'TryStatement expects either a handler or finalizer, or both',
                    );
                  }
                },
                { oneOfNodeTypes: ['BlockStatement'] },
              ),
            ),
          },
          handler: {
            optional: true,
            validate: (0, l.assertNodeType)('CatchClause'),
          },
          finalizer: {
            optional: true,
            validate: (0, l.assertNodeType)('BlockStatement'),
          },
        },
      });
      c('UnaryExpression', {
        builder: ['operator', 'argument', 'prefix'],
        fields: {
          prefix: { default: true },
          argument: { validate: (0, l.assertNodeType)('Expression') },
          operator: { validate: (0, l.assertOneOf)(...o.UNARY_OPERATORS) },
        },
        visitor: ['argument'],
        aliases: ['UnaryLike', 'Expression'],
      });
      c('UpdateExpression', {
        builder: ['operator', 'argument', 'prefix'],
        fields: {
          prefix: { default: false },
          argument: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, l.assertNodeType)('Expression')
              : (0, l.assertNodeType)('Identifier', 'MemberExpression'),
          },
          operator: { validate: (0, l.assertOneOf)(...o.UPDATE_OPERATORS) },
        },
        visitor: ['argument'],
        aliases: ['Expression'],
      });
      c('VariableDeclaration', {
        builder: ['kind', 'declarations'],
        visitor: ['declarations'],
        aliases: ['Statement', 'Declaration'],
        fields: {
          declare: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
          kind: {
            validate: (0, l.assertOneOf)(
              'var',
              'let',
              'const',
              'using',
              'await using',
            ),
          },
          declarations: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('VariableDeclarator')),
            ),
          },
        },
        validate(e, t, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          if (!(0, s.default)('ForXStatement', e, { left: r })) return;
          if (r.declarations.length !== 1) {
            throw new TypeError(
              `Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e.type}`,
            );
          }
        },
      });
      c('VariableDeclarator', {
        visitor: ['id', 'init'],
        fields: {
          id: {
            validate: (function () {
              if (!process.env.BABEL_TYPES_8_BREAKING) {
                return (0, l.assertNodeType)('LVal');
              }
              const e = (0, l.assertNodeType)(
                'Identifier',
                'ArrayPattern',
                'ObjectPattern',
              );
              const t = (0, l.assertNodeType)('Identifier');
              return function (r, s, i) {
                const n = r.init ? e : t;
                n(r, s, i);
              };
            })(),
          },
          definite: {
            optional: true,
            validate: (0, l.assertValueType)('boolean'),
          },
          init: {
            optional: true,
            validate: (0, l.assertNodeType)('Expression'),
          },
        },
      });
      c('WhileStatement', {
        visitor: ['test', 'body'],
        aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
        fields: {
          test: { validate: (0, l.assertNodeType)('Expression') },
          body: { validate: (0, l.assertNodeType)('Statement') },
        },
      });
      c('WithStatement', {
        visitor: ['object', 'body'],
        aliases: ['Statement'],
        fields: {
          object: { validate: (0, l.assertNodeType)('Expression') },
          body: { validate: (0, l.assertNodeType)('Statement') },
        },
      });
      c('AssignmentPattern', {
        visitor: ['left', 'right', 'decorators'],
        builder: ['left', 'right'],
        aliases: ['Pattern', 'PatternLike', 'LVal'],
        fields: Object.assign({}, patternLikeCommon(), {
          left: {
            validate: (0, l.assertNodeType)(
              'Identifier',
              'ObjectPattern',
              'ArrayPattern',
              'MemberExpression',
              'TSAsExpression',
              'TSSatisfiesExpression',
              'TSTypeAssertion',
              'TSNonNullExpression',
            ),
          },
          right: { validate: (0, l.assertNodeType)('Expression') },
          decorators: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Decorator')),
            ),
            optional: true,
          },
        }),
      });
      c('ArrayPattern', {
        visitor: ['elements', 'typeAnnotation'],
        builder: ['elements'],
        aliases: ['Pattern', 'PatternLike', 'LVal'],
        fields: Object.assign({}, patternLikeCommon(), {
          elements: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)(
                (0, l.assertNodeOrValueType)('null', 'PatternLike', 'LVal'),
              ),
            ),
          },
        }),
      });
      c('ArrowFunctionExpression', {
        builder: ['params', 'body', 'async'],
        visitor: ['params', 'body', 'returnType', 'typeParameters'],
        aliases: [
          'Scopable',
          'Function',
          'BlockParent',
          'FunctionParent',
          'Expression',
          'Pureish',
        ],
        fields: Object.assign(
          {},
          functionCommon(),
          functionTypeAnnotationCommon(),
          {
            expression: { validate: (0, l.assertValueType)('boolean') },
            body: {
              validate: (0, l.assertNodeType)('BlockStatement', 'Expression'),
            },
            predicate: {
              validate: (0, l.assertNodeType)(
                'DeclaredPredicate',
                'InferredPredicate',
              ),
              optional: true,
            },
          },
        ),
      });
      c('ClassBody', {
        visitor: ['body'],
        fields: {
          body: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)(
                (0, l.assertNodeType)(
                  'ClassMethod',
                  'ClassPrivateMethod',
                  'ClassProperty',
                  'ClassPrivateProperty',
                  'ClassAccessorProperty',
                  'TSDeclareMethod',
                  'TSIndexSignature',
                  'StaticBlock',
                ),
              ),
            ),
          },
        },
      });
      c('ClassExpression', {
        builder: ['id', 'superClass', 'body', 'decorators'],
        visitor: [
          'id',
          'body',
          'superClass',
          'mixins',
          'typeParameters',
          'superTypeParameters',
          'implements',
          'decorators',
        ],
        aliases: ['Scopable', 'Class', 'Expression'],
        fields: {
          id: { validate: (0, l.assertNodeType)('Identifier'), optional: true },
          typeParameters: {
            validate: (0, l.assertNodeType)(
              'TypeParameterDeclaration',
              'TSTypeParameterDeclaration',
              'Noop',
            ),
            optional: true,
          },
          body: { validate: (0, l.assertNodeType)('ClassBody') },
          superClass: {
            optional: true,
            validate: (0, l.assertNodeType)('Expression'),
          },
          superTypeParameters: {
            validate: (0, l.assertNodeType)(
              'TypeParameterInstantiation',
              'TSTypeParameterInstantiation',
            ),
            optional: true,
          },
          implements: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)(
                (0, l.assertNodeType)(
                  'TSExpressionWithTypeArguments',
                  'ClassImplements',
                ),
              ),
            ),
            optional: true,
          },
          decorators: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Decorator')),
            ),
            optional: true,
          },
          mixins: {
            validate: (0, l.assertNodeType)('InterfaceExtends'),
            optional: true,
          },
        },
      });
      c('ClassDeclaration', {
        inherits: 'ClassExpression',
        aliases: ['Scopable', 'Class', 'Statement', 'Declaration'],
        fields: {
          id: { validate: (0, l.assertNodeType)('Identifier'), optional: true },
          typeParameters: {
            validate: (0, l.assertNodeType)(
              'TypeParameterDeclaration',
              'TSTypeParameterDeclaration',
              'Noop',
            ),
            optional: true,
          },
          body: { validate: (0, l.assertNodeType)('ClassBody') },
          superClass: {
            optional: true,
            validate: (0, l.assertNodeType)('Expression'),
          },
          superTypeParameters: {
            validate: (0, l.assertNodeType)(
              'TypeParameterInstantiation',
              'TSTypeParameterInstantiation',
            ),
            optional: true,
          },
          implements: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)(
                (0, l.assertNodeType)(
                  'TSExpressionWithTypeArguments',
                  'ClassImplements',
                ),
              ),
            ),
            optional: true,
          },
          decorators: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Decorator')),
            ),
            optional: true,
          },
          mixins: {
            validate: (0, l.assertNodeType)('InterfaceExtends'),
            optional: true,
          },
          declare: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
          abstract: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
        },
        validate: (function () {
          const e = (0, l.assertNodeType)('Identifier');
          return function (t, r, i) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;
            if (!(0, s.default)('ExportDefaultDeclaration', t)) {
              e(i, 'id', i.id);
            }
          };
        })(),
      });
      c('ExportAllDeclaration', {
        builder: ['source'],
        visitor: ['source', 'attributes', 'assertions'],
        aliases: [
          'Statement',
          'Declaration',
          'ImportOrExportDeclaration',
          'ExportDeclaration',
        ],
        fields: {
          source: { validate: (0, l.assertNodeType)('StringLiteral') },
          exportKind: (0, l.validateOptional)(
            (0, l.assertOneOf)('type', 'value'),
          ),
          attributes: {
            optional: true,
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('ImportAttribute')),
            ),
          },
          assertions: {
            optional: true,
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('ImportAttribute')),
            ),
          },
        },
      });
      c('ExportDefaultDeclaration', {
        visitor: ['declaration'],
        aliases: [
          'Statement',
          'Declaration',
          'ImportOrExportDeclaration',
          'ExportDeclaration',
        ],
        fields: {
          declaration: {
            validate: (0, l.assertNodeType)(
              'TSDeclareFunction',
              'FunctionDeclaration',
              'ClassDeclaration',
              'Expression',
            ),
          },
          exportKind: (0, l.validateOptional)((0, l.assertOneOf)('value')),
        },
      });
      c('ExportNamedDeclaration', {
        builder: ['declaration', 'specifiers', 'source'],
        visitor: [
          'declaration',
          'specifiers',
          'source',
          'attributes',
          'assertions',
        ],
        aliases: [
          'Statement',
          'Declaration',
          'ImportOrExportDeclaration',
          'ExportDeclaration',
        ],
        fields: {
          declaration: {
            optional: true,
            validate: (0, l.chain)(
              (0, l.assertNodeType)('Declaration'),
              Object.assign(
                function (e, t, r) {
                  if (!process.env.BABEL_TYPES_8_BREAKING) return;
                  if (r && e.specifiers.length) {
                    throw new TypeError(
                      'Only declaration or specifiers is allowed on ExportNamedDeclaration',
                    );
                  }
                },
                { oneOfNodeTypes: ['Declaration'] },
              ),
              function (e, t, r) {
                if (!process.env.BABEL_TYPES_8_BREAKING) return;
                if (r && e.source) {
                  throw new TypeError(
                    'Cannot export a declaration from a source',
                  );
                }
              },
            ),
          },
          attributes: {
            optional: true,
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('ImportAttribute')),
            ),
          },
          assertions: {
            optional: true,
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('ImportAttribute')),
            ),
          },
          specifiers: {
            default: [],
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)(
                (function () {
                  const e = (0, l.assertNodeType)(
                    'ExportSpecifier',
                    'ExportDefaultSpecifier',
                    'ExportNamespaceSpecifier',
                  );
                  const t = (0, l.assertNodeType)('ExportSpecifier');
                  if (!process.env.BABEL_TYPES_8_BREAKING) return e;
                  return function (r, s, i) {
                    const n = r.source ? e : t;
                    n(r, s, i);
                  };
                })(),
              ),
            ),
          },
          source: {
            validate: (0, l.assertNodeType)('StringLiteral'),
            optional: true,
          },
          exportKind: (0, l.validateOptional)(
            (0, l.assertOneOf)('type', 'value'),
          ),
        },
      });
      c('ExportSpecifier', {
        visitor: ['local', 'exported'],
        aliases: ['ModuleSpecifier'],
        fields: {
          local: { validate: (0, l.assertNodeType)('Identifier') },
          exported: {
            validate: (0, l.assertNodeType)('Identifier', 'StringLiteral'),
          },
          exportKind: {
            validate: (0, l.assertOneOf)('type', 'value'),
            optional: true,
          },
        },
      });
      c('ForOfStatement', {
        visitor: ['left', 'right', 'body'],
        builder: ['left', 'right', 'body', 'await'],
        aliases: [
          'Scopable',
          'Statement',
          'For',
          'BlockParent',
          'Loop',
          'ForXStatement',
        ],
        fields: {
          left: {
            validate: (function () {
              if (!process.env.BABEL_TYPES_8_BREAKING) {
                return (0, l.assertNodeType)('VariableDeclaration', 'LVal');
              }
              const e = (0, l.assertNodeType)('VariableDeclaration');
              const t = (0, l.assertNodeType)(
                'Identifier',
                'MemberExpression',
                'ArrayPattern',
                'ObjectPattern',
                'TSAsExpression',
                'TSSatisfiesExpression',
                'TSTypeAssertion',
                'TSNonNullExpression',
              );
              return function (r, i, n) {
                if ((0, s.default)('VariableDeclaration', n)) {
                  e(r, i, n);
                } else {
                  t(r, i, n);
                }
              };
            })(),
          },
          right: { validate: (0, l.assertNodeType)('Expression') },
          body: { validate: (0, l.assertNodeType)('Statement') },
          await: { default: false },
        },
      });
      c('ImportDeclaration', {
        builder: ['specifiers', 'source'],
        visitor: ['specifiers', 'source', 'attributes', 'assertions'],
        aliases: ['Statement', 'Declaration', 'ImportOrExportDeclaration'],
        fields: {
          attributes: {
            optional: true,
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('ImportAttribute')),
            ),
          },
          assertions: {
            optional: true,
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('ImportAttribute')),
            ),
          },
          module: {
            optional: true,
            validate: (0, l.assertValueType)('boolean'),
          },
          phase: {
            default: null,
            validate: (0, l.assertOneOf)('source', 'defer'),
          },
          specifiers: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)(
                (0, l.assertNodeType)(
                  'ImportSpecifier',
                  'ImportDefaultSpecifier',
                  'ImportNamespaceSpecifier',
                ),
              ),
            ),
          },
          source: { validate: (0, l.assertNodeType)('StringLiteral') },
          importKind: {
            validate: (0, l.assertOneOf)('type', 'typeof', 'value'),
            optional: true,
          },
        },
      });
      c('ImportDefaultSpecifier', {
        visitor: ['local'],
        aliases: ['ModuleSpecifier'],
        fields: { local: { validate: (0, l.assertNodeType)('Identifier') } },
      });
      c('ImportNamespaceSpecifier', {
        visitor: ['local'],
        aliases: ['ModuleSpecifier'],
        fields: { local: { validate: (0, l.assertNodeType)('Identifier') } },
      });
      c('ImportSpecifier', {
        visitor: ['local', 'imported'],
        aliases: ['ModuleSpecifier'],
        fields: {
          local: { validate: (0, l.assertNodeType)('Identifier') },
          imported: {
            validate: (0, l.assertNodeType)('Identifier', 'StringLiteral'),
          },
          importKind: {
            validate: (0, l.assertOneOf)('type', 'typeof', 'value'),
            optional: true,
          },
        },
      });
      c('ImportExpression', {
        visitor: ['source', 'options'],
        aliases: ['Expression'],
        fields: {
          phase: {
            default: null,
            validate: (0, l.assertOneOf)('source', 'defer'),
          },
          source: { validate: (0, l.assertNodeType)('Expression') },
          options: {
            validate: (0, l.assertNodeType)('Expression'),
            optional: true,
          },
        },
      });
      c('MetaProperty', {
        visitor: ['meta', 'property'],
        aliases: ['Expression'],
        fields: {
          meta: {
            validate: (0, l.chain)(
              (0, l.assertNodeType)('Identifier'),
              Object.assign(
                function (e, t, r) {
                  if (!process.env.BABEL_TYPES_8_BREAKING) return;
                  let i;
                  switch (r.name) {
                    case 'function':
                      i = 'sent';
                      break;
                    case 'new':
                      i = 'target';
                      break;
                    case 'import':
                      i = 'meta';
                      break;
                  }
                  if (!(0, s.default)('Identifier', e.property, { name: i })) {
                    throw new TypeError('Unrecognised MetaProperty');
                  }
                },
                { oneOfNodeTypes: ['Identifier'] },
              ),
            ),
          },
          property: { validate: (0, l.assertNodeType)('Identifier') },
        },
      });
      const classMethodOrPropertyCommon = () => ({
        abstract: {
          validate: (0, l.assertValueType)('boolean'),
          optional: true,
        },
        accessibility: {
          validate: (0, l.assertOneOf)('public', 'private', 'protected'),
          optional: true,
        },
        static: { default: false },
        override: { default: false },
        computed: { default: false },
        optional: {
          validate: (0, l.assertValueType)('boolean'),
          optional: true,
        },
        key: {
          validate: (0, l.chain)(
            (function () {
              const e = (0, l.assertNodeType)(
                'Identifier',
                'StringLiteral',
                'NumericLiteral',
              );
              const t = (0, l.assertNodeType)('Expression');
              return function (r, s, i) {
                const n = r.computed ? t : e;
                n(r, s, i);
              };
            })(),
            (0, l.assertNodeType)(
              'Identifier',
              'StringLiteral',
              'NumericLiteral',
              'BigIntLiteral',
              'Expression',
            ),
          ),
        },
      });
      t.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
      const classMethodOrDeclareMethodCommon = () =>
        Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
          params: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)(
                (0, l.assertNodeType)(
                  'Identifier',
                  'Pattern',
                  'RestElement',
                  'TSParameterProperty',
                ),
              ),
            ),
          },
          kind: {
            validate: (0, l.assertOneOf)('get', 'set', 'method', 'constructor'),
            default: 'method',
          },
          access: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('string'),
              (0, l.assertOneOf)('public', 'private', 'protected'),
            ),
            optional: true,
          },
          decorators: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Decorator')),
            ),
            optional: true,
          },
        });
      t.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
      c('ClassMethod', {
        aliases: [
          'Function',
          'Scopable',
          'BlockParent',
          'FunctionParent',
          'Method',
        ],
        builder: [
          'kind',
          'key',
          'params',
          'body',
          'computed',
          'static',
          'generator',
          'async',
        ],
        visitor: [
          'key',
          'params',
          'body',
          'decorators',
          'returnType',
          'typeParameters',
        ],
        fields: Object.assign(
          {},
          classMethodOrDeclareMethodCommon(),
          functionTypeAnnotationCommon(),
          { body: { validate: (0, l.assertNodeType)('BlockStatement') } },
        ),
      });
      c('ObjectPattern', {
        visitor: ['properties', 'typeAnnotation', 'decorators'],
        builder: ['properties'],
        aliases: ['Pattern', 'PatternLike', 'LVal'],
        fields: Object.assign({}, patternLikeCommon(), {
          properties: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)(
                (0, l.assertNodeType)('RestElement', 'ObjectProperty'),
              ),
            ),
          },
        }),
      });
      c('SpreadElement', {
        visitor: ['argument'],
        aliases: ['UnaryLike'],
        deprecatedAlias: 'SpreadProperty',
        fields: { argument: { validate: (0, l.assertNodeType)('Expression') } },
      });
      c('Super', { aliases: ['Expression'] });
      c('TaggedTemplateExpression', {
        visitor: ['tag', 'quasi', 'typeParameters'],
        builder: ['tag', 'quasi'],
        aliases: ['Expression'],
        fields: {
          tag: { validate: (0, l.assertNodeType)('Expression') },
          quasi: { validate: (0, l.assertNodeType)('TemplateLiteral') },
          typeParameters: {
            validate: (0, l.assertNodeType)(
              'TypeParameterInstantiation',
              'TSTypeParameterInstantiation',
            ),
            optional: true,
          },
        },
      });
      c('TemplateElement', {
        builder: ['value', 'tail'],
        fields: {
          value: {
            validate: (0, l.chain)(
              (0, l.assertShape)({
                raw: { validate: (0, l.assertValueType)('string') },
                cooked: {
                  validate: (0, l.assertValueType)('string'),
                  optional: true,
                },
              }),
              function templateElementCookedValidator(e) {
                const t = e.value.raw;
                let r = false;
                const error = () => {
                  throw new Error('Internal @babel/types error.');
                };
                const { str: s, firstInvalidLoc: i } = (0,
                a.readStringContents)('template', t, 0, 0, 0, {
                  unterminated() {
                    r = true;
                  },
                  strictNumericEscape: error,
                  invalidEscapeSequence: error,
                  numericSeparatorInEscapeSequence: error,
                  unexpectedNumericSeparator: error,
                  invalidDigit: error,
                  invalidCodePoint: error,
                });
                if (!r) throw new Error('Invalid raw');
                e.value.cooked = i ? null : s;
              },
            ),
          },
          tail: { default: false },
        },
      });
      c('TemplateLiteral', {
        visitor: ['quasis', 'expressions'],
        aliases: ['Expression', 'Literal'],
        fields: {
          quasis: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('TemplateElement')),
            ),
          },
          expressions: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Expression', 'TSType')),
              function (e, t, r) {
                if (e.quasis.length !== r.length + 1) {
                  throw new TypeError(
                    `Number of ${
                      e.type
                    } quasis should be exactly one more than the number of expressions.\nExpected ${
                      r.length + 1
                    } quasis but got ${e.quasis.length}`,
                  );
                }
              },
            ),
          },
        },
      });
      c('YieldExpression', {
        builder: ['argument', 'delegate'],
        visitor: ['argument'],
        aliases: ['Expression', 'Terminatorless'],
        fields: {
          delegate: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('boolean'),
              Object.assign(
                function (e, t, r) {
                  if (!process.env.BABEL_TYPES_8_BREAKING) return;
                  if (r && !e.argument) {
                    throw new TypeError(
                      'Property delegate of YieldExpression cannot be true if there is no argument',
                    );
                  }
                },
                { type: 'boolean' },
              ),
            ),
            default: false,
          },
          argument: {
            optional: true,
            validate: (0, l.assertNodeType)('Expression'),
          },
        },
      });
      c('AwaitExpression', {
        builder: ['argument'],
        visitor: ['argument'],
        aliases: ['Expression', 'Terminatorless'],
        fields: { argument: { validate: (0, l.assertNodeType)('Expression') } },
      });
      c('Import', { aliases: ['Expression'] });
      c('BigIntLiteral', {
        builder: ['value'],
        fields: { value: { validate: (0, l.assertValueType)('string') } },
        aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
      });
      c('ExportNamespaceSpecifier', {
        visitor: ['exported'],
        aliases: ['ModuleSpecifier'],
        fields: { exported: { validate: (0, l.assertNodeType)('Identifier') } },
      });
      c('OptionalMemberExpression', {
        builder: ['object', 'property', 'computed', 'optional'],
        visitor: ['object', 'property'],
        aliases: ['Expression'],
        fields: {
          object: { validate: (0, l.assertNodeType)('Expression') },
          property: {
            validate: (function () {
              const e = (0, l.assertNodeType)('Identifier');
              const t = (0, l.assertNodeType)('Expression');
              const r = Object.assign(
                function (r, s, i) {
                  const n = r.computed ? t : e;
                  n(r, s, i);
                },
                { oneOfNodeTypes: ['Expression', 'Identifier'] },
              );
              return r;
            })(),
          },
          computed: { default: false },
          optional: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, l.assertValueType)('boolean')
              : (0, l.chain)(
                  (0, l.assertValueType)('boolean'),
                  (0, l.assertOptionalChainStart)(),
                ),
          },
        },
      });
      c('OptionalCallExpression', {
        visitor: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
        builder: ['callee', 'arguments', 'optional'],
        aliases: ['Expression'],
        fields: {
          callee: { validate: (0, l.assertNodeType)('Expression') },
          arguments: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)(
                (0, l.assertNodeType)(
                  'Expression',
                  'SpreadElement',
                  'JSXNamespacedName',
                  'ArgumentPlaceholder',
                ),
              ),
            ),
          },
          optional: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, l.assertValueType)('boolean')
              : (0, l.chain)(
                  (0, l.assertValueType)('boolean'),
                  (0, l.assertOptionalChainStart)(),
                ),
          },
          typeArguments: {
            validate: (0, l.assertNodeType)('TypeParameterInstantiation'),
            optional: true,
          },
          typeParameters: {
            validate: (0, l.assertNodeType)('TSTypeParameterInstantiation'),
            optional: true,
          },
        },
      });
      c('ClassProperty', {
        visitor: ['key', 'value', 'typeAnnotation', 'decorators'],
        builder: [
          'key',
          'value',
          'typeAnnotation',
          'decorators',
          'computed',
          'static',
        ],
        aliases: ['Property'],
        fields: Object.assign({}, classMethodOrPropertyCommon(), {
          value: {
            validate: (0, l.assertNodeType)('Expression'),
            optional: true,
          },
          definite: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
          typeAnnotation: {
            validate: (0, l.assertNodeType)(
              'TypeAnnotation',
              'TSTypeAnnotation',
              'Noop',
            ),
            optional: true,
          },
          decorators: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Decorator')),
            ),
            optional: true,
          },
          readonly: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
          declare: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
          variance: {
            validate: (0, l.assertNodeType)('Variance'),
            optional: true,
          },
        }),
      });
      c('ClassAccessorProperty', {
        visitor: ['key', 'value', 'typeAnnotation', 'decorators'],
        builder: [
          'key',
          'value',
          'typeAnnotation',
          'decorators',
          'computed',
          'static',
        ],
        aliases: ['Property', 'Accessor'],
        fields: Object.assign({}, classMethodOrPropertyCommon(), {
          key: {
            validate: (0, l.chain)(
              (function () {
                const e = (0, l.assertNodeType)(
                  'Identifier',
                  'StringLiteral',
                  'NumericLiteral',
                  'BigIntLiteral',
                  'PrivateName',
                );
                const t = (0, l.assertNodeType)('Expression');
                return function (r, s, i) {
                  const n = r.computed ? t : e;
                  n(r, s, i);
                };
              })(),
              (0, l.assertNodeType)(
                'Identifier',
                'StringLiteral',
                'NumericLiteral',
                'BigIntLiteral',
                'Expression',
                'PrivateName',
              ),
            ),
          },
          value: {
            validate: (0, l.assertNodeType)('Expression'),
            optional: true,
          },
          definite: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
          typeAnnotation: {
            validate: (0, l.assertNodeType)(
              'TypeAnnotation',
              'TSTypeAnnotation',
              'Noop',
            ),
            optional: true,
          },
          decorators: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Decorator')),
            ),
            optional: true,
          },
          readonly: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
          declare: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
          variance: {
            validate: (0, l.assertNodeType)('Variance'),
            optional: true,
          },
        }),
      });
      c('ClassPrivateProperty', {
        visitor: ['key', 'value', 'decorators', 'typeAnnotation'],
        builder: ['key', 'value', 'decorators', 'static'],
        aliases: ['Property', 'Private'],
        fields: {
          key: { validate: (0, l.assertNodeType)('PrivateName') },
          value: {
            validate: (0, l.assertNodeType)('Expression'),
            optional: true,
          },
          typeAnnotation: {
            validate: (0, l.assertNodeType)(
              'TypeAnnotation',
              'TSTypeAnnotation',
              'Noop',
            ),
            optional: true,
          },
          decorators: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Decorator')),
            ),
            optional: true,
          },
          static: {
            validate: (0, l.assertValueType)('boolean'),
            default: false,
          },
          readonly: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
          definite: {
            validate: (0, l.assertValueType)('boolean'),
            optional: true,
          },
          variance: {
            validate: (0, l.assertNodeType)('Variance'),
            optional: true,
          },
        },
      });
      c('ClassPrivateMethod', {
        builder: ['kind', 'key', 'params', 'body', 'static'],
        visitor: [
          'key',
          'params',
          'body',
          'decorators',
          'returnType',
          'typeParameters',
        ],
        aliases: [
          'Function',
          'Scopable',
          'BlockParent',
          'FunctionParent',
          'Method',
          'Private',
        ],
        fields: Object.assign(
          {},
          classMethodOrDeclareMethodCommon(),
          functionTypeAnnotationCommon(),
          {
            kind: {
              validate: (0, l.assertOneOf)('get', 'set', 'method'),
              default: 'method',
            },
            key: { validate: (0, l.assertNodeType)('PrivateName') },
            body: { validate: (0, l.assertNodeType)('BlockStatement') },
          },
        ),
      });
      c('PrivateName', {
        visitor: ['id'],
        aliases: ['Private'],
        fields: { id: { validate: (0, l.assertNodeType)('Identifier') } },
      });
      c('StaticBlock', {
        visitor: ['body'],
        fields: {
          body: {
            validate: (0, l.chain)(
              (0, l.assertValueType)('array'),
              (0, l.assertEach)((0, l.assertNodeType)('Statement')),
            ),
          },
        },
        aliases: ['Scopable', 'BlockParent', 'FunctionParent'],
      });
    },
    1875: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.DEPRECATED_ALIASES = void 0;
      const r = (t.DEPRECATED_ALIASES = {
        ModuleDeclaration: 'ImportOrExportDeclaration',
      });
    },
    5035: function (e, t, r) {
      'use strict';
      var s = r(1903);
      (0, s.default)('ArgumentPlaceholder', {});
      (0, s.default)('BindExpression', {
        visitor: ['object', 'callee'],
        aliases: ['Expression'],
        fields: !process.env.BABEL_TYPES_8_BREAKING
          ? {
              object: {
                validate: Object.assign(() => {}, {
                  oneOfNodeTypes: ['Expression'],
                }),
              },
              callee: {
                validate: Object.assign(() => {}, {
                  oneOfNodeTypes: ['Expression'],
                }),
              },
            }
          : {
              object: { validate: (0, s.assertNodeType)('Expression') },
              callee: { validate: (0, s.assertNodeType)('Expression') },
            },
      });
      (0, s.default)('ImportAttribute', {
        visitor: ['key', 'value'],
        fields: {
          key: {
            validate: (0, s.assertNodeType)('Identifier', 'StringLiteral'),
          },
          value: { validate: (0, s.assertNodeType)('StringLiteral') },
        },
      });
      (0, s.default)('Decorator', {
        visitor: ['expression'],
        fields: {
          expression: { validate: (0, s.assertNodeType)('Expression') },
        },
      });
      (0, s.default)('DoExpression', {
        visitor: ['body'],
        builder: ['body', 'async'],
        aliases: ['Expression'],
        fields: {
          body: { validate: (0, s.assertNodeType)('BlockStatement') },
          async: {
            validate: (0, s.assertValueType)('boolean'),
            default: false,
          },
        },
      });
      (0, s.default)('ExportDefaultSpecifier', {
        visitor: ['exported'],
        aliases: ['ModuleSpecifier'],
        fields: { exported: { validate: (0, s.assertNodeType)('Identifier') } },
      });
      (0, s.default)('RecordExpression', {
        visitor: ['properties'],
        aliases: ['Expression'],
        fields: {
          properties: {
            validate: (0, s.chain)(
              (0, s.assertValueType)('array'),
              (0, s.assertEach)(
                (0, s.assertNodeType)('ObjectProperty', 'SpreadElement'),
              ),
            ),
          },
        },
      });
      (0, s.default)('TupleExpression', {
        fields: {
          elements: {
            validate: (0, s.chain)(
              (0, s.assertValueType)('array'),
              (0, s.assertEach)(
                (0, s.assertNodeType)('Expression', 'SpreadElement'),
              ),
            ),
            default: [],
          },
        },
        visitor: ['elements'],
        aliases: ['Expression'],
      });
      (0, s.default)('DecimalLiteral', {
        builder: ['value'],
        fields: { value: { validate: (0, s.assertValueType)('string') } },
        aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
      });
      (0, s.default)('ModuleExpression', {
        visitor: ['body'],
        fields: { body: { validate: (0, s.assertNodeType)('Program') } },
        aliases: ['Expression'],
      });
      (0, s.default)('TopicReference', { aliases: ['Expression'] });
      (0, s.default)('PipelineTopicExpression', {
        builder: ['expression'],
        visitor: ['expression'],
        fields: {
          expression: { validate: (0, s.assertNodeType)('Expression') },
        },
        aliases: ['Expression'],
      });
      (0, s.default)('PipelineBareFunction', {
        builder: ['callee'],
        visitor: ['callee'],
        fields: { callee: { validate: (0, s.assertNodeType)('Expression') } },
        aliases: ['Expression'],
      });
      (0, s.default)('PipelinePrimaryTopicReference', {
        aliases: ['Expression'],
      });
    },
    7069: function (e, t, r) {
      'use strict';
      var s = r(1903);
      const i = (0, s.defineAliasedType)('Flow');
      const defineInterfaceishType = (e) => {
        const t = e === 'DeclareClass';
        i(e, {
          builder: ['id', 'typeParameters', 'extends', 'body'],
          visitor: [
            'id',
            'typeParameters',
            'extends',
            ...(t ? ['mixins', 'implements'] : []),
            'body',
          ],
          aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
          fields: Object.assign(
            {
              id: (0, s.validateType)('Identifier'),
              typeParameters: (0, s.validateOptionalType)(
                'TypeParameterDeclaration',
              ),
              extends: (0, s.validateOptional)(
                (0, s.arrayOfType)('InterfaceExtends'),
              ),
            },
            t
              ? {
                  mixins: (0, s.validateOptional)(
                    (0, s.arrayOfType)('InterfaceExtends'),
                  ),
                  implements: (0, s.validateOptional)(
                    (0, s.arrayOfType)('ClassImplements'),
                  ),
                }
              : {},
            { body: (0, s.validateType)('ObjectTypeAnnotation') },
          ),
        });
      };
      i('AnyTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] });
      i('ArrayTypeAnnotation', {
        visitor: ['elementType'],
        aliases: ['FlowType'],
        fields: { elementType: (0, s.validateType)('FlowType') },
      });
      i('BooleanTypeAnnotation', {
        aliases: ['FlowType', 'FlowBaseAnnotation'],
      });
      i('BooleanLiteralTypeAnnotation', {
        builder: ['value'],
        aliases: ['FlowType'],
        fields: { value: (0, s.validate)((0, s.assertValueType)('boolean')) },
      });
      i('NullLiteralTypeAnnotation', {
        aliases: ['FlowType', 'FlowBaseAnnotation'],
      });
      i('ClassImplements', {
        visitor: ['id', 'typeParameters'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          typeParameters: (0, s.validateOptionalType)(
            'TypeParameterInstantiation',
          ),
        },
      });
      defineInterfaceishType('DeclareClass');
      i('DeclareFunction', {
        visitor: ['id'],
        aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          predicate: (0, s.validateOptionalType)('DeclaredPredicate'),
        },
      });
      defineInterfaceishType('DeclareInterface');
      i('DeclareModule', {
        builder: ['id', 'body', 'kind'],
        visitor: ['id', 'body'],
        aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
        fields: {
          id: (0, s.validateType)(['Identifier', 'StringLiteral']),
          body: (0, s.validateType)('BlockStatement'),
          kind: (0, s.validateOptional)((0, s.assertOneOf)('CommonJS', 'ES')),
        },
      });
      i('DeclareModuleExports', {
        visitor: ['typeAnnotation'],
        aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
        fields: { typeAnnotation: (0, s.validateType)('TypeAnnotation') },
      });
      i('DeclareTypeAlias', {
        visitor: ['id', 'typeParameters', 'right'],
        aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          typeParameters: (0, s.validateOptionalType)(
            'TypeParameterDeclaration',
          ),
          right: (0, s.validateType)('FlowType'),
        },
      });
      i('DeclareOpaqueType', {
        visitor: ['id', 'typeParameters', 'supertype'],
        aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          typeParameters: (0, s.validateOptionalType)(
            'TypeParameterDeclaration',
          ),
          supertype: (0, s.validateOptionalType)('FlowType'),
          impltype: (0, s.validateOptionalType)('FlowType'),
        },
      });
      i('DeclareVariable', {
        visitor: ['id'],
        aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
        fields: { id: (0, s.validateType)('Identifier') },
      });
      i('DeclareExportDeclaration', {
        visitor: ['declaration', 'specifiers', 'source'],
        aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
        fields: {
          declaration: (0, s.validateOptionalType)('Flow'),
          specifiers: (0, s.validateOptional)(
            (0, s.arrayOfType)(['ExportSpecifier', 'ExportNamespaceSpecifier']),
          ),
          source: (0, s.validateOptionalType)('StringLiteral'),
          default: (0, s.validateOptional)((0, s.assertValueType)('boolean')),
        },
      });
      i('DeclareExportAllDeclaration', {
        visitor: ['source'],
        aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
        fields: {
          source: (0, s.validateType)('StringLiteral'),
          exportKind: (0, s.validateOptional)(
            (0, s.assertOneOf)('type', 'value'),
          ),
        },
      });
      i('DeclaredPredicate', {
        visitor: ['value'],
        aliases: ['FlowPredicate'],
        fields: { value: (0, s.validateType)('Flow') },
      });
      i('ExistsTypeAnnotation', { aliases: ['FlowType'] });
      i('FunctionTypeAnnotation', {
        visitor: ['typeParameters', 'params', 'rest', 'returnType'],
        aliases: ['FlowType'],
        fields: {
          typeParameters: (0, s.validateOptionalType)(
            'TypeParameterDeclaration',
          ),
          params: (0, s.validate)((0, s.arrayOfType)('FunctionTypeParam')),
          rest: (0, s.validateOptionalType)('FunctionTypeParam'),
          this: (0, s.validateOptionalType)('FunctionTypeParam'),
          returnType: (0, s.validateType)('FlowType'),
        },
      });
      i('FunctionTypeParam', {
        visitor: ['name', 'typeAnnotation'],
        fields: {
          name: (0, s.validateOptionalType)('Identifier'),
          typeAnnotation: (0, s.validateType)('FlowType'),
          optional: (0, s.validateOptional)((0, s.assertValueType)('boolean')),
        },
      });
      i('GenericTypeAnnotation', {
        visitor: ['id', 'typeParameters'],
        aliases: ['FlowType'],
        fields: {
          id: (0, s.validateType)(['Identifier', 'QualifiedTypeIdentifier']),
          typeParameters: (0, s.validateOptionalType)(
            'TypeParameterInstantiation',
          ),
        },
      });
      i('InferredPredicate', { aliases: ['FlowPredicate'] });
      i('InterfaceExtends', {
        visitor: ['id', 'typeParameters'],
        fields: {
          id: (0, s.validateType)(['Identifier', 'QualifiedTypeIdentifier']),
          typeParameters: (0, s.validateOptionalType)(
            'TypeParameterInstantiation',
          ),
        },
      });
      defineInterfaceishType('InterfaceDeclaration');
      i('InterfaceTypeAnnotation', {
        visitor: ['extends', 'body'],
        aliases: ['FlowType'],
        fields: {
          extends: (0, s.validateOptional)(
            (0, s.arrayOfType)('InterfaceExtends'),
          ),
          body: (0, s.validateType)('ObjectTypeAnnotation'),
        },
      });
      i('IntersectionTypeAnnotation', {
        visitor: ['types'],
        aliases: ['FlowType'],
        fields: { types: (0, s.validate)((0, s.arrayOfType)('FlowType')) },
      });
      i('MixedTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] });
      i('EmptyTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] });
      i('NullableTypeAnnotation', {
        visitor: ['typeAnnotation'],
        aliases: ['FlowType'],
        fields: { typeAnnotation: (0, s.validateType)('FlowType') },
      });
      i('NumberLiteralTypeAnnotation', {
        builder: ['value'],
        aliases: ['FlowType'],
        fields: { value: (0, s.validate)((0, s.assertValueType)('number')) },
      });
      i('NumberTypeAnnotation', {
        aliases: ['FlowType', 'FlowBaseAnnotation'],
      });
      i('ObjectTypeAnnotation', {
        visitor: ['properties', 'indexers', 'callProperties', 'internalSlots'],
        aliases: ['FlowType'],
        builder: [
          'properties',
          'indexers',
          'callProperties',
          'internalSlots',
          'exact',
        ],
        fields: {
          properties: (0, s.validate)(
            (0, s.arrayOfType)([
              'ObjectTypeProperty',
              'ObjectTypeSpreadProperty',
            ]),
          ),
          indexers: {
            validate: (0, s.arrayOfType)('ObjectTypeIndexer'),
            optional: true,
            default: [],
          },
          callProperties: {
            validate: (0, s.arrayOfType)('ObjectTypeCallProperty'),
            optional: true,
            default: [],
          },
          internalSlots: {
            validate: (0, s.arrayOfType)('ObjectTypeInternalSlot'),
            optional: true,
            default: [],
          },
          exact: {
            validate: (0, s.assertValueType)('boolean'),
            default: false,
          },
          inexact: (0, s.validateOptional)((0, s.assertValueType)('boolean')),
        },
      });
      i('ObjectTypeInternalSlot', {
        visitor: ['id', 'value', 'optional', 'static', 'method'],
        aliases: ['UserWhitespacable'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          value: (0, s.validateType)('FlowType'),
          optional: (0, s.validate)((0, s.assertValueType)('boolean')),
          static: (0, s.validate)((0, s.assertValueType)('boolean')),
          method: (0, s.validate)((0, s.assertValueType)('boolean')),
        },
      });
      i('ObjectTypeCallProperty', {
        visitor: ['value'],
        aliases: ['UserWhitespacable'],
        fields: {
          value: (0, s.validateType)('FlowType'),
          static: (0, s.validate)((0, s.assertValueType)('boolean')),
        },
      });
      i('ObjectTypeIndexer', {
        visitor: ['id', 'key', 'value', 'variance'],
        aliases: ['UserWhitespacable'],
        fields: {
          id: (0, s.validateOptionalType)('Identifier'),
          key: (0, s.validateType)('FlowType'),
          value: (0, s.validateType)('FlowType'),
          static: (0, s.validate)((0, s.assertValueType)('boolean')),
          variance: (0, s.validateOptionalType)('Variance'),
        },
      });
      i('ObjectTypeProperty', {
        visitor: ['key', 'value', 'variance'],
        aliases: ['UserWhitespacable'],
        fields: {
          key: (0, s.validateType)(['Identifier', 'StringLiteral']),
          value: (0, s.validateType)('FlowType'),
          kind: (0, s.validate)((0, s.assertOneOf)('init', 'get', 'set')),
          static: (0, s.validate)((0, s.assertValueType)('boolean')),
          proto: (0, s.validate)((0, s.assertValueType)('boolean')),
          optional: (0, s.validate)((0, s.assertValueType)('boolean')),
          variance: (0, s.validateOptionalType)('Variance'),
          method: (0, s.validate)((0, s.assertValueType)('boolean')),
        },
      });
      i('ObjectTypeSpreadProperty', {
        visitor: ['argument'],
        aliases: ['UserWhitespacable'],
        fields: { argument: (0, s.validateType)('FlowType') },
      });
      i('OpaqueType', {
        visitor: ['id', 'typeParameters', 'supertype', 'impltype'],
        aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          typeParameters: (0, s.validateOptionalType)(
            'TypeParameterDeclaration',
          ),
          supertype: (0, s.validateOptionalType)('FlowType'),
          impltype: (0, s.validateType)('FlowType'),
        },
      });
      i('QualifiedTypeIdentifier', {
        visitor: ['id', 'qualification'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          qualification: (0, s.validateType)([
            'Identifier',
            'QualifiedTypeIdentifier',
          ]),
        },
      });
      i('StringLiteralTypeAnnotation', {
        builder: ['value'],
        aliases: ['FlowType'],
        fields: { value: (0, s.validate)((0, s.assertValueType)('string')) },
      });
      i('StringTypeAnnotation', {
        aliases: ['FlowType', 'FlowBaseAnnotation'],
      });
      i('SymbolTypeAnnotation', {
        aliases: ['FlowType', 'FlowBaseAnnotation'],
      });
      i('ThisTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] });
      i('TupleTypeAnnotation', {
        visitor: ['types'],
        aliases: ['FlowType'],
        fields: { types: (0, s.validate)((0, s.arrayOfType)('FlowType')) },
      });
      i('TypeofTypeAnnotation', {
        visitor: ['argument'],
        aliases: ['FlowType'],
        fields: { argument: (0, s.validateType)('FlowType') },
      });
      i('TypeAlias', {
        visitor: ['id', 'typeParameters', 'right'],
        aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          typeParameters: (0, s.validateOptionalType)(
            'TypeParameterDeclaration',
          ),
          right: (0, s.validateType)('FlowType'),
        },
      });
      i('TypeAnnotation', {
        visitor: ['typeAnnotation'],
        fields: { typeAnnotation: (0, s.validateType)('FlowType') },
      });
      i('TypeCastExpression', {
        visitor: ['expression', 'typeAnnotation'],
        aliases: ['ExpressionWrapper', 'Expression'],
        fields: {
          expression: (0, s.validateType)('Expression'),
          typeAnnotation: (0, s.validateType)('TypeAnnotation'),
        },
      });
      i('TypeParameter', {
        visitor: ['bound', 'default', 'variance'],
        fields: {
          name: (0, s.validate)((0, s.assertValueType)('string')),
          bound: (0, s.validateOptionalType)('TypeAnnotation'),
          default: (0, s.validateOptionalType)('FlowType'),
          variance: (0, s.validateOptionalType)('Variance'),
        },
      });
      i('TypeParameterDeclaration', {
        visitor: ['params'],
        fields: {
          params: (0, s.validate)((0, s.arrayOfType)('TypeParameter')),
        },
      });
      i('TypeParameterInstantiation', {
        visitor: ['params'],
        fields: { params: (0, s.validate)((0, s.arrayOfType)('FlowType')) },
      });
      i('UnionTypeAnnotation', {
        visitor: ['types'],
        aliases: ['FlowType'],
        fields: { types: (0, s.validate)((0, s.arrayOfType)('FlowType')) },
      });
      i('Variance', {
        builder: ['kind'],
        fields: { kind: (0, s.validate)((0, s.assertOneOf)('minus', 'plus')) },
      });
      i('VoidTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] });
      i('EnumDeclaration', {
        aliases: ['Statement', 'Declaration'],
        visitor: ['id', 'body'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          body: (0, s.validateType)([
            'EnumBooleanBody',
            'EnumNumberBody',
            'EnumStringBody',
            'EnumSymbolBody',
          ]),
        },
      });
      i('EnumBooleanBody', {
        aliases: ['EnumBody'],
        visitor: ['members'],
        fields: {
          explicitType: (0, s.validate)((0, s.assertValueType)('boolean')),
          members: (0, s.validateArrayOfType)('EnumBooleanMember'),
          hasUnknownMembers: (0, s.validate)((0, s.assertValueType)('boolean')),
        },
      });
      i('EnumNumberBody', {
        aliases: ['EnumBody'],
        visitor: ['members'],
        fields: {
          explicitType: (0, s.validate)((0, s.assertValueType)('boolean')),
          members: (0, s.validateArrayOfType)('EnumNumberMember'),
          hasUnknownMembers: (0, s.validate)((0, s.assertValueType)('boolean')),
        },
      });
      i('EnumStringBody', {
        aliases: ['EnumBody'],
        visitor: ['members'],
        fields: {
          explicitType: (0, s.validate)((0, s.assertValueType)('boolean')),
          members: (0, s.validateArrayOfType)([
            'EnumStringMember',
            'EnumDefaultedMember',
          ]),
          hasUnknownMembers: (0, s.validate)((0, s.assertValueType)('boolean')),
        },
      });
      i('EnumSymbolBody', {
        aliases: ['EnumBody'],
        visitor: ['members'],
        fields: {
          members: (0, s.validateArrayOfType)('EnumDefaultedMember'),
          hasUnknownMembers: (0, s.validate)((0, s.assertValueType)('boolean')),
        },
      });
      i('EnumBooleanMember', {
        aliases: ['EnumMember'],
        visitor: ['id'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          init: (0, s.validateType)('BooleanLiteral'),
        },
      });
      i('EnumNumberMember', {
        aliases: ['EnumMember'],
        visitor: ['id', 'init'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          init: (0, s.validateType)('NumericLiteral'),
        },
      });
      i('EnumStringMember', {
        aliases: ['EnumMember'],
        visitor: ['id', 'init'],
        fields: {
          id: (0, s.validateType)('Identifier'),
          init: (0, s.validateType)('StringLiteral'),
        },
      });
      i('EnumDefaultedMember', {
        aliases: ['EnumMember'],
        visitor: ['id'],
        fields: { id: (0, s.validateType)('Identifier') },
      });
      i('IndexedAccessType', {
        visitor: ['objectType', 'indexType'],
        aliases: ['FlowType'],
        fields: {
          objectType: (0, s.validateType)('FlowType'),
          indexType: (0, s.validateType)('FlowType'),
        },
      });
      i('OptionalIndexedAccessType', {
        visitor: ['objectType', 'indexType'],
        aliases: ['FlowType'],
        fields: {
          objectType: (0, s.validateType)('FlowType'),
          indexType: (0, s.validateType)('FlowType'),
          optional: (0, s.validate)((0, s.assertValueType)('boolean')),
        },
      });
    },
    7405: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      Object.defineProperty(t, 'ALIAS_KEYS', {
        enumerable: true,
        get: function () {
          return i.ALIAS_KEYS;
        },
      });
      Object.defineProperty(t, 'BUILDER_KEYS', {
        enumerable: true,
        get: function () {
          return i.BUILDER_KEYS;
        },
      });
      Object.defineProperty(t, 'DEPRECATED_ALIASES', {
        enumerable: true,
        get: function () {
          return a.DEPRECATED_ALIASES;
        },
      });
      Object.defineProperty(t, 'DEPRECATED_KEYS', {
        enumerable: true,
        get: function () {
          return i.DEPRECATED_KEYS;
        },
      });
      Object.defineProperty(t, 'FLIPPED_ALIAS_KEYS', {
        enumerable: true,
        get: function () {
          return i.FLIPPED_ALIAS_KEYS;
        },
      });
      Object.defineProperty(t, 'NODE_FIELDS', {
        enumerable: true,
        get: function () {
          return i.NODE_FIELDS;
        },
      });
      Object.defineProperty(t, 'NODE_PARENT_VALIDATIONS', {
        enumerable: true,
        get: function () {
          return i.NODE_PARENT_VALIDATIONS;
        },
      });
      Object.defineProperty(t, 'PLACEHOLDERS', {
        enumerable: true,
        get: function () {
          return n.PLACEHOLDERS;
        },
      });
      Object.defineProperty(t, 'PLACEHOLDERS_ALIAS', {
        enumerable: true,
        get: function () {
          return n.PLACEHOLDERS_ALIAS;
        },
      });
      Object.defineProperty(t, 'PLACEHOLDERS_FLIPPED_ALIAS', {
        enumerable: true,
        get: function () {
          return n.PLACEHOLDERS_FLIPPED_ALIAS;
        },
      });
      t.TYPES = void 0;
      Object.defineProperty(t, 'VISITOR_KEYS', {
        enumerable: true,
        get: function () {
          return i.VISITOR_KEYS;
        },
      });
      var s = r(6802);
      r(5967);
      r(7069);
      r(4746);
      r(6742);
      r(5035);
      r(4488);
      var i = r(1903);
      var n = r(1141);
      var a = r(1875);
      Object.keys(a.DEPRECATED_ALIASES).forEach((e) => {
        i.FLIPPED_ALIAS_KEYS[e] = i.FLIPPED_ALIAS_KEYS[a.DEPRECATED_ALIASES[e]];
      });
      s(i.VISITOR_KEYS);
      s(i.ALIAS_KEYS);
      s(i.FLIPPED_ALIAS_KEYS);
      s(i.NODE_FIELDS);
      s(i.BUILDER_KEYS);
      s(i.DEPRECATED_KEYS);
      s(n.PLACEHOLDERS_ALIAS);
      s(n.PLACEHOLDERS_FLIPPED_ALIAS);
      const o = (t.TYPES = [].concat(
        Object.keys(i.VISITOR_KEYS),
        Object.keys(i.FLIPPED_ALIAS_KEYS),
        Object.keys(i.DEPRECATED_KEYS),
      ));
    },
    4746: function (e, t, r) {
      'use strict';
      var s = r(1903);
      const i = (0, s.defineAliasedType)('JSX');
      i('JSXAttribute', {
        visitor: ['name', 'value'],
        aliases: ['Immutable'],
        fields: {
          name: {
            validate: (0, s.assertNodeType)(
              'JSXIdentifier',
              'JSXNamespacedName',
            ),
          },
          value: {
            optional: true,
            validate: (0, s.assertNodeType)(
              'JSXElement',
              'JSXFragment',
              'StringLiteral',
              'JSXExpressionContainer',
            ),
          },
        },
      });
      i('JSXClosingElement', {
        visitor: ['name'],
        aliases: ['Immutable'],
        fields: {
          name: {
            validate: (0, s.assertNodeType)(
              'JSXIdentifier',
              'JSXMemberExpression',
              'JSXNamespacedName',
            ),
          },
        },
      });
      i('JSXElement', {
        builder: [
          'openingElement',
          'closingElement',
          'children',
          'selfClosing',
        ],
        visitor: ['openingElement', 'children', 'closingElement'],
        aliases: ['Immutable', 'Expression'],
        fields: Object.assign(
          {
            openingElement: {
              validate: (0, s.assertNodeType)('JSXOpeningElement'),
            },
            closingElement: {
              optional: true,
              validate: (0, s.assertNodeType)('JSXClosingElement'),
            },
            children: {
              validate: (0, s.chain)(
                (0, s.assertValueType)('array'),
                (0, s.assertEach)(
                  (0, s.assertNodeType)(
                    'JSXText',
                    'JSXExpressionContainer',
                    'JSXSpreadChild',
                    'JSXElement',
                    'JSXFragment',
                  ),
                ),
              ),
            },
          },
          {
            selfClosing: {
              validate: (0, s.assertValueType)('boolean'),
              optional: true,
            },
          },
        ),
      });
      i('JSXEmptyExpression', {});
      i('JSXExpressionContainer', {
        visitor: ['expression'],
        aliases: ['Immutable'],
        fields: {
          expression: {
            validate: (0, s.assertNodeType)('Expression', 'JSXEmptyExpression'),
          },
        },
      });
      i('JSXSpreadChild', {
        visitor: ['expression'],
        aliases: ['Immutable'],
        fields: {
          expression: { validate: (0, s.assertNodeType)('Expression') },
        },
      });
      i('JSXIdentifier', {
        builder: ['name'],
        fields: { name: { validate: (0, s.assertValueType)('string') } },
      });
      i('JSXMemberExpression', {
        visitor: ['object', 'property'],
        fields: {
          object: {
            validate: (0, s.assertNodeType)(
              'JSXMemberExpression',
              'JSXIdentifier',
            ),
          },
          property: { validate: (0, s.assertNodeType)('JSXIdentifier') },
        },
      });
      i('JSXNamespacedName', {
        visitor: ['namespace', 'name'],
        fields: {
          namespace: { validate: (0, s.assertNodeType)('JSXIdentifier') },
          name: { validate: (0, s.assertNodeType)('JSXIdentifier') },
        },
      });
      i('JSXOpeningElement', {
        builder: ['name', 'attributes', 'selfClosing'],
        visitor: ['name', 'attributes'],
        aliases: ['Immutable'],
        fields: {
          name: {
            validate: (0, s.assertNodeType)(
              'JSXIdentifier',
              'JSXMemberExpression',
              'JSXNamespacedName',
            ),
          },
          selfClosing: { default: false },
          attributes: {
            validate: (0, s.chain)(
              (0, s.assertValueType)('array'),
              (0, s.assertEach)(
                (0, s.assertNodeType)('JSXAttribute', 'JSXSpreadAttribute'),
              ),
            ),
          },
          typeParameters: {
            validate: (0, s.assertNodeType)(
              'TypeParameterInstantiation',
              'TSTypeParameterInstantiation',
            ),
            optional: true,
          },
        },
      });
      i('JSXSpreadAttribute', {
        visitor: ['argument'],
        fields: { argument: { validate: (0, s.assertNodeType)('Expression') } },
      });
      i('JSXText', {
        aliases: ['Immutable'],
        builder: ['value'],
        fields: { value: { validate: (0, s.assertValueType)('string') } },
      });
      i('JSXFragment', {
        builder: ['openingFragment', 'closingFragment', 'children'],
        visitor: ['openingFragment', 'children', 'closingFragment'],
        aliases: ['Immutable', 'Expression'],
        fields: {
          openingFragment: {
            validate: (0, s.assertNodeType)('JSXOpeningFragment'),
          },
          closingFragment: {
            validate: (0, s.assertNodeType)('JSXClosingFragment'),
          },
          children: {
            validate: (0, s.chain)(
              (0, s.assertValueType)('array'),
              (0, s.assertEach)(
                (0, s.assertNodeType)(
                  'JSXText',
                  'JSXExpressionContainer',
                  'JSXSpreadChild',
                  'JSXElement',
                  'JSXFragment',
                ),
              ),
            ),
          },
        },
      });
      i('JSXOpeningFragment', { aliases: ['Immutable'] });
      i('JSXClosingFragment', { aliases: ['Immutable'] });
    },
    6742: function (e, t, r) {
      'use strict';
      var s = r(1903);
      var i = r(1141);
      const n = (0, s.defineAliasedType)('Miscellaneous');
      {
        n('Noop', { visitor: [] });
      }
      n('Placeholder', {
        visitor: [],
        builder: ['expectedNode', 'name'],
        fields: {
          name: { validate: (0, s.assertNodeType)('Identifier') },
          expectedNode: { validate: (0, s.assertOneOf)(...i.PLACEHOLDERS) },
        },
      });
      n('V8IntrinsicIdentifier', {
        builder: ['name'],
        fields: { name: { validate: (0, s.assertValueType)('string') } },
      });
    },
    1141: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.PLACEHOLDERS_FLIPPED_ALIAS =
        t.PLACEHOLDERS_ALIAS =
        t.PLACEHOLDERS =
          void 0;
      var s = r(1903);
      const i = (t.PLACEHOLDERS = [
        'Identifier',
        'StringLiteral',
        'Expression',
        'Statement',
        'Declaration',
        'BlockStatement',
        'ClassBody',
        'Pattern',
      ]);
      const n = (t.PLACEHOLDERS_ALIAS = {
        Declaration: ['Statement'],
        Pattern: ['PatternLike', 'LVal'],
      });
      for (const e of i) {
        const t = s.ALIAS_KEYS[e];
        if (t != null && t.length) n[e] = t;
      }
      const a = (t.PLACEHOLDERS_FLIPPED_ALIAS = {});
      Object.keys(n).forEach((e) => {
        n[e].forEach((t) => {
          if (!Object.hasOwnProperty.call(a, t)) {
            a[t] = [];
          }
          a[t].push(e);
        });
      });
    },
    4488: function (e, t, r) {
      'use strict';
      var s = r(1903);
      var i = r(5967);
      var n = r(3685);
      const a = (0, s.defineAliasedType)('TypeScript');
      const o = (0, s.assertValueType)('boolean');
      const tSFunctionTypeAnnotationCommon = () => ({
        returnType: {
          validate: (0, s.assertNodeType)('TSTypeAnnotation', 'Noop'),
          optional: true,
        },
        typeParameters: {
          validate: (0, s.assertNodeType)('TSTypeParameterDeclaration', 'Noop'),
          optional: true,
        },
      });
      a('TSParameterProperty', {
        aliases: ['LVal'],
        visitor: ['parameter'],
        fields: {
          accessibility: {
            validate: (0, s.assertOneOf)('public', 'private', 'protected'),
            optional: true,
          },
          readonly: {
            validate: (0, s.assertValueType)('boolean'),
            optional: true,
          },
          parameter: {
            validate: (0, s.assertNodeType)('Identifier', 'AssignmentPattern'),
          },
          override: {
            validate: (0, s.assertValueType)('boolean'),
            optional: true,
          },
          decorators: {
            validate: (0, s.chain)(
              (0, s.assertValueType)('array'),
              (0, s.assertEach)((0, s.assertNodeType)('Decorator')),
            ),
            optional: true,
          },
        },
      });
      a('TSDeclareFunction', {
        aliases: ['Statement', 'Declaration'],
        visitor: ['id', 'typeParameters', 'params', 'returnType'],
        fields: Object.assign(
          {},
          (0, i.functionDeclarationCommon)(),
          tSFunctionTypeAnnotationCommon(),
        ),
      });
      a('TSDeclareMethod', {
        visitor: [
          'decorators',
          'key',
          'typeParameters',
          'params',
          'returnType',
        ],
        fields: Object.assign(
          {},
          (0, i.classMethodOrDeclareMethodCommon)(),
          tSFunctionTypeAnnotationCommon(),
        ),
      });
      a('TSQualifiedName', {
        aliases: ['TSEntityName'],
        visitor: ['left', 'right'],
        fields: {
          left: (0, s.validateType)('TSEntityName'),
          right: (0, s.validateType)('Identifier'),
        },
      });
      const signatureDeclarationCommon = () => ({
        typeParameters: (0, s.validateOptionalType)(
          'TSTypeParameterDeclaration',
        ),
        ['parameters']: (0, s.validateArrayOfType)([
          'ArrayPattern',
          'Identifier',
          'ObjectPattern',
          'RestElement',
        ]),
        ['typeAnnotation']: (0, s.validateOptionalType)('TSTypeAnnotation'),
      });
      const l = {
        aliases: ['TSTypeElement'],
        visitor: ['typeParameters', 'parameters', 'typeAnnotation'],
        fields: signatureDeclarationCommon(),
      };
      a('TSCallSignatureDeclaration', l);
      a('TSConstructSignatureDeclaration', l);
      const namedTypeElementCommon = () => ({
        key: (0, s.validateType)('Expression'),
        computed: { default: false },
        optional: (0, s.validateOptional)(o),
      });
      a('TSPropertySignature', {
        aliases: ['TSTypeElement'],
        visitor: ['key', 'typeAnnotation', 'initializer'],
        fields: Object.assign({}, namedTypeElementCommon(), {
          readonly: (0, s.validateOptional)(o),
          typeAnnotation: (0, s.validateOptionalType)('TSTypeAnnotation'),
          initializer: (0, s.validateOptionalType)('Expression'),
          kind: { validate: (0, s.assertOneOf)('get', 'set') },
        }),
      });
      a('TSMethodSignature', {
        aliases: ['TSTypeElement'],
        visitor: ['key', 'typeParameters', 'parameters', 'typeAnnotation'],
        fields: Object.assign(
          {},
          signatureDeclarationCommon(),
          namedTypeElementCommon(),
          { kind: { validate: (0, s.assertOneOf)('method', 'get', 'set') } },
        ),
      });
      a('TSIndexSignature', {
        aliases: ['TSTypeElement'],
        visitor: ['parameters', 'typeAnnotation'],
        fields: {
          readonly: (0, s.validateOptional)(o),
          static: (0, s.validateOptional)(o),
          parameters: (0, s.validateArrayOfType)('Identifier'),
          typeAnnotation: (0, s.validateOptionalType)('TSTypeAnnotation'),
        },
      });
      const c = [
        'TSAnyKeyword',
        'TSBooleanKeyword',
        'TSBigIntKeyword',
        'TSIntrinsicKeyword',
        'TSNeverKeyword',
        'TSNullKeyword',
        'TSNumberKeyword',
        'TSObjectKeyword',
        'TSStringKeyword',
        'TSSymbolKeyword',
        'TSUndefinedKeyword',
        'TSUnknownKeyword',
        'TSVoidKeyword',
      ];
      for (const e of c) {
        a(e, { aliases: ['TSType', 'TSBaseType'], visitor: [], fields: {} });
      }
      a('TSThisType', {
        aliases: ['TSType', 'TSBaseType'],
        visitor: [],
        fields: {},
      });
      const p = {
        aliases: ['TSType'],
        visitor: ['typeParameters', 'parameters', 'typeAnnotation'],
      };
      a(
        'TSFunctionType',
        Object.assign({}, p, { fields: signatureDeclarationCommon() }),
      );
      a(
        'TSConstructorType',
        Object.assign({}, p, {
          fields: Object.assign({}, signatureDeclarationCommon(), {
            abstract: (0, s.validateOptional)(o),
          }),
        }),
      );
      a('TSTypeReference', {
        aliases: ['TSType'],
        visitor: ['typeName', 'typeParameters'],
        fields: {
          typeName: (0, s.validateType)('TSEntityName'),
          typeParameters: (0, s.validateOptionalType)(
            'TSTypeParameterInstantiation',
          ),
        },
      });
      a('TSTypePredicate', {
        aliases: ['TSType'],
        visitor: ['parameterName', 'typeAnnotation'],
        builder: ['parameterName', 'typeAnnotation', 'asserts'],
        fields: {
          parameterName: (0, s.validateType)(['Identifier', 'TSThisType']),
          typeAnnotation: (0, s.validateOptionalType)('TSTypeAnnotation'),
          asserts: (0, s.validateOptional)(o),
        },
      });
      a('TSTypeQuery', {
        aliases: ['TSType'],
        visitor: ['exprName', 'typeParameters'],
        fields: {
          exprName: (0, s.validateType)(['TSEntityName', 'TSImportType']),
          typeParameters: (0, s.validateOptionalType)(
            'TSTypeParameterInstantiation',
          ),
        },
      });
      a('TSTypeLiteral', {
        aliases: ['TSType'],
        visitor: ['members'],
        fields: { members: (0, s.validateArrayOfType)('TSTypeElement') },
      });
      a('TSArrayType', {
        aliases: ['TSType'],
        visitor: ['elementType'],
        fields: { elementType: (0, s.validateType)('TSType') },
      });
      a('TSTupleType', {
        aliases: ['TSType'],
        visitor: ['elementTypes'],
        fields: {
          elementTypes: (0, s.validateArrayOfType)([
            'TSType',
            'TSNamedTupleMember',
          ]),
        },
      });
      a('TSOptionalType', {
        aliases: ['TSType'],
        visitor: ['typeAnnotation'],
        fields: { typeAnnotation: (0, s.validateType)('TSType') },
      });
      a('TSRestType', {
        aliases: ['TSType'],
        visitor: ['typeAnnotation'],
        fields: { typeAnnotation: (0, s.validateType)('TSType') },
      });
      a('TSNamedTupleMember', {
        visitor: ['label', 'elementType'],
        builder: ['label', 'elementType', 'optional'],
        fields: {
          label: (0, s.validateType)('Identifier'),
          optional: { validate: o, default: false },
          elementType: (0, s.validateType)('TSType'),
        },
      });
      const u = {
        aliases: ['TSType'],
        visitor: ['types'],
        fields: { types: (0, s.validateArrayOfType)('TSType') },
      };
      a('TSUnionType', u);
      a('TSIntersectionType', u);
      a('TSConditionalType', {
        aliases: ['TSType'],
        visitor: ['checkType', 'extendsType', 'trueType', 'falseType'],
        fields: {
          checkType: (0, s.validateType)('TSType'),
          extendsType: (0, s.validateType)('TSType'),
          trueType: (0, s.validateType)('TSType'),
          falseType: (0, s.validateType)('TSType'),
        },
      });
      a('TSInferType', {
        aliases: ['TSType'],
        visitor: ['typeParameter'],
        fields: { typeParameter: (0, s.validateType)('TSTypeParameter') },
      });
      a('TSParenthesizedType', {
        aliases: ['TSType'],
        visitor: ['typeAnnotation'],
        fields: { typeAnnotation: (0, s.validateType)('TSType') },
      });
      a('TSTypeOperator', {
        aliases: ['TSType'],
        visitor: ['typeAnnotation'],
        fields: {
          operator: (0, s.validate)((0, s.assertValueType)('string')),
          typeAnnotation: (0, s.validateType)('TSType'),
        },
      });
      a('TSIndexedAccessType', {
        aliases: ['TSType'],
        visitor: ['objectType', 'indexType'],
        fields: {
          objectType: (0, s.validateType)('TSType'),
          indexType: (0, s.validateType)('TSType'),
        },
      });
      a('TSMappedType', {
        aliases: ['TSType'],
        visitor: ['typeParameter', 'typeAnnotation', 'nameType'],
        fields: {
          readonly: (0, s.validateOptional)(
            (0, s.assertOneOf)(true, false, '+', '-'),
          ),
          typeParameter: (0, s.validateType)('TSTypeParameter'),
          optional: (0, s.validateOptional)(
            (0, s.assertOneOf)(true, false, '+', '-'),
          ),
          typeAnnotation: (0, s.validateOptionalType)('TSType'),
          nameType: (0, s.validateOptionalType)('TSType'),
        },
      });
      a('TSLiteralType', {
        aliases: ['TSType', 'TSBaseType'],
        visitor: ['literal'],
        fields: {
          literal: {
            validate: (function () {
              const e = (0, s.assertNodeType)(
                'NumericLiteral',
                'BigIntLiteral',
              );
              const t = (0, s.assertOneOf)('-');
              const r = (0, s.assertNodeType)(
                'NumericLiteral',
                'StringLiteral',
                'BooleanLiteral',
                'BigIntLiteral',
                'TemplateLiteral',
              );
              function validator(s, i, a) {
                if ((0, n.default)('UnaryExpression', a)) {
                  t(a, 'operator', a.operator);
                  e(a, 'argument', a.argument);
                } else {
                  r(s, i, a);
                }
              }
              validator.oneOfNodeTypes = [
                'NumericLiteral',
                'StringLiteral',
                'BooleanLiteral',
                'BigIntLiteral',
                'TemplateLiteral',
                'UnaryExpression',
              ];
              return validator;
            })(),
          },
        },
      });
      a('TSExpressionWithTypeArguments', {
        aliases: ['TSType'],
        visitor: ['expression', 'typeParameters'],
        fields: {
          expression: (0, s.validateType)('TSEntityName'),
          typeParameters: (0, s.validateOptionalType)(
            'TSTypeParameterInstantiation',
          ),
        },
      });
      a('TSInterfaceDeclaration', {
        aliases: ['Statement', 'Declaration'],
        visitor: ['id', 'typeParameters', 'extends', 'body'],
        fields: {
          declare: (0, s.validateOptional)(o),
          id: (0, s.validateType)('Identifier'),
          typeParameters: (0, s.validateOptionalType)(
            'TSTypeParameterDeclaration',
          ),
          extends: (0, s.validateOptional)(
            (0, s.arrayOfType)('TSExpressionWithTypeArguments'),
          ),
          body: (0, s.validateType)('TSInterfaceBody'),
        },
      });
      a('TSInterfaceBody', {
        visitor: ['body'],
        fields: { body: (0, s.validateArrayOfType)('TSTypeElement') },
      });
      a('TSTypeAliasDeclaration', {
        aliases: ['Statement', 'Declaration'],
        visitor: ['id', 'typeParameters', 'typeAnnotation'],
        fields: {
          declare: (0, s.validateOptional)(o),
          id: (0, s.validateType)('Identifier'),
          typeParameters: (0, s.validateOptionalType)(
            'TSTypeParameterDeclaration',
          ),
          typeAnnotation: (0, s.validateType)('TSType'),
        },
      });
      a('TSInstantiationExpression', {
        aliases: ['Expression'],
        visitor: ['expression', 'typeParameters'],
        fields: {
          expression: (0, s.validateType)('Expression'),
          typeParameters: (0, s.validateOptionalType)(
            'TSTypeParameterInstantiation',
          ),
        },
      });
      const d = {
        aliases: ['Expression', 'LVal', 'PatternLike'],
        visitor: ['expression', 'typeAnnotation'],
        fields: {
          expression: (0, s.validateType)('Expression'),
          typeAnnotation: (0, s.validateType)('TSType'),
        },
      };
      a('TSAsExpression', d);
      a('TSSatisfiesExpression', d);
      a('TSTypeAssertion', {
        aliases: ['Expression', 'LVal', 'PatternLike'],
        visitor: ['typeAnnotation', 'expression'],
        fields: {
          typeAnnotation: (0, s.validateType)('TSType'),
          expression: (0, s.validateType)('Expression'),
        },
      });
      a('TSEnumDeclaration', {
        aliases: ['Statement', 'Declaration'],
        visitor: ['id', 'members'],
        fields: {
          declare: (0, s.validateOptional)(o),
          const: (0, s.validateOptional)(o),
          id: (0, s.validateType)('Identifier'),
          members: (0, s.validateArrayOfType)('TSEnumMember'),
          initializer: (0, s.validateOptionalType)('Expression'),
        },
      });
      a('TSEnumMember', {
        visitor: ['id', 'initializer'],
        fields: {
          id: (0, s.validateType)(['Identifier', 'StringLiteral']),
          initializer: (0, s.validateOptionalType)('Expression'),
        },
      });
      a('TSModuleDeclaration', {
        aliases: ['Statement', 'Declaration'],
        visitor: ['id', 'body'],
        fields: {
          declare: (0, s.validateOptional)(o),
          global: (0, s.validateOptional)(o),
          id: (0, s.validateType)(['Identifier', 'StringLiteral']),
          body: (0, s.validateType)(['TSModuleBlock', 'TSModuleDeclaration']),
        },
      });
      a('TSModuleBlock', {
        aliases: ['Scopable', 'Block', 'BlockParent', 'FunctionParent'],
        visitor: ['body'],
        fields: { body: (0, s.validateArrayOfType)('Statement') },
      });
      a('TSImportType', {
        aliases: ['TSType'],
        visitor: ['argument', 'qualifier', 'typeParameters'],
        fields: {
          argument: (0, s.validateType)('StringLiteral'),
          qualifier: (0, s.validateOptionalType)('TSEntityName'),
          typeParameters: (0, s.validateOptionalType)(
            'TSTypeParameterInstantiation',
          ),
        },
      });
      a('TSImportEqualsDeclaration', {
        aliases: ['Statement'],
        visitor: ['id', 'moduleReference'],
        fields: {
          isExport: (0, s.validate)(o),
          id: (0, s.validateType)('Identifier'),
          moduleReference: (0, s.validateType)([
            'TSEntityName',
            'TSExternalModuleReference',
          ]),
          importKind: {
            validate: (0, s.assertOneOf)('type', 'value'),
            optional: true,
          },
        },
      });
      a('TSExternalModuleReference', {
        visitor: ['expression'],
        fields: { expression: (0, s.validateType)('StringLiteral') },
      });
      a('TSNonNullExpression', {
        aliases: ['Expression', 'LVal', 'PatternLike'],
        visitor: ['expression'],
        fields: { expression: (0, s.validateType)('Expression') },
      });
      a('TSExportAssignment', {
        aliases: ['Statement'],
        visitor: ['expression'],
        fields: { expression: (0, s.validateType)('Expression') },
      });
      a('TSNamespaceExportDeclaration', {
        aliases: ['Statement'],
        visitor: ['id'],
        fields: { id: (0, s.validateType)('Identifier') },
      });
      a('TSTypeAnnotation', {
        visitor: ['typeAnnotation'],
        fields: {
          typeAnnotation: { validate: (0, s.assertNodeType)('TSType') },
        },
      });
      a('TSTypeParameterInstantiation', {
        visitor: ['params'],
        fields: {
          params: {
            validate: (0, s.chain)(
              (0, s.assertValueType)('array'),
              (0, s.assertEach)((0, s.assertNodeType)('TSType')),
            ),
          },
        },
      });
      a('TSTypeParameterDeclaration', {
        visitor: ['params'],
        fields: {
          params: {
            validate: (0, s.chain)(
              (0, s.assertValueType)('array'),
              (0, s.assertEach)((0, s.assertNodeType)('TSTypeParameter')),
            ),
          },
        },
      });
      a('TSTypeParameter', {
        builder: ['constraint', 'default', 'name'],
        visitor: ['constraint', 'default'],
        fields: {
          name: { validate: (0, s.assertValueType)('string') },
          in: { validate: (0, s.assertValueType)('boolean'), optional: true },
          out: { validate: (0, s.assertValueType)('boolean'), optional: true },
          const: {
            validate: (0, s.assertValueType)('boolean'),
            optional: true,
          },
          constraint: {
            validate: (0, s.assertNodeType)('TSType'),
            optional: true,
          },
          default: {
            validate: (0, s.assertNodeType)('TSType'),
            optional: true,
          },
        },
      });
    },
    1903: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.VISITOR_KEYS =
        t.NODE_PARENT_VALIDATIONS =
        t.NODE_FIELDS =
        t.FLIPPED_ALIAS_KEYS =
        t.DEPRECATED_KEYS =
        t.BUILDER_KEYS =
        t.ALIAS_KEYS =
          void 0;
      t.arrayOf = arrayOf;
      t.arrayOfType = arrayOfType;
      t.assertEach = assertEach;
      t.assertNodeOrValueType = assertNodeOrValueType;
      t.assertNodeType = assertNodeType;
      t.assertOneOf = assertOneOf;
      t.assertOptionalChainStart = assertOptionalChainStart;
      t.assertShape = assertShape;
      t.assertValueType = assertValueType;
      t.chain = chain;
      t['default'] = defineType;
      t.defineAliasedType = defineAliasedType;
      t.typeIs = typeIs;
      t.validate = validate;
      t.validateArrayOfType = validateArrayOfType;
      t.validateOptional = validateOptional;
      t.validateOptionalType = validateOptionalType;
      t.validateType = validateType;
      var s = r(3685);
      var i = r(7159);
      const n = (t.VISITOR_KEYS = {});
      const a = (t.ALIAS_KEYS = {});
      const o = (t.FLIPPED_ALIAS_KEYS = {});
      const l = (t.NODE_FIELDS = {});
      const c = (t.BUILDER_KEYS = {});
      const p = (t.DEPRECATED_KEYS = {});
      const u = (t.NODE_PARENT_VALIDATIONS = {});
      function getType(e) {
        if (Array.isArray(e)) {
          return 'array';
        } else if (e === null) {
          return 'null';
        } else {
          return typeof e;
        }
      }
      function validate(e) {
        return { validate: e };
      }
      function typeIs(e) {
        return typeof e === 'string' ? assertNodeType(e) : assertNodeType(...e);
      }
      function validateType(e) {
        return validate(typeIs(e));
      }
      function validateOptional(e) {
        return { validate: e, optional: true };
      }
      function validateOptionalType(e) {
        return { validate: typeIs(e), optional: true };
      }
      function arrayOf(e) {
        return chain(assertValueType('array'), assertEach(e));
      }
      function arrayOfType(e) {
        return arrayOf(typeIs(e));
      }
      function validateArrayOfType(e) {
        return validate(arrayOfType(e));
      }
      function assertEach(e) {
        function validator(t, r, s) {
          if (!Array.isArray(s)) return;
          for (let n = 0; n < s.length; n++) {
            const a = `${r}[${n}]`;
            const o = s[n];
            e(t, a, o);
            if (process.env.BABEL_TYPES_8_BREAKING)
              (0, i.validateChild)(t, a, o);
          }
        }
        validator.each = e;
        return validator;
      }
      function assertOneOf(...e) {
        function validate(t, r, s) {
          if (e.indexOf(s) < 0) {
            throw new TypeError(
              `Property ${r} expected value to be one of ${JSON.stringify(
                e,
              )} but got ${JSON.stringify(s)}`,
            );
          }
        }
        validate.oneOf = e;
        return validate;
      }
      function assertNodeType(...e) {
        function validate(t, r, n) {
          for (const a of e) {
            if ((0, s.default)(a, n)) {
              (0, i.validateChild)(t, r, n);
              return;
            }
          }
          throw new TypeError(
            `Property ${r} of ${
              t.type
            } expected node to be of a type ${JSON.stringify(
              e,
            )} but instead got ${JSON.stringify(n == null ? void 0 : n.type)}`,
          );
        }
        validate.oneOfNodeTypes = e;
        return validate;
      }
      function assertNodeOrValueType(...e) {
        function validate(t, r, n) {
          for (const a of e) {
            if (getType(n) === a || (0, s.default)(a, n)) {
              (0, i.validateChild)(t, r, n);
              return;
            }
          }
          throw new TypeError(
            `Property ${r} of ${
              t.type
            } expected node to be of a type ${JSON.stringify(
              e,
            )} but instead got ${JSON.stringify(n == null ? void 0 : n.type)}`,
          );
        }
        validate.oneOfNodeOrValueTypes = e;
        return validate;
      }
      function assertValueType(e) {
        function validate(t, r, s) {
          const i = getType(s) === e;
          if (!i) {
            throw new TypeError(
              `Property ${r} expected type of ${e} but got ${getType(s)}`,
            );
          }
        }
        validate.type = e;
        return validate;
      }
      function assertShape(e) {
        function validate(t, r, s) {
          const n = [];
          for (const r of Object.keys(e)) {
            try {
              (0, i.validateField)(t, r, s[r], e[r]);
            } catch (e) {
              if (e instanceof TypeError) {
                n.push(e.message);
                continue;
              }
              throw e;
            }
          }
          if (n.length) {
            throw new TypeError(
              `Property ${r} of ${
                t.type
              } expected to have the following:\n${n.join('\n')}`,
            );
          }
        }
        validate.shapeOf = e;
        return validate;
      }
      function assertOptionalChainStart() {
        function validate(e) {
          var t;
          let r = e;
          while (e) {
            const { type: e } = r;
            if (e === 'OptionalCallExpression') {
              if (r.optional) return;
              r = r.callee;
              continue;
            }
            if (e === 'OptionalMemberExpression') {
              if (r.optional) return;
              r = r.object;
              continue;
            }
            break;
          }
          throw new TypeError(
            `Non-optional ${
              e.type
            } must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${
              (t = r) == null ? void 0 : t.type
            }`,
          );
        }
        return validate;
      }
      function chain(...e) {
        function validate(...t) {
          for (const r of e) {
            r(...t);
          }
        }
        validate.chainOf = e;
        if (
          e.length >= 2 &&
          'type' in e[0] &&
          e[0].type === 'array' &&
          !('each' in e[1])
        ) {
          throw new Error(
            `An assertValueType("array") validator can only be followed by an assertEach(...) validator.`,
          );
        }
        return validate;
      }
      const d = [
        'aliases',
        'builder',
        'deprecatedAlias',
        'fields',
        'inherits',
        'visitor',
        'validate',
      ];
      const f = ['default', 'optional', 'deprecated', 'validate'];
      const h = {};
      function defineAliasedType(...e) {
        return (t, r = {}) => {
          let s = r.aliases;
          if (!s) {
            var i, n;
            if (r.inherits)
              s = (i = h[r.inherits].aliases) == null ? void 0 : i.slice();
            (n = s) != null ? n : (s = []);
            r.aliases = s;
          }
          const a = e.filter((e) => !s.includes(e));
          s.unshift(...a);
          defineType(t, r);
        };
      }
      function defineType(e, t = {}) {
        const r = (t.inherits && h[t.inherits]) || {};
        let s = t.fields;
        if (!s) {
          s = {};
          if (r.fields) {
            const e = Object.getOwnPropertyNames(r.fields);
            for (const t of e) {
              const e = r.fields[t];
              const i = e.default;
              if (
                Array.isArray(i) ? i.length > 0 : i && typeof i === 'object'
              ) {
                throw new Error(
                  'field defaults can only be primitives or empty arrays currently',
                );
              }
              s[t] = {
                default: Array.isArray(i) ? [] : i,
                optional: e.optional,
                deprecated: e.deprecated,
                validate: e.validate,
              };
            }
          }
        }
        const i = t.visitor || r.visitor || [];
        const y = t.aliases || r.aliases || [];
        const m = t.builder || r.builder || t.visitor || [];
        for (const r of Object.keys(t)) {
          if (d.indexOf(r) === -1) {
            throw new Error(`Unknown type option "${r}" on ${e}`);
          }
        }
        if (t.deprecatedAlias) {
          p[t.deprecatedAlias] = e;
        }
        for (const e of i.concat(m)) {
          s[e] = s[e] || {};
        }
        for (const t of Object.keys(s)) {
          const r = s[t];
          if (r.default !== undefined && m.indexOf(t) === -1) {
            r.optional = true;
          }
          if (r.default === undefined) {
            r.default = null;
          } else if (!r.validate && r.default != null) {
            r.validate = assertValueType(getType(r.default));
          }
          for (const s of Object.keys(r)) {
            if (f.indexOf(s) === -1) {
              throw new Error(`Unknown field key "${s}" on ${e}.${t}`);
            }
          }
        }
        n[e] = t.visitor = i;
        c[e] = t.builder = m;
        l[e] = t.fields = s;
        a[e] = t.aliases = y;
        y.forEach((t) => {
          o[t] = o[t] || [];
          o[t].push(e);
        });
        if (t.validate) {
          u[e] = t.validate;
        }
        h[e] = t;
      }
    },
    4739: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      var s = {
        react: true,
        assertNode: true,
        createTypeAnnotationBasedOnTypeof: true,
        createUnionTypeAnnotation: true,
        createFlowUnionType: true,
        createTSUnionType: true,
        cloneNode: true,
        clone: true,
        cloneDeep: true,
        cloneDeepWithoutLoc: true,
        cloneWithoutLoc: true,
        addComment: true,
        addComments: true,
        inheritInnerComments: true,
        inheritLeadingComments: true,
        inheritsComments: true,
        inheritTrailingComments: true,
        removeComments: true,
        ensureBlock: true,
        toBindingIdentifierName: true,
        toBlock: true,
        toComputedKey: true,
        toExpression: true,
        toIdentifier: true,
        toKeyAlias: true,
        toStatement: true,
        valueToNode: true,
        appendToMemberExpression: true,
        inherits: true,
        prependToMemberExpression: true,
        removeProperties: true,
        removePropertiesDeep: true,
        removeTypeDuplicates: true,
        getBindingIdentifiers: true,
        getOuterBindingIdentifiers: true,
        traverse: true,
        traverseFast: true,
        shallowEqual: true,
        is: true,
        isBinding: true,
        isBlockScoped: true,
        isImmutable: true,
        isLet: true,
        isNode: true,
        isNodesEquivalent: true,
        isPlaceholderType: true,
        isReferenced: true,
        isScope: true,
        isSpecifierDefault: true,
        isType: true,
        isValidES3Identifier: true,
        isValidIdentifier: true,
        isVar: true,
        matchesPattern: true,
        validate: true,
        buildMatchMemberExpression: true,
        __internal__deprecationWarning: true,
      };
      Object.defineProperty(t, '__internal__deprecationWarning', {
        enumerable: true,
        get: function () {
          return ye.default;
        },
      });
      Object.defineProperty(t, 'addComment', {
        enumerable: true,
        get: function () {
          return b.default;
        },
      });
      Object.defineProperty(t, 'addComments', {
        enumerable: true,
        get: function () {
          return E.default;
        },
      });
      Object.defineProperty(t, 'appendToMemberExpression', {
        enumerable: true,
        get: function () {
          return R.default;
        },
      });
      Object.defineProperty(t, 'assertNode', {
        enumerable: true,
        get: function () {
          return o.default;
        },
      });
      Object.defineProperty(t, 'buildMatchMemberExpression', {
        enumerable: true,
        get: function () {
          return fe.default;
        },
      });
      Object.defineProperty(t, 'clone', {
        enumerable: true,
        get: function () {
          return m.default;
        },
      });
      Object.defineProperty(t, 'cloneDeep', {
        enumerable: true,
        get: function () {
          return T.default;
        },
      });
      Object.defineProperty(t, 'cloneDeepWithoutLoc', {
        enumerable: true,
        get: function () {
          return S.default;
        },
      });
      Object.defineProperty(t, 'cloneNode', {
        enumerable: true,
        get: function () {
          return y.default;
        },
      });
      Object.defineProperty(t, 'cloneWithoutLoc', {
        enumerable: true,
        get: function () {
          return x.default;
        },
      });
      Object.defineProperty(t, 'createFlowUnionType', {
        enumerable: true,
        get: function () {
          return p.default;
        },
      });
      Object.defineProperty(t, 'createTSUnionType', {
        enumerable: true,
        get: function () {
          return u.default;
        },
      });
      Object.defineProperty(t, 'createTypeAnnotationBasedOnTypeof', {
        enumerable: true,
        get: function () {
          return c.default;
        },
      });
      Object.defineProperty(t, 'createUnionTypeAnnotation', {
        enumerable: true,
        get: function () {
          return p.default;
        },
      });
      Object.defineProperty(t, 'ensureBlock', {
        enumerable: true,
        get: function () {
          return O.default;
        },
      });
      Object.defineProperty(t, 'getBindingIdentifiers', {
        enumerable: true,
        get: function () {
          return Y.default;
        },
      });
      Object.defineProperty(t, 'getOuterBindingIdentifiers', {
        enumerable: true,
        get: function () {
          return W.default;
        },
      });
      Object.defineProperty(t, 'inheritInnerComments', {
        enumerable: true,
        get: function () {
          return P.default;
        },
      });
      Object.defineProperty(t, 'inheritLeadingComments', {
        enumerable: true,
        get: function () {
          return g.default;
        },
      });
      Object.defineProperty(t, 'inheritTrailingComments', {
        enumerable: true,
        get: function () {
          return v.default;
        },
      });
      Object.defineProperty(t, 'inherits', {
        enumerable: true,
        get: function () {
          return K.default;
        },
      });
      Object.defineProperty(t, 'inheritsComments', {
        enumerable: true,
        get: function () {
          return A.default;
        },
      });
      Object.defineProperty(t, 'is', {
        enumerable: true,
        get: function () {
          return H.default;
        },
      });
      Object.defineProperty(t, 'isBinding', {
        enumerable: true,
        get: function () {
          return G.default;
        },
      });
      Object.defineProperty(t, 'isBlockScoped', {
        enumerable: true,
        get: function () {
          return Q.default;
        },
      });
      Object.defineProperty(t, 'isImmutable', {
        enumerable: true,
        get: function () {
          return Z.default;
        },
      });
      Object.defineProperty(t, 'isLet', {
        enumerable: true,
        get: function () {
          return ee.default;
        },
      });
      Object.defineProperty(t, 'isNode', {
        enumerable: true,
        get: function () {
          return te.default;
        },
      });
      Object.defineProperty(t, 'isNodesEquivalent', {
        enumerable: true,
        get: function () {
          return re.default;
        },
      });
      Object.defineProperty(t, 'isPlaceholderType', {
        enumerable: true,
        get: function () {
          return se.default;
        },
      });
      Object.defineProperty(t, 'isReferenced', {
        enumerable: true,
        get: function () {
          return ie.default;
        },
      });
      Object.defineProperty(t, 'isScope', {
        enumerable: true,
        get: function () {
          return ne.default;
        },
      });
      Object.defineProperty(t, 'isSpecifierDefault', {
        enumerable: true,
        get: function () {
          return ae.default;
        },
      });
      Object.defineProperty(t, 'isType', {
        enumerable: true,
        get: function () {
          return oe.default;
        },
      });
      Object.defineProperty(t, 'isValidES3Identifier', {
        enumerable: true,
        get: function () {
          return le.default;
        },
      });
      Object.defineProperty(t, 'isValidIdentifier', {
        enumerable: true,
        get: function () {
          return ce.default;
        },
      });
      Object.defineProperty(t, 'isVar', {
        enumerable: true,
        get: function () {
          return pe.default;
        },
      });
      Object.defineProperty(t, 'matchesPattern', {
        enumerable: true,
        get: function () {
          return ue.default;
        },
      });
      Object.defineProperty(t, 'prependToMemberExpression', {
        enumerable: true,
        get: function () {
          return U.default;
        },
      });
      t.react = void 0;
      Object.defineProperty(t, 'removeComments', {
        enumerable: true,
        get: function () {
          return I.default;
        },
      });
      Object.defineProperty(t, 'removeProperties', {
        enumerable: true,
        get: function () {
          return V.default;
        },
      });
      Object.defineProperty(t, 'removePropertiesDeep', {
        enumerable: true,
        get: function () {
          return X.default;
        },
      });
      Object.defineProperty(t, 'removeTypeDuplicates', {
        enumerable: true,
        get: function () {
          return J.default;
        },
      });
      Object.defineProperty(t, 'shallowEqual', {
        enumerable: true,
        get: function () {
          return z.default;
        },
      });
      Object.defineProperty(t, 'toBindingIdentifierName', {
        enumerable: true,
        get: function () {
          return C.default;
        },
      });
      Object.defineProperty(t, 'toBlock', {
        enumerable: true,
        get: function () {
          return D.default;
        },
      });
      Object.defineProperty(t, 'toComputedKey', {
        enumerable: true,
        get: function () {
          return k.default;
        },
      });
      Object.defineProperty(t, 'toExpression', {
        enumerable: true,
        get: function () {
          return L.default;
        },
      });
      Object.defineProperty(t, 'toIdentifier', {
        enumerable: true,
        get: function () {
          return M.default;
        },
      });
      Object.defineProperty(t, 'toKeyAlias', {
        enumerable: true,
        get: function () {
          return j.default;
        },
      });
      Object.defineProperty(t, 'toStatement', {
        enumerable: true,
        get: function () {
          return B.default;
        },
      });
      Object.defineProperty(t, 'traverse', {
        enumerable: true,
        get: function () {
          return q.default;
        },
      });
      Object.defineProperty(t, 'traverseFast', {
        enumerable: true,
        get: function () {
          return $.default;
        },
      });
      Object.defineProperty(t, 'validate', {
        enumerable: true,
        get: function () {
          return de.default;
        },
      });
      Object.defineProperty(t, 'valueToNode', {
        enumerable: true,
        get: function () {
          return F.default;
        },
      });
      var i = r(835);
      var n = r(9482);
      var a = r(3718);
      var o = r(4632);
      var l = r(3701);
      Object.keys(l).forEach(function (e) {
        if (e === 'default' || e === '__esModule') return;
        if (Object.prototype.hasOwnProperty.call(s, e)) return;
        if (e in t && t[e] === l[e]) return;
        Object.defineProperty(t, e, {
          enumerable: true,
          get: function () {
            return l[e];
          },
        });
      });
      var c = r(8276);
      var p = r(2814);
      var u = r(1094);
      var d = r(397);
      Object.keys(d).forEach(function (e) {
        if (e === 'default' || e === '__esModule') return;
        if (Object.prototype.hasOwnProperty.call(s, e)) return;
        if (e in t && t[e] === d[e]) return;
        Object.defineProperty(t, e, {
          enumerable: true,
          get: function () {
            return d[e];
          },
        });
      });
      var f = r(6503);
      Object.keys(f).forEach(function (e) {
        if (e === 'default' || e === '__esModule') return;
        if (Object.prototype.hasOwnProperty.call(s, e)) return;
        if (e in t && t[e] === f[e]) return;
        Object.defineProperty(t, e, {
          enumerable: true,
          get: function () {
            return f[e];
          },
        });
      });
      var h = r(5673);
      Object.keys(h).forEach(function (e) {
        if (e === 'default' || e === '__esModule') return;
        if (Object.prototype.hasOwnProperty.call(s, e)) return;
        if (e in t && t[e] === h[e]) return;
        Object.defineProperty(t, e, {
          enumerable: true,
          get: function () {
            return h[e];
          },
        });
      });
      var y = r(7421);
      var m = r(9906);
      var T = r(6719);
      var S = r(6489);
      var x = r(1260);
      var b = r(2227);
      var E = r(9534);
      var P = r(8898);
      var g = r(5689);
      var A = r(8237);
      var v = r(3146);
      var I = r(6267);
      var w = r(8178);
      Object.keys(w).forEach(function (e) {
        if (e === 'default' || e === '__esModule') return;
        if (Object.prototype.hasOwnProperty.call(s, e)) return;
        if (e in t && t[e] === w[e]) return;
        Object.defineProperty(t, e, {
          enumerable: true,
          get: function () {
            return w[e];
          },
        });
      });
      var N = r(1227);
      Object.keys(N).forEach(function (e) {
        if (e === 'default' || e === '__esModule') return;
        if (Object.prototype.hasOwnProperty.call(s, e)) return;
        if (e in t && t[e] === N[e]) return;
        Object.defineProperty(t, e, {
          enumerable: true,
          get: function () {
            return N[e];
          },
        });
      });
      var O = r(7158);
      var C = r(5999);
      var D = r(5013);
      var k = r(3317);
      var L = r(9132);
      var M = r(1868);
      var j = r(1873);
      var B = r(4570);
      var F = r(1382);
      var _ = r(7405);
      Object.keys(_).forEach(function (e) {
        if (e === 'default' || e === '__esModule') return;
        if (Object.prototype.hasOwnProperty.call(s, e)) return;
        if (e in t && t[e] === _[e]) return;
        Object.defineProperty(t, e, {
          enumerable: true,
          get: function () {
            return _[e];
          },
        });
      });
      var R = r(8490);
      var K = r(2710);
      var U = r(6409);
      var V = r(316);
      var X = r(2735);
      var J = r(3864);
      var Y = r(6675);
      var W = r(9852);
      var q = r(954);
      Object.keys(q).forEach(function (e) {
        if (e === 'default' || e === '__esModule') return;
        if (Object.prototype.hasOwnProperty.call(s, e)) return;
        if (e in t && t[e] === q[e]) return;
        Object.defineProperty(t, e, {
          enumerable: true,
          get: function () {
            return q[e];
          },
        });
      });
      var $ = r(9370);
      var z = r(79);
      var H = r(3685);
      var G = r(8731);
      var Q = r(2821);
      var Z = r(5456);
      var ee = r(9552);
      var te = r(6516);
      var re = r(1840);
      var se = r(6937);
      var ie = r(7391);
      var ne = r(7910);
      var ae = r(9003);
      var oe = r(1009);
      var le = r(5563);
      var ce = r(9994);
      var pe = r(7407);
      var ue = r(3794);
      var de = r(7159);
      var fe = r(5659);
      var he = r(6428);
      Object.keys(he).forEach(function (e) {
        if (e === 'default' || e === '__esModule') return;
        if (Object.prototype.hasOwnProperty.call(s, e)) return;
        if (e in t && t[e] === he[e]) return;
        Object.defineProperty(t, e, {
          enumerable: true,
          get: function () {
            return he[e];
          },
        });
      });
      var ye = r(8418);
      const me = (t.react = {
        isReactComponent: i.default,
        isCompatTag: n.default,
        buildChildren: a.default,
      });
      {
        t.toSequenceExpression = r(6906)['default'];
      }
    },
    8490: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = appendToMemberExpression;
      var s = r(397);
      function appendToMemberExpression(e, t, r = false) {
        e.object = (0, s.memberExpression)(e.object, e.property, e.computed);
        e.property = t;
        e.computed = !!r;
        return e;
      }
    },
    3864: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = removeTypeDuplicates;
      var s = r(6428);
      function getQualifiedName(e) {
        return (0, s.isIdentifier)(e)
          ? e.name
          : `${e.id.name}.${getQualifiedName(e.qualification)}`;
      }
      function removeTypeDuplicates(e) {
        const t = Array.from(e);
        const r = new Map();
        const i = new Map();
        const n = new Set();
        const a = [];
        for (let e = 0; e < t.length; e++) {
          const o = t[e];
          if (!o) continue;
          if (a.indexOf(o) >= 0) {
            continue;
          }
          if ((0, s.isAnyTypeAnnotation)(o)) {
            return [o];
          }
          if ((0, s.isFlowBaseAnnotation)(o)) {
            i.set(o.type, o);
            continue;
          }
          if ((0, s.isUnionTypeAnnotation)(o)) {
            if (!n.has(o.types)) {
              t.push(...o.types);
              n.add(o.types);
            }
            continue;
          }
          if ((0, s.isGenericTypeAnnotation)(o)) {
            const e = getQualifiedName(o.id);
            if (r.has(e)) {
              let t = r.get(e);
              if (t.typeParameters) {
                if (o.typeParameters) {
                  t.typeParameters.params.push(...o.typeParameters.params);
                  t.typeParameters.params = removeTypeDuplicates(
                    t.typeParameters.params,
                  );
                }
              } else {
                t = o.typeParameters;
              }
            } else {
              r.set(e, o);
            }
            continue;
          }
          a.push(o);
        }
        for (const [, e] of i) {
          a.push(e);
        }
        for (const [, e] of r) {
          a.push(e);
        }
        return a;
      }
    },
    2710: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = inherits;
      var s = r(1227);
      var i = r(8237);
      function inherits(e, t) {
        if (!e || !t) return e;
        for (const r of s.INHERIT_KEYS.optional) {
          if (e[r] == null) {
            e[r] = t[r];
          }
        }
        for (const r of Object.keys(t)) {
          if (r[0] === '_' && r !== '__clone') {
            e[r] = t[r];
          }
        }
        for (const r of s.INHERIT_KEYS.force) {
          e[r] = t[r];
        }
        (0, i.default)(e, t);
        return e;
      }
    },
    6409: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = prependToMemberExpression;
      var s = r(397);
      var i = r(4739);
      function prependToMemberExpression(e, t) {
        if ((0, i.isSuper)(e.object)) {
          throw new Error(
            'Cannot prepend node to super property access (`super.foo`).',
          );
        }
        e.object = (0, s.memberExpression)(t, e.object);
        return e;
      }
    },
    316: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = removeProperties;
      var s = r(1227);
      const i = ['tokens', 'start', 'end', 'loc', 'raw', 'rawValue'];
      const n = [...s.COMMENT_KEYS, 'comments', ...i];
      function removeProperties(e, t = {}) {
        const r = t.preserveComments ? i : n;
        for (const t of r) {
          if (e[t] != null) e[t] = undefined;
        }
        for (const t of Object.keys(e)) {
          if (t[0] === '_' && e[t] != null) e[t] = undefined;
        }
        const s = Object.getOwnPropertySymbols(e);
        for (const t of s) {
          e[t] = null;
        }
      }
    },
    2735: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = removePropertiesDeep;
      var s = r(9370);
      var i = r(316);
      function removePropertiesDeep(e, t) {
        (0, s.default)(e, i.default, t);
        return e;
      }
    },
    2832: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = removeTypeDuplicates;
      var s = r(6428);
      function getQualifiedName(e) {
        return (0, s.isIdentifier)(e)
          ? e.name
          : `${e.right.name}.${getQualifiedName(e.left)}`;
      }
      function removeTypeDuplicates(e) {
        const t = Array.from(e);
        const r = new Map();
        const i = new Map();
        const n = new Set();
        const a = [];
        for (let e = 0; e < t.length; e++) {
          const o = t[e];
          if (!o) continue;
          if (a.indexOf(o) >= 0) {
            continue;
          }
          if ((0, s.isTSAnyKeyword)(o)) {
            return [o];
          }
          if ((0, s.isTSBaseType)(o)) {
            i.set(o.type, o);
            continue;
          }
          if ((0, s.isTSUnionType)(o)) {
            if (!n.has(o.types)) {
              t.push(...o.types);
              n.add(o.types);
            }
            continue;
          }
          if ((0, s.isTSTypeReference)(o) && o.typeParameters) {
            const e = getQualifiedName(o.typeName);
            if (r.has(e)) {
              let t = r.get(e);
              if (t.typeParameters) {
                if (o.typeParameters) {
                  t.typeParameters.params.push(...o.typeParameters.params);
                  t.typeParameters.params = removeTypeDuplicates(
                    t.typeParameters.params,
                  );
                }
              } else {
                t = o.typeParameters;
              }
            } else {
              r.set(e, o);
            }
            continue;
          }
          a.push(o);
        }
        for (const [, e] of i) {
          a.push(e);
        }
        for (const [, e] of r) {
          a.push(e);
        }
        return a;
      }
    },
    6675: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = getBindingIdentifiers;
      var s = r(6428);
      function getBindingIdentifiers(e, t, r) {
        const i = [].concat(e);
        const n = Object.create(null);
        while (i.length) {
          const e = i.shift();
          if (!e) continue;
          const a = getBindingIdentifiers.keys[e.type];
          if ((0, s.isIdentifier)(e)) {
            if (t) {
              const t = (n[e.name] = n[e.name] || []);
              t.push(e);
            } else {
              n[e.name] = e;
            }
            continue;
          }
          if (
            (0, s.isExportDeclaration)(e) &&
            !(0, s.isExportAllDeclaration)(e)
          ) {
            if ((0, s.isDeclaration)(e.declaration)) {
              i.push(e.declaration);
            }
            continue;
          }
          if (r) {
            if ((0, s.isFunctionDeclaration)(e)) {
              i.push(e.id);
              continue;
            }
            if ((0, s.isFunctionExpression)(e)) {
              continue;
            }
          }
          if (a) {
            for (let t = 0; t < a.length; t++) {
              const r = a[t];
              const s = e[r];
              if (s) {
                Array.isArray(s) ? i.push(...s) : i.push(s);
              }
            }
          }
        }
        return n;
      }
      getBindingIdentifiers.keys = {
        DeclareClass: ['id'],
        DeclareFunction: ['id'],
        DeclareModule: ['id'],
        DeclareVariable: ['id'],
        DeclareInterface: ['id'],
        DeclareTypeAlias: ['id'],
        DeclareOpaqueType: ['id'],
        InterfaceDeclaration: ['id'],
        TypeAlias: ['id'],
        OpaqueType: ['id'],
        CatchClause: ['param'],
        LabeledStatement: ['label'],
        UnaryExpression: ['argument'],
        AssignmentExpression: ['left'],
        ImportSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportDefaultSpecifier: ['local'],
        ImportDeclaration: ['specifiers'],
        ExportSpecifier: ['exported'],
        ExportNamespaceSpecifier: ['exported'],
        ExportDefaultSpecifier: ['exported'],
        FunctionDeclaration: ['id', 'params'],
        FunctionExpression: ['id', 'params'],
        ArrowFunctionExpression: ['params'],
        ObjectMethod: ['params'],
        ClassMethod: ['params'],
        ClassPrivateMethod: ['params'],
        ForInStatement: ['left'],
        ForOfStatement: ['left'],
        ClassDeclaration: ['id'],
        ClassExpression: ['id'],
        RestElement: ['argument'],
        UpdateExpression: ['argument'],
        ObjectProperty: ['value'],
        AssignmentPattern: ['left'],
        ArrayPattern: ['elements'],
        ObjectPattern: ['properties'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id'],
      };
    },
    9852: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = void 0;
      var s = r(6675);
      var i = (t['default'] = getOuterBindingIdentifiers);
      function getOuterBindingIdentifiers(e, t) {
        return (0, s.default)(e, t, true);
      }
    },
    954: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = traverse;
      var s = r(7405);
      function traverse(e, t, r) {
        if (typeof t === 'function') {
          t = { enter: t };
        }
        const { enter: s, exit: i } = t;
        traverseSimpleImpl(e, s, i, r, []);
      }
      function traverseSimpleImpl(e, t, r, i, n) {
        const a = s.VISITOR_KEYS[e.type];
        if (!a) return;
        if (t) t(e, n, i);
        for (const s of a) {
          const a = e[s];
          if (Array.isArray(a)) {
            for (let o = 0; o < a.length; o++) {
              const l = a[o];
              if (!l) continue;
              n.push({ node: e, key: s, index: o });
              traverseSimpleImpl(l, t, r, i, n);
              n.pop();
            }
          } else if (a) {
            n.push({ node: e, key: s });
            traverseSimpleImpl(a, t, r, i, n);
            n.pop();
          }
        }
        if (r) r(e, n, i);
      }
    },
    9370: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = traverseFast;
      var s = r(7405);
      function traverseFast(e, t, r) {
        if (!e) return;
        const i = s.VISITOR_KEYS[e.type];
        if (!i) return;
        r = r || {};
        t(e, r);
        for (const s of i) {
          const i = e[s];
          if (Array.isArray(i)) {
            for (const e of i) {
              traverseFast(e, t, r);
            }
          } else {
            traverseFast(i, t, r);
          }
        }
      }
    },
    8418: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = deprecationWarning;
      const r = new Set();
      function deprecationWarning(e, t, s = '') {
        if (r.has(e)) return;
        r.add(e);
        const { internal: i, trace: n } = captureShortStackTrace(1, 2);
        if (i) {
          return;
        }
        console.warn(
          `${s}\`${e}\` has been deprecated, please migrate to \`${t}\`\n${n}`,
        );
      }
      function captureShortStackTrace(e, t) {
        const { stackTraceLimit: r, prepareStackTrace: s } = Error;
        let i;
        Error.stackTraceLimit = 1 + e + t;
        Error.prepareStackTrace = function (e, t) {
          i = t;
        };
        new Error().stack;
        Error.stackTraceLimit = r;
        Error.prepareStackTrace = s;
        if (!i) return { internal: false, trace: '' };
        const n = i.slice(1 + e, 1 + e + t);
        return {
          internal: /[\\/]@babel[\\/]/.test(n[1].getFileName()),
          trace: n.map((e) => `    at ${e}`).join('\n'),
        };
      }
    },
    778: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = inherit;
      function inherit(e, t, r) {
        if (t && r) {
          t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean)));
        }
      }
    },
    485: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = cleanJSXElementLiteralChild;
      var s = r(397);
      var i = r(4739);
      function cleanJSXElementLiteralChild(e, t) {
        const r = e.value.split(/\r\n|\n|\r/);
        let n = 0;
        for (let e = 0; e < r.length; e++) {
          if (r[e].match(/[^ \t]/)) {
            n = e;
          }
        }
        let a = '';
        for (let e = 0; e < r.length; e++) {
          const t = r[e];
          const s = e === 0;
          const i = e === r.length - 1;
          const o = e === n;
          let l = t.replace(/\t/g, ' ');
          if (!s) {
            l = l.replace(/^[ ]+/, '');
          }
          if (!i) {
            l = l.replace(/[ ]+$/, '');
          }
          if (l) {
            if (!o) {
              l += ' ';
            }
            a += l;
          }
        }
        if (a) t.push((0, i.inherits)((0, s.stringLiteral)(a), e));
      }
    },
    79: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = shallowEqual;
      function shallowEqual(e, t) {
        const r = Object.keys(t);
        for (const s of r) {
          if (e[s] !== t[s]) {
            return false;
          }
        }
        return true;
      }
    },
    5659: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = buildMatchMemberExpression;
      var s = r(3794);
      function buildMatchMemberExpression(e, t) {
        const r = e.split('.');
        return (e) => (0, s.default)(e, r, t);
      }
    },
    6428: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t.isAccessor = isAccessor;
      t.isAnyTypeAnnotation = isAnyTypeAnnotation;
      t.isArgumentPlaceholder = isArgumentPlaceholder;
      t.isArrayExpression = isArrayExpression;
      t.isArrayPattern = isArrayPattern;
      t.isArrayTypeAnnotation = isArrayTypeAnnotation;
      t.isArrowFunctionExpression = isArrowFunctionExpression;
      t.isAssignmentExpression = isAssignmentExpression;
      t.isAssignmentPattern = isAssignmentPattern;
      t.isAwaitExpression = isAwaitExpression;
      t.isBigIntLiteral = isBigIntLiteral;
      t.isBinary = isBinary;
      t.isBinaryExpression = isBinaryExpression;
      t.isBindExpression = isBindExpression;
      t.isBlock = isBlock;
      t.isBlockParent = isBlockParent;
      t.isBlockStatement = isBlockStatement;
      t.isBooleanLiteral = isBooleanLiteral;
      t.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
      t.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
      t.isBreakStatement = isBreakStatement;
      t.isCallExpression = isCallExpression;
      t.isCatchClause = isCatchClause;
      t.isClass = isClass;
      t.isClassAccessorProperty = isClassAccessorProperty;
      t.isClassBody = isClassBody;
      t.isClassDeclaration = isClassDeclaration;
      t.isClassExpression = isClassExpression;
      t.isClassImplements = isClassImplements;
      t.isClassMethod = isClassMethod;
      t.isClassPrivateMethod = isClassPrivateMethod;
      t.isClassPrivateProperty = isClassPrivateProperty;
      t.isClassProperty = isClassProperty;
      t.isCompletionStatement = isCompletionStatement;
      t.isConditional = isConditional;
      t.isConditionalExpression = isConditionalExpression;
      t.isContinueStatement = isContinueStatement;
      t.isDebuggerStatement = isDebuggerStatement;
      t.isDecimalLiteral = isDecimalLiteral;
      t.isDeclaration = isDeclaration;
      t.isDeclareClass = isDeclareClass;
      t.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
      t.isDeclareExportDeclaration = isDeclareExportDeclaration;
      t.isDeclareFunction = isDeclareFunction;
      t.isDeclareInterface = isDeclareInterface;
      t.isDeclareModule = isDeclareModule;
      t.isDeclareModuleExports = isDeclareModuleExports;
      t.isDeclareOpaqueType = isDeclareOpaqueType;
      t.isDeclareTypeAlias = isDeclareTypeAlias;
      t.isDeclareVariable = isDeclareVariable;
      t.isDeclaredPredicate = isDeclaredPredicate;
      t.isDecorator = isDecorator;
      t.isDirective = isDirective;
      t.isDirectiveLiteral = isDirectiveLiteral;
      t.isDoExpression = isDoExpression;
      t.isDoWhileStatement = isDoWhileStatement;
      t.isEmptyStatement = isEmptyStatement;
      t.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
      t.isEnumBody = isEnumBody;
      t.isEnumBooleanBody = isEnumBooleanBody;
      t.isEnumBooleanMember = isEnumBooleanMember;
      t.isEnumDeclaration = isEnumDeclaration;
      t.isEnumDefaultedMember = isEnumDefaultedMember;
      t.isEnumMember = isEnumMember;
      t.isEnumNumberBody = isEnumNumberBody;
      t.isEnumNumberMember = isEnumNumberMember;
      t.isEnumStringBody = isEnumStringBody;
      t.isEnumStringMember = isEnumStringMember;
      t.isEnumSymbolBody = isEnumSymbolBody;
      t.isExistsTypeAnnotation = isExistsTypeAnnotation;
      t.isExportAllDeclaration = isExportAllDeclaration;
      t.isExportDeclaration = isExportDeclaration;
      t.isExportDefaultDeclaration = isExportDefaultDeclaration;
      t.isExportDefaultSpecifier = isExportDefaultSpecifier;
      t.isExportNamedDeclaration = isExportNamedDeclaration;
      t.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
      t.isExportSpecifier = isExportSpecifier;
      t.isExpression = isExpression;
      t.isExpressionStatement = isExpressionStatement;
      t.isExpressionWrapper = isExpressionWrapper;
      t.isFile = isFile;
      t.isFlow = isFlow;
      t.isFlowBaseAnnotation = isFlowBaseAnnotation;
      t.isFlowDeclaration = isFlowDeclaration;
      t.isFlowPredicate = isFlowPredicate;
      t.isFlowType = isFlowType;
      t.isFor = isFor;
      t.isForInStatement = isForInStatement;
      t.isForOfStatement = isForOfStatement;
      t.isForStatement = isForStatement;
      t.isForXStatement = isForXStatement;
      t.isFunction = isFunction;
      t.isFunctionDeclaration = isFunctionDeclaration;
      t.isFunctionExpression = isFunctionExpression;
      t.isFunctionParent = isFunctionParent;
      t.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
      t.isFunctionTypeParam = isFunctionTypeParam;
      t.isGenericTypeAnnotation = isGenericTypeAnnotation;
      t.isIdentifier = isIdentifier;
      t.isIfStatement = isIfStatement;
      t.isImmutable = isImmutable;
      t.isImport = isImport;
      t.isImportAttribute = isImportAttribute;
      t.isImportDeclaration = isImportDeclaration;
      t.isImportDefaultSpecifier = isImportDefaultSpecifier;
      t.isImportExpression = isImportExpression;
      t.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
      t.isImportOrExportDeclaration = isImportOrExportDeclaration;
      t.isImportSpecifier = isImportSpecifier;
      t.isIndexedAccessType = isIndexedAccessType;
      t.isInferredPredicate = isInferredPredicate;
      t.isInterfaceDeclaration = isInterfaceDeclaration;
      t.isInterfaceExtends = isInterfaceExtends;
      t.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
      t.isInterpreterDirective = isInterpreterDirective;
      t.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
      t.isJSX = isJSX;
      t.isJSXAttribute = isJSXAttribute;
      t.isJSXClosingElement = isJSXClosingElement;
      t.isJSXClosingFragment = isJSXClosingFragment;
      t.isJSXElement = isJSXElement;
      t.isJSXEmptyExpression = isJSXEmptyExpression;
      t.isJSXExpressionContainer = isJSXExpressionContainer;
      t.isJSXFragment = isJSXFragment;
      t.isJSXIdentifier = isJSXIdentifier;
      t.isJSXMemberExpression = isJSXMemberExpression;
      t.isJSXNamespacedName = isJSXNamespacedName;
      t.isJSXOpeningElement = isJSXOpeningElement;
      t.isJSXOpeningFragment = isJSXOpeningFragment;
      t.isJSXSpreadAttribute = isJSXSpreadAttribute;
      t.isJSXSpreadChild = isJSXSpreadChild;
      t.isJSXText = isJSXText;
      t.isLVal = isLVal;
      t.isLabeledStatement = isLabeledStatement;
      t.isLiteral = isLiteral;
      t.isLogicalExpression = isLogicalExpression;
      t.isLoop = isLoop;
      t.isMemberExpression = isMemberExpression;
      t.isMetaProperty = isMetaProperty;
      t.isMethod = isMethod;
      t.isMiscellaneous = isMiscellaneous;
      t.isMixedTypeAnnotation = isMixedTypeAnnotation;
      t.isModuleDeclaration = isModuleDeclaration;
      t.isModuleExpression = isModuleExpression;
      t.isModuleSpecifier = isModuleSpecifier;
      t.isNewExpression = isNewExpression;
      t.isNoop = isNoop;
      t.isNullLiteral = isNullLiteral;
      t.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
      t.isNullableTypeAnnotation = isNullableTypeAnnotation;
      t.isNumberLiteral = isNumberLiteral;
      t.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
      t.isNumberTypeAnnotation = isNumberTypeAnnotation;
      t.isNumericLiteral = isNumericLiteral;
      t.isObjectExpression = isObjectExpression;
      t.isObjectMember = isObjectMember;
      t.isObjectMethod = isObjectMethod;
      t.isObjectPattern = isObjectPattern;
      t.isObjectProperty = isObjectProperty;
      t.isObjectTypeAnnotation = isObjectTypeAnnotation;
      t.isObjectTypeCallProperty = isObjectTypeCallProperty;
      t.isObjectTypeIndexer = isObjectTypeIndexer;
      t.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
      t.isObjectTypeProperty = isObjectTypeProperty;
      t.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
      t.isOpaqueType = isOpaqueType;
      t.isOptionalCallExpression = isOptionalCallExpression;
      t.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
      t.isOptionalMemberExpression = isOptionalMemberExpression;
      t.isParenthesizedExpression = isParenthesizedExpression;
      t.isPattern = isPattern;
      t.isPatternLike = isPatternLike;
      t.isPipelineBareFunction = isPipelineBareFunction;
      t.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
      t.isPipelineTopicExpression = isPipelineTopicExpression;
      t.isPlaceholder = isPlaceholder;
      t.isPrivate = isPrivate;
      t.isPrivateName = isPrivateName;
      t.isProgram = isProgram;
      t.isProperty = isProperty;
      t.isPureish = isPureish;
      t.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
      t.isRecordExpression = isRecordExpression;
      t.isRegExpLiteral = isRegExpLiteral;
      t.isRegexLiteral = isRegexLiteral;
      t.isRestElement = isRestElement;
      t.isRestProperty = isRestProperty;
      t.isReturnStatement = isReturnStatement;
      t.isScopable = isScopable;
      t.isSequenceExpression = isSequenceExpression;
      t.isSpreadElement = isSpreadElement;
      t.isSpreadProperty = isSpreadProperty;
      t.isStandardized = isStandardized;
      t.isStatement = isStatement;
      t.isStaticBlock = isStaticBlock;
      t.isStringLiteral = isStringLiteral;
      t.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
      t.isStringTypeAnnotation = isStringTypeAnnotation;
      t.isSuper = isSuper;
      t.isSwitchCase = isSwitchCase;
      t.isSwitchStatement = isSwitchStatement;
      t.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
      t.isTSAnyKeyword = isTSAnyKeyword;
      t.isTSArrayType = isTSArrayType;
      t.isTSAsExpression = isTSAsExpression;
      t.isTSBaseType = isTSBaseType;
      t.isTSBigIntKeyword = isTSBigIntKeyword;
      t.isTSBooleanKeyword = isTSBooleanKeyword;
      t.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
      t.isTSConditionalType = isTSConditionalType;
      t.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
      t.isTSConstructorType = isTSConstructorType;
      t.isTSDeclareFunction = isTSDeclareFunction;
      t.isTSDeclareMethod = isTSDeclareMethod;
      t.isTSEntityName = isTSEntityName;
      t.isTSEnumDeclaration = isTSEnumDeclaration;
      t.isTSEnumMember = isTSEnumMember;
      t.isTSExportAssignment = isTSExportAssignment;
      t.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
      t.isTSExternalModuleReference = isTSExternalModuleReference;
      t.isTSFunctionType = isTSFunctionType;
      t.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
      t.isTSImportType = isTSImportType;
      t.isTSIndexSignature = isTSIndexSignature;
      t.isTSIndexedAccessType = isTSIndexedAccessType;
      t.isTSInferType = isTSInferType;
      t.isTSInstantiationExpression = isTSInstantiationExpression;
      t.isTSInterfaceBody = isTSInterfaceBody;
      t.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
      t.isTSIntersectionType = isTSIntersectionType;
      t.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
      t.isTSLiteralType = isTSLiteralType;
      t.isTSMappedType = isTSMappedType;
      t.isTSMethodSignature = isTSMethodSignature;
      t.isTSModuleBlock = isTSModuleBlock;
      t.isTSModuleDeclaration = isTSModuleDeclaration;
      t.isTSNamedTupleMember = isTSNamedTupleMember;
      t.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
      t.isTSNeverKeyword = isTSNeverKeyword;
      t.isTSNonNullExpression = isTSNonNullExpression;
      t.isTSNullKeyword = isTSNullKeyword;
      t.isTSNumberKeyword = isTSNumberKeyword;
      t.isTSObjectKeyword = isTSObjectKeyword;
      t.isTSOptionalType = isTSOptionalType;
      t.isTSParameterProperty = isTSParameterProperty;
      t.isTSParenthesizedType = isTSParenthesizedType;
      t.isTSPropertySignature = isTSPropertySignature;
      t.isTSQualifiedName = isTSQualifiedName;
      t.isTSRestType = isTSRestType;
      t.isTSSatisfiesExpression = isTSSatisfiesExpression;
      t.isTSStringKeyword = isTSStringKeyword;
      t.isTSSymbolKeyword = isTSSymbolKeyword;
      t.isTSThisType = isTSThisType;
      t.isTSTupleType = isTSTupleType;
      t.isTSType = isTSType;
      t.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
      t.isTSTypeAnnotation = isTSTypeAnnotation;
      t.isTSTypeAssertion = isTSTypeAssertion;
      t.isTSTypeElement = isTSTypeElement;
      t.isTSTypeLiteral = isTSTypeLiteral;
      t.isTSTypeOperator = isTSTypeOperator;
      t.isTSTypeParameter = isTSTypeParameter;
      t.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
      t.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
      t.isTSTypePredicate = isTSTypePredicate;
      t.isTSTypeQuery = isTSTypeQuery;
      t.isTSTypeReference = isTSTypeReference;
      t.isTSUndefinedKeyword = isTSUndefinedKeyword;
      t.isTSUnionType = isTSUnionType;
      t.isTSUnknownKeyword = isTSUnknownKeyword;
      t.isTSVoidKeyword = isTSVoidKeyword;
      t.isTaggedTemplateExpression = isTaggedTemplateExpression;
      t.isTemplateElement = isTemplateElement;
      t.isTemplateLiteral = isTemplateLiteral;
      t.isTerminatorless = isTerminatorless;
      t.isThisExpression = isThisExpression;
      t.isThisTypeAnnotation = isThisTypeAnnotation;
      t.isThrowStatement = isThrowStatement;
      t.isTopicReference = isTopicReference;
      t.isTryStatement = isTryStatement;
      t.isTupleExpression = isTupleExpression;
      t.isTupleTypeAnnotation = isTupleTypeAnnotation;
      t.isTypeAlias = isTypeAlias;
      t.isTypeAnnotation = isTypeAnnotation;
      t.isTypeCastExpression = isTypeCastExpression;
      t.isTypeParameter = isTypeParameter;
      t.isTypeParameterDeclaration = isTypeParameterDeclaration;
      t.isTypeParameterInstantiation = isTypeParameterInstantiation;
      t.isTypeScript = isTypeScript;
      t.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
      t.isUnaryExpression = isUnaryExpression;
      t.isUnaryLike = isUnaryLike;
      t.isUnionTypeAnnotation = isUnionTypeAnnotation;
      t.isUpdateExpression = isUpdateExpression;
      t.isUserWhitespacable = isUserWhitespacable;
      t.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
      t.isVariableDeclaration = isVariableDeclaration;
      t.isVariableDeclarator = isVariableDeclarator;
      t.isVariance = isVariance;
      t.isVoidTypeAnnotation = isVoidTypeAnnotation;
      t.isWhile = isWhile;
      t.isWhileStatement = isWhileStatement;
      t.isWithStatement = isWithStatement;
      t.isYieldExpression = isYieldExpression;
      var s = r(79);
      var i = r(8418);
      function isArrayExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'ArrayExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isAssignmentExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'AssignmentExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isBinaryExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'BinaryExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isInterpreterDirective(e, t) {
        if (!e) return false;
        if (e.type !== 'InterpreterDirective') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDirective(e, t) {
        if (!e) return false;
        if (e.type !== 'Directive') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDirectiveLiteral(e, t) {
        if (!e) return false;
        if (e.type !== 'DirectiveLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isBlockStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'BlockStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isBreakStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'BreakStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isCallExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'CallExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isCatchClause(e, t) {
        if (!e) return false;
        if (e.type !== 'CatchClause') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isConditionalExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'ConditionalExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isContinueStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'ContinueStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDebuggerStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'DebuggerStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDoWhileStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'DoWhileStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isEmptyStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'EmptyStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isExpressionStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'ExpressionStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isFile(e, t) {
        if (!e) return false;
        if (e.type !== 'File') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isForInStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'ForInStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isForStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'ForStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isFunctionDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'FunctionDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isFunctionExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'FunctionExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isIdentifier(e, t) {
        if (!e) return false;
        if (e.type !== 'Identifier') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isIfStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'IfStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isLabeledStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'LabeledStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isStringLiteral(e, t) {
        if (!e) return false;
        if (e.type !== 'StringLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isNumericLiteral(e, t) {
        if (!e) return false;
        if (e.type !== 'NumericLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isNullLiteral(e, t) {
        if (!e) return false;
        if (e.type !== 'NullLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isBooleanLiteral(e, t) {
        if (!e) return false;
        if (e.type !== 'BooleanLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isRegExpLiteral(e, t) {
        if (!e) return false;
        if (e.type !== 'RegExpLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isLogicalExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'LogicalExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isMemberExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'MemberExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isNewExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'NewExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isProgram(e, t) {
        if (!e) return false;
        if (e.type !== 'Program') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isObjectExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'ObjectExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isObjectMethod(e, t) {
        if (!e) return false;
        if (e.type !== 'ObjectMethod') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isObjectProperty(e, t) {
        if (!e) return false;
        if (e.type !== 'ObjectProperty') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isRestElement(e, t) {
        if (!e) return false;
        if (e.type !== 'RestElement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isReturnStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'ReturnStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isSequenceExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'SequenceExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isParenthesizedExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'ParenthesizedExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isSwitchCase(e, t) {
        if (!e) return false;
        if (e.type !== 'SwitchCase') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isSwitchStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'SwitchStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isThisExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'ThisExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isThrowStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'ThrowStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTryStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'TryStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isUnaryExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'UnaryExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isUpdateExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'UpdateExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isVariableDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'VariableDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isVariableDeclarator(e, t) {
        if (!e) return false;
        if (e.type !== 'VariableDeclarator') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isWhileStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'WhileStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isWithStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'WithStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isAssignmentPattern(e, t) {
        if (!e) return false;
        if (e.type !== 'AssignmentPattern') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isArrayPattern(e, t) {
        if (!e) return false;
        if (e.type !== 'ArrayPattern') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isArrowFunctionExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'ArrowFunctionExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isClassBody(e, t) {
        if (!e) return false;
        if (e.type !== 'ClassBody') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isClassExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'ClassExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isClassDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'ClassDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isExportAllDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'ExportAllDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isExportDefaultDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'ExportDefaultDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isExportNamedDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'ExportNamedDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isExportSpecifier(e, t) {
        if (!e) return false;
        if (e.type !== 'ExportSpecifier') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isForOfStatement(e, t) {
        if (!e) return false;
        if (e.type !== 'ForOfStatement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isImportDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'ImportDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isImportDefaultSpecifier(e, t) {
        if (!e) return false;
        if (e.type !== 'ImportDefaultSpecifier') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isImportNamespaceSpecifier(e, t) {
        if (!e) return false;
        if (e.type !== 'ImportNamespaceSpecifier') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isImportSpecifier(e, t) {
        if (!e) return false;
        if (e.type !== 'ImportSpecifier') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isImportExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'ImportExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isMetaProperty(e, t) {
        if (!e) return false;
        if (e.type !== 'MetaProperty') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isClassMethod(e, t) {
        if (!e) return false;
        if (e.type !== 'ClassMethod') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isObjectPattern(e, t) {
        if (!e) return false;
        if (e.type !== 'ObjectPattern') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isSpreadElement(e, t) {
        if (!e) return false;
        if (e.type !== 'SpreadElement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isSuper(e, t) {
        if (!e) return false;
        if (e.type !== 'Super') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTaggedTemplateExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'TaggedTemplateExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTemplateElement(e, t) {
        if (!e) return false;
        if (e.type !== 'TemplateElement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTemplateLiteral(e, t) {
        if (!e) return false;
        if (e.type !== 'TemplateLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isYieldExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'YieldExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isAwaitExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'AwaitExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isImport(e, t) {
        if (!e) return false;
        if (e.type !== 'Import') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isBigIntLiteral(e, t) {
        if (!e) return false;
        if (e.type !== 'BigIntLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isExportNamespaceSpecifier(e, t) {
        if (!e) return false;
        if (e.type !== 'ExportNamespaceSpecifier') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isOptionalMemberExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'OptionalMemberExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isOptionalCallExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'OptionalCallExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isClassProperty(e, t) {
        if (!e) return false;
        if (e.type !== 'ClassProperty') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isClassAccessorProperty(e, t) {
        if (!e) return false;
        if (e.type !== 'ClassAccessorProperty') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isClassPrivateProperty(e, t) {
        if (!e) return false;
        if (e.type !== 'ClassPrivateProperty') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isClassPrivateMethod(e, t) {
        if (!e) return false;
        if (e.type !== 'ClassPrivateMethod') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isPrivateName(e, t) {
        if (!e) return false;
        if (e.type !== 'PrivateName') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isStaticBlock(e, t) {
        if (!e) return false;
        if (e.type !== 'StaticBlock') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isAnyTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'AnyTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isArrayTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'ArrayTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isBooleanTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'BooleanTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isBooleanLiteralTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'BooleanLiteralTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isNullLiteralTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'NullLiteralTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isClassImplements(e, t) {
        if (!e) return false;
        if (e.type !== 'ClassImplements') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDeclareClass(e, t) {
        if (!e) return false;
        if (e.type !== 'DeclareClass') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDeclareFunction(e, t) {
        if (!e) return false;
        if (e.type !== 'DeclareFunction') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDeclareInterface(e, t) {
        if (!e) return false;
        if (e.type !== 'DeclareInterface') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDeclareModule(e, t) {
        if (!e) return false;
        if (e.type !== 'DeclareModule') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDeclareModuleExports(e, t) {
        if (!e) return false;
        if (e.type !== 'DeclareModuleExports') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDeclareTypeAlias(e, t) {
        if (!e) return false;
        if (e.type !== 'DeclareTypeAlias') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDeclareOpaqueType(e, t) {
        if (!e) return false;
        if (e.type !== 'DeclareOpaqueType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDeclareVariable(e, t) {
        if (!e) return false;
        if (e.type !== 'DeclareVariable') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDeclareExportDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'DeclareExportDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDeclareExportAllDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'DeclareExportAllDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDeclaredPredicate(e, t) {
        if (!e) return false;
        if (e.type !== 'DeclaredPredicate') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isExistsTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'ExistsTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isFunctionTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'FunctionTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isFunctionTypeParam(e, t) {
        if (!e) return false;
        if (e.type !== 'FunctionTypeParam') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isGenericTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'GenericTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isInferredPredicate(e, t) {
        if (!e) return false;
        if (e.type !== 'InferredPredicate') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isInterfaceExtends(e, t) {
        if (!e) return false;
        if (e.type !== 'InterfaceExtends') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isInterfaceDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'InterfaceDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isInterfaceTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'InterfaceTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isIntersectionTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'IntersectionTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isMixedTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'MixedTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isEmptyTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'EmptyTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isNullableTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'NullableTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isNumberLiteralTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'NumberLiteralTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isNumberTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'NumberTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isObjectTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'ObjectTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isObjectTypeInternalSlot(e, t) {
        if (!e) return false;
        if (e.type !== 'ObjectTypeInternalSlot') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isObjectTypeCallProperty(e, t) {
        if (!e) return false;
        if (e.type !== 'ObjectTypeCallProperty') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isObjectTypeIndexer(e, t) {
        if (!e) return false;
        if (e.type !== 'ObjectTypeIndexer') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isObjectTypeProperty(e, t) {
        if (!e) return false;
        if (e.type !== 'ObjectTypeProperty') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isObjectTypeSpreadProperty(e, t) {
        if (!e) return false;
        if (e.type !== 'ObjectTypeSpreadProperty') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isOpaqueType(e, t) {
        if (!e) return false;
        if (e.type !== 'OpaqueType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isQualifiedTypeIdentifier(e, t) {
        if (!e) return false;
        if (e.type !== 'QualifiedTypeIdentifier') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isStringLiteralTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'StringLiteralTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isStringTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'StringTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isSymbolTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'SymbolTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isThisTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'ThisTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTupleTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'TupleTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTypeofTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'TypeofTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTypeAlias(e, t) {
        if (!e) return false;
        if (e.type !== 'TypeAlias') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'TypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTypeCastExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'TypeCastExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTypeParameter(e, t) {
        if (!e) return false;
        if (e.type !== 'TypeParameter') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTypeParameterDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'TypeParameterDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTypeParameterInstantiation(e, t) {
        if (!e) return false;
        if (e.type !== 'TypeParameterInstantiation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isUnionTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'UnionTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isVariance(e, t) {
        if (!e) return false;
        if (e.type !== 'Variance') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isVoidTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'VoidTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isEnumDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'EnumDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isEnumBooleanBody(e, t) {
        if (!e) return false;
        if (e.type !== 'EnumBooleanBody') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isEnumNumberBody(e, t) {
        if (!e) return false;
        if (e.type !== 'EnumNumberBody') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isEnumStringBody(e, t) {
        if (!e) return false;
        if (e.type !== 'EnumStringBody') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isEnumSymbolBody(e, t) {
        if (!e) return false;
        if (e.type !== 'EnumSymbolBody') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isEnumBooleanMember(e, t) {
        if (!e) return false;
        if (e.type !== 'EnumBooleanMember') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isEnumNumberMember(e, t) {
        if (!e) return false;
        if (e.type !== 'EnumNumberMember') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isEnumStringMember(e, t) {
        if (!e) return false;
        if (e.type !== 'EnumStringMember') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isEnumDefaultedMember(e, t) {
        if (!e) return false;
        if (e.type !== 'EnumDefaultedMember') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isIndexedAccessType(e, t) {
        if (!e) return false;
        if (e.type !== 'IndexedAccessType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isOptionalIndexedAccessType(e, t) {
        if (!e) return false;
        if (e.type !== 'OptionalIndexedAccessType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXAttribute(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXAttribute') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXClosingElement(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXClosingElement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXElement(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXElement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXEmptyExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXEmptyExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXExpressionContainer(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXExpressionContainer') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXSpreadChild(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXSpreadChild') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXIdentifier(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXIdentifier') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXMemberExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXMemberExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXNamespacedName(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXNamespacedName') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXOpeningElement(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXOpeningElement') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXSpreadAttribute(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXSpreadAttribute') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXText(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXText') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXFragment(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXFragment') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXOpeningFragment(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXOpeningFragment') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isJSXClosingFragment(e, t) {
        if (!e) return false;
        if (e.type !== 'JSXClosingFragment') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isNoop(e, t) {
        if (!e) return false;
        if (e.type !== 'Noop') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isPlaceholder(e, t) {
        if (!e) return false;
        if (e.type !== 'Placeholder') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isV8IntrinsicIdentifier(e, t) {
        if (!e) return false;
        if (e.type !== 'V8IntrinsicIdentifier') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isArgumentPlaceholder(e, t) {
        if (!e) return false;
        if (e.type !== 'ArgumentPlaceholder') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isBindExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'BindExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isImportAttribute(e, t) {
        if (!e) return false;
        if (e.type !== 'ImportAttribute') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDecorator(e, t) {
        if (!e) return false;
        if (e.type !== 'Decorator') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDoExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'DoExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isExportDefaultSpecifier(e, t) {
        if (!e) return false;
        if (e.type !== 'ExportDefaultSpecifier') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isRecordExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'RecordExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTupleExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'TupleExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isDecimalLiteral(e, t) {
        if (!e) return false;
        if (e.type !== 'DecimalLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isModuleExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'ModuleExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTopicReference(e, t) {
        if (!e) return false;
        if (e.type !== 'TopicReference') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isPipelineTopicExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'PipelineTopicExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isPipelineBareFunction(e, t) {
        if (!e) return false;
        if (e.type !== 'PipelineBareFunction') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isPipelinePrimaryTopicReference(e, t) {
        if (!e) return false;
        if (e.type !== 'PipelinePrimaryTopicReference') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSParameterProperty(e, t) {
        if (!e) return false;
        if (e.type !== 'TSParameterProperty') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSDeclareFunction(e, t) {
        if (!e) return false;
        if (e.type !== 'TSDeclareFunction') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSDeclareMethod(e, t) {
        if (!e) return false;
        if (e.type !== 'TSDeclareMethod') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSQualifiedName(e, t) {
        if (!e) return false;
        if (e.type !== 'TSQualifiedName') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSCallSignatureDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'TSCallSignatureDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSConstructSignatureDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'TSConstructSignatureDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSPropertySignature(e, t) {
        if (!e) return false;
        if (e.type !== 'TSPropertySignature') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSMethodSignature(e, t) {
        if (!e) return false;
        if (e.type !== 'TSMethodSignature') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSIndexSignature(e, t) {
        if (!e) return false;
        if (e.type !== 'TSIndexSignature') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSAnyKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSAnyKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSBooleanKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSBooleanKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSBigIntKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSBigIntKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSIntrinsicKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSIntrinsicKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSNeverKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSNeverKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSNullKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSNullKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSNumberKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSNumberKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSObjectKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSObjectKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSStringKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSStringKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSSymbolKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSSymbolKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSUndefinedKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSUndefinedKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSUnknownKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSUnknownKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSVoidKeyword(e, t) {
        if (!e) return false;
        if (e.type !== 'TSVoidKeyword') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSThisType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSThisType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSFunctionType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSFunctionType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSConstructorType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSConstructorType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypeReference(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTypeReference') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypePredicate(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTypePredicate') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypeQuery(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTypeQuery') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypeLiteral(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTypeLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSArrayType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSArrayType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTupleType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTupleType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSOptionalType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSOptionalType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSRestType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSRestType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSNamedTupleMember(e, t) {
        if (!e) return false;
        if (e.type !== 'TSNamedTupleMember') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSUnionType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSUnionType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSIntersectionType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSIntersectionType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSConditionalType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSConditionalType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSInferType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSInferType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSParenthesizedType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSParenthesizedType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypeOperator(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTypeOperator') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSIndexedAccessType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSIndexedAccessType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSMappedType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSMappedType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSLiteralType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSLiteralType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSExpressionWithTypeArguments(e, t) {
        if (!e) return false;
        if (e.type !== 'TSExpressionWithTypeArguments') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSInterfaceDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'TSInterfaceDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSInterfaceBody(e, t) {
        if (!e) return false;
        if (e.type !== 'TSInterfaceBody') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypeAliasDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTypeAliasDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSInstantiationExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'TSInstantiationExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSAsExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'TSAsExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSSatisfiesExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'TSSatisfiesExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypeAssertion(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTypeAssertion') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSEnumDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'TSEnumDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSEnumMember(e, t) {
        if (!e) return false;
        if (e.type !== 'TSEnumMember') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSModuleDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'TSModuleDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSModuleBlock(e, t) {
        if (!e) return false;
        if (e.type !== 'TSModuleBlock') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSImportType(e, t) {
        if (!e) return false;
        if (e.type !== 'TSImportType') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSImportEqualsDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'TSImportEqualsDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSExternalModuleReference(e, t) {
        if (!e) return false;
        if (e.type !== 'TSExternalModuleReference') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSNonNullExpression(e, t) {
        if (!e) return false;
        if (e.type !== 'TSNonNullExpression') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSExportAssignment(e, t) {
        if (!e) return false;
        if (e.type !== 'TSExportAssignment') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSNamespaceExportDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'TSNamespaceExportDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypeAnnotation(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTypeAnnotation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypeParameterInstantiation(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTypeParameterInstantiation') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypeParameterDeclaration(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTypeParameterDeclaration') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypeParameter(e, t) {
        if (!e) return false;
        if (e.type !== 'TSTypeParameter') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isStandardized(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ArrayExpression':
          case 'AssignmentExpression':
          case 'BinaryExpression':
          case 'InterpreterDirective':
          case 'Directive':
          case 'DirectiveLiteral':
          case 'BlockStatement':
          case 'BreakStatement':
          case 'CallExpression':
          case 'CatchClause':
          case 'ConditionalExpression':
          case 'ContinueStatement':
          case 'DebuggerStatement':
          case 'DoWhileStatement':
          case 'EmptyStatement':
          case 'ExpressionStatement':
          case 'File':
          case 'ForInStatement':
          case 'ForStatement':
          case 'FunctionDeclaration':
          case 'FunctionExpression':
          case 'Identifier':
          case 'IfStatement':
          case 'LabeledStatement':
          case 'StringLiteral':
          case 'NumericLiteral':
          case 'NullLiteral':
          case 'BooleanLiteral':
          case 'RegExpLiteral':
          case 'LogicalExpression':
          case 'MemberExpression':
          case 'NewExpression':
          case 'Program':
          case 'ObjectExpression':
          case 'ObjectMethod':
          case 'ObjectProperty':
          case 'RestElement':
          case 'ReturnStatement':
          case 'SequenceExpression':
          case 'ParenthesizedExpression':
          case 'SwitchCase':
          case 'SwitchStatement':
          case 'ThisExpression':
          case 'ThrowStatement':
          case 'TryStatement':
          case 'UnaryExpression':
          case 'UpdateExpression':
          case 'VariableDeclaration':
          case 'VariableDeclarator':
          case 'WhileStatement':
          case 'WithStatement':
          case 'AssignmentPattern':
          case 'ArrayPattern':
          case 'ArrowFunctionExpression':
          case 'ClassBody':
          case 'ClassExpression':
          case 'ClassDeclaration':
          case 'ExportAllDeclaration':
          case 'ExportDefaultDeclaration':
          case 'ExportNamedDeclaration':
          case 'ExportSpecifier':
          case 'ForOfStatement':
          case 'ImportDeclaration':
          case 'ImportDefaultSpecifier':
          case 'ImportNamespaceSpecifier':
          case 'ImportSpecifier':
          case 'ImportExpression':
          case 'MetaProperty':
          case 'ClassMethod':
          case 'ObjectPattern':
          case 'SpreadElement':
          case 'Super':
          case 'TaggedTemplateExpression':
          case 'TemplateElement':
          case 'TemplateLiteral':
          case 'YieldExpression':
          case 'AwaitExpression':
          case 'Import':
          case 'BigIntLiteral':
          case 'ExportNamespaceSpecifier':
          case 'OptionalMemberExpression':
          case 'OptionalCallExpression':
          case 'ClassProperty':
          case 'ClassAccessorProperty':
          case 'ClassPrivateProperty':
          case 'ClassPrivateMethod':
          case 'PrivateName':
          case 'StaticBlock':
            break;
          case 'Placeholder':
            switch (e.expectedNode) {
              case 'Identifier':
              case 'StringLiteral':
              case 'BlockStatement':
              case 'ClassBody':
                break;
              default:
                return false;
            }
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isExpression(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ArrayExpression':
          case 'AssignmentExpression':
          case 'BinaryExpression':
          case 'CallExpression':
          case 'ConditionalExpression':
          case 'FunctionExpression':
          case 'Identifier':
          case 'StringLiteral':
          case 'NumericLiteral':
          case 'NullLiteral':
          case 'BooleanLiteral':
          case 'RegExpLiteral':
          case 'LogicalExpression':
          case 'MemberExpression':
          case 'NewExpression':
          case 'ObjectExpression':
          case 'SequenceExpression':
          case 'ParenthesizedExpression':
          case 'ThisExpression':
          case 'UnaryExpression':
          case 'UpdateExpression':
          case 'ArrowFunctionExpression':
          case 'ClassExpression':
          case 'ImportExpression':
          case 'MetaProperty':
          case 'Super':
          case 'TaggedTemplateExpression':
          case 'TemplateLiteral':
          case 'YieldExpression':
          case 'AwaitExpression':
          case 'Import':
          case 'BigIntLiteral':
          case 'OptionalMemberExpression':
          case 'OptionalCallExpression':
          case 'TypeCastExpression':
          case 'JSXElement':
          case 'JSXFragment':
          case 'BindExpression':
          case 'DoExpression':
          case 'RecordExpression':
          case 'TupleExpression':
          case 'DecimalLiteral':
          case 'ModuleExpression':
          case 'TopicReference':
          case 'PipelineTopicExpression':
          case 'PipelineBareFunction':
          case 'PipelinePrimaryTopicReference':
          case 'TSInstantiationExpression':
          case 'TSAsExpression':
          case 'TSSatisfiesExpression':
          case 'TSTypeAssertion':
          case 'TSNonNullExpression':
            break;
          case 'Placeholder':
            switch (e.expectedNode) {
              case 'Expression':
              case 'Identifier':
              case 'StringLiteral':
                break;
              default:
                return false;
            }
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isBinary(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'BinaryExpression':
          case 'LogicalExpression':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isScopable(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'BlockStatement':
          case 'CatchClause':
          case 'DoWhileStatement':
          case 'ForInStatement':
          case 'ForStatement':
          case 'FunctionDeclaration':
          case 'FunctionExpression':
          case 'Program':
          case 'ObjectMethod':
          case 'SwitchStatement':
          case 'WhileStatement':
          case 'ArrowFunctionExpression':
          case 'ClassExpression':
          case 'ClassDeclaration':
          case 'ForOfStatement':
          case 'ClassMethod':
          case 'ClassPrivateMethod':
          case 'StaticBlock':
          case 'TSModuleBlock':
            break;
          case 'Placeholder':
            if (e.expectedNode === 'BlockStatement') break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isBlockParent(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'BlockStatement':
          case 'CatchClause':
          case 'DoWhileStatement':
          case 'ForInStatement':
          case 'ForStatement':
          case 'FunctionDeclaration':
          case 'FunctionExpression':
          case 'Program':
          case 'ObjectMethod':
          case 'SwitchStatement':
          case 'WhileStatement':
          case 'ArrowFunctionExpression':
          case 'ForOfStatement':
          case 'ClassMethod':
          case 'ClassPrivateMethod':
          case 'StaticBlock':
          case 'TSModuleBlock':
            break;
          case 'Placeholder':
            if (e.expectedNode === 'BlockStatement') break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isBlock(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'BlockStatement':
          case 'Program':
          case 'TSModuleBlock':
            break;
          case 'Placeholder':
            if (e.expectedNode === 'BlockStatement') break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isStatement(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'BlockStatement':
          case 'BreakStatement':
          case 'ContinueStatement':
          case 'DebuggerStatement':
          case 'DoWhileStatement':
          case 'EmptyStatement':
          case 'ExpressionStatement':
          case 'ForInStatement':
          case 'ForStatement':
          case 'FunctionDeclaration':
          case 'IfStatement':
          case 'LabeledStatement':
          case 'ReturnStatement':
          case 'SwitchStatement':
          case 'ThrowStatement':
          case 'TryStatement':
          case 'VariableDeclaration':
          case 'WhileStatement':
          case 'WithStatement':
          case 'ClassDeclaration':
          case 'ExportAllDeclaration':
          case 'ExportDefaultDeclaration':
          case 'ExportNamedDeclaration':
          case 'ForOfStatement':
          case 'ImportDeclaration':
          case 'DeclareClass':
          case 'DeclareFunction':
          case 'DeclareInterface':
          case 'DeclareModule':
          case 'DeclareModuleExports':
          case 'DeclareTypeAlias':
          case 'DeclareOpaqueType':
          case 'DeclareVariable':
          case 'DeclareExportDeclaration':
          case 'DeclareExportAllDeclaration':
          case 'InterfaceDeclaration':
          case 'OpaqueType':
          case 'TypeAlias':
          case 'EnumDeclaration':
          case 'TSDeclareFunction':
          case 'TSInterfaceDeclaration':
          case 'TSTypeAliasDeclaration':
          case 'TSEnumDeclaration':
          case 'TSModuleDeclaration':
          case 'TSImportEqualsDeclaration':
          case 'TSExportAssignment':
          case 'TSNamespaceExportDeclaration':
            break;
          case 'Placeholder':
            switch (e.expectedNode) {
              case 'Statement':
              case 'Declaration':
              case 'BlockStatement':
                break;
              default:
                return false;
            }
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isTerminatorless(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'BreakStatement':
          case 'ContinueStatement':
          case 'ReturnStatement':
          case 'ThrowStatement':
          case 'YieldExpression':
          case 'AwaitExpression':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isCompletionStatement(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'BreakStatement':
          case 'ContinueStatement':
          case 'ReturnStatement':
          case 'ThrowStatement':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isConditional(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ConditionalExpression':
          case 'IfStatement':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isLoop(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'DoWhileStatement':
          case 'ForInStatement':
          case 'ForStatement':
          case 'WhileStatement':
          case 'ForOfStatement':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isWhile(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'DoWhileStatement':
          case 'WhileStatement':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isExpressionWrapper(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ExpressionStatement':
          case 'ParenthesizedExpression':
          case 'TypeCastExpression':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isFor(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ForInStatement':
          case 'ForStatement':
          case 'ForOfStatement':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isForXStatement(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ForInStatement':
          case 'ForOfStatement':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isFunction(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'FunctionDeclaration':
          case 'FunctionExpression':
          case 'ObjectMethod':
          case 'ArrowFunctionExpression':
          case 'ClassMethod':
          case 'ClassPrivateMethod':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isFunctionParent(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'FunctionDeclaration':
          case 'FunctionExpression':
          case 'ObjectMethod':
          case 'ArrowFunctionExpression':
          case 'ClassMethod':
          case 'ClassPrivateMethod':
          case 'StaticBlock':
          case 'TSModuleBlock':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isPureish(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'FunctionDeclaration':
          case 'FunctionExpression':
          case 'StringLiteral':
          case 'NumericLiteral':
          case 'NullLiteral':
          case 'BooleanLiteral':
          case 'RegExpLiteral':
          case 'ArrowFunctionExpression':
          case 'BigIntLiteral':
          case 'DecimalLiteral':
            break;
          case 'Placeholder':
            if (e.expectedNode === 'StringLiteral') break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isDeclaration(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'FunctionDeclaration':
          case 'VariableDeclaration':
          case 'ClassDeclaration':
          case 'ExportAllDeclaration':
          case 'ExportDefaultDeclaration':
          case 'ExportNamedDeclaration':
          case 'ImportDeclaration':
          case 'DeclareClass':
          case 'DeclareFunction':
          case 'DeclareInterface':
          case 'DeclareModule':
          case 'DeclareModuleExports':
          case 'DeclareTypeAlias':
          case 'DeclareOpaqueType':
          case 'DeclareVariable':
          case 'DeclareExportDeclaration':
          case 'DeclareExportAllDeclaration':
          case 'InterfaceDeclaration':
          case 'OpaqueType':
          case 'TypeAlias':
          case 'EnumDeclaration':
          case 'TSDeclareFunction':
          case 'TSInterfaceDeclaration':
          case 'TSTypeAliasDeclaration':
          case 'TSEnumDeclaration':
          case 'TSModuleDeclaration':
            break;
          case 'Placeholder':
            if (e.expectedNode === 'Declaration') break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isPatternLike(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'Identifier':
          case 'RestElement':
          case 'AssignmentPattern':
          case 'ArrayPattern':
          case 'ObjectPattern':
          case 'TSAsExpression':
          case 'TSSatisfiesExpression':
          case 'TSTypeAssertion':
          case 'TSNonNullExpression':
            break;
          case 'Placeholder':
            switch (e.expectedNode) {
              case 'Pattern':
              case 'Identifier':
                break;
              default:
                return false;
            }
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isLVal(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'Identifier':
          case 'MemberExpression':
          case 'RestElement':
          case 'AssignmentPattern':
          case 'ArrayPattern':
          case 'ObjectPattern':
          case 'TSParameterProperty':
          case 'TSAsExpression':
          case 'TSSatisfiesExpression':
          case 'TSTypeAssertion':
          case 'TSNonNullExpression':
            break;
          case 'Placeholder':
            switch (e.expectedNode) {
              case 'Pattern':
              case 'Identifier':
                break;
              default:
                return false;
            }
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isTSEntityName(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'Identifier':
          case 'TSQualifiedName':
            break;
          case 'Placeholder':
            if (e.expectedNode === 'Identifier') break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isLiteral(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'StringLiteral':
          case 'NumericLiteral':
          case 'NullLiteral':
          case 'BooleanLiteral':
          case 'RegExpLiteral':
          case 'TemplateLiteral':
          case 'BigIntLiteral':
          case 'DecimalLiteral':
            break;
          case 'Placeholder':
            if (e.expectedNode === 'StringLiteral') break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isImmutable(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'StringLiteral':
          case 'NumericLiteral':
          case 'NullLiteral':
          case 'BooleanLiteral':
          case 'BigIntLiteral':
          case 'JSXAttribute':
          case 'JSXClosingElement':
          case 'JSXElement':
          case 'JSXExpressionContainer':
          case 'JSXSpreadChild':
          case 'JSXOpeningElement':
          case 'JSXText':
          case 'JSXFragment':
          case 'JSXOpeningFragment':
          case 'JSXClosingFragment':
          case 'DecimalLiteral':
            break;
          case 'Placeholder':
            if (e.expectedNode === 'StringLiteral') break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isUserWhitespacable(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ObjectMethod':
          case 'ObjectProperty':
          case 'ObjectTypeInternalSlot':
          case 'ObjectTypeCallProperty':
          case 'ObjectTypeIndexer':
          case 'ObjectTypeProperty':
          case 'ObjectTypeSpreadProperty':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isMethod(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ObjectMethod':
          case 'ClassMethod':
          case 'ClassPrivateMethod':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isObjectMember(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ObjectMethod':
          case 'ObjectProperty':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isProperty(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ObjectProperty':
          case 'ClassProperty':
          case 'ClassAccessorProperty':
          case 'ClassPrivateProperty':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isUnaryLike(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'UnaryExpression':
          case 'SpreadElement':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isPattern(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'AssignmentPattern':
          case 'ArrayPattern':
          case 'ObjectPattern':
            break;
          case 'Placeholder':
            if (e.expectedNode === 'Pattern') break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isClass(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ClassExpression':
          case 'ClassDeclaration':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isImportOrExportDeclaration(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ExportAllDeclaration':
          case 'ExportDefaultDeclaration':
          case 'ExportNamedDeclaration':
          case 'ImportDeclaration':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isExportDeclaration(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ExportAllDeclaration':
          case 'ExportDefaultDeclaration':
          case 'ExportNamedDeclaration':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isModuleSpecifier(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ExportSpecifier':
          case 'ImportDefaultSpecifier':
          case 'ImportNamespaceSpecifier':
          case 'ImportSpecifier':
          case 'ExportNamespaceSpecifier':
          case 'ExportDefaultSpecifier':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isAccessor(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ClassAccessorProperty':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isPrivate(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'ClassPrivateProperty':
          case 'ClassPrivateMethod':
          case 'PrivateName':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isFlow(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'AnyTypeAnnotation':
          case 'ArrayTypeAnnotation':
          case 'BooleanTypeAnnotation':
          case 'BooleanLiteralTypeAnnotation':
          case 'NullLiteralTypeAnnotation':
          case 'ClassImplements':
          case 'DeclareClass':
          case 'DeclareFunction':
          case 'DeclareInterface':
          case 'DeclareModule':
          case 'DeclareModuleExports':
          case 'DeclareTypeAlias':
          case 'DeclareOpaqueType':
          case 'DeclareVariable':
          case 'DeclareExportDeclaration':
          case 'DeclareExportAllDeclaration':
          case 'DeclaredPredicate':
          case 'ExistsTypeAnnotation':
          case 'FunctionTypeAnnotation':
          case 'FunctionTypeParam':
          case 'GenericTypeAnnotation':
          case 'InferredPredicate':
          case 'InterfaceExtends':
          case 'InterfaceDeclaration':
          case 'InterfaceTypeAnnotation':
          case 'IntersectionTypeAnnotation':
          case 'MixedTypeAnnotation':
          case 'EmptyTypeAnnotation':
          case 'NullableTypeAnnotation':
          case 'NumberLiteralTypeAnnotation':
          case 'NumberTypeAnnotation':
          case 'ObjectTypeAnnotation':
          case 'ObjectTypeInternalSlot':
          case 'ObjectTypeCallProperty':
          case 'ObjectTypeIndexer':
          case 'ObjectTypeProperty':
          case 'ObjectTypeSpreadProperty':
          case 'OpaqueType':
          case 'QualifiedTypeIdentifier':
          case 'StringLiteralTypeAnnotation':
          case 'StringTypeAnnotation':
          case 'SymbolTypeAnnotation':
          case 'ThisTypeAnnotation':
          case 'TupleTypeAnnotation':
          case 'TypeofTypeAnnotation':
          case 'TypeAlias':
          case 'TypeAnnotation':
          case 'TypeCastExpression':
          case 'TypeParameter':
          case 'TypeParameterDeclaration':
          case 'TypeParameterInstantiation':
          case 'UnionTypeAnnotation':
          case 'Variance':
          case 'VoidTypeAnnotation':
          case 'EnumDeclaration':
          case 'EnumBooleanBody':
          case 'EnumNumberBody':
          case 'EnumStringBody':
          case 'EnumSymbolBody':
          case 'EnumBooleanMember':
          case 'EnumNumberMember':
          case 'EnumStringMember':
          case 'EnumDefaultedMember':
          case 'IndexedAccessType':
          case 'OptionalIndexedAccessType':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isFlowType(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'AnyTypeAnnotation':
          case 'ArrayTypeAnnotation':
          case 'BooleanTypeAnnotation':
          case 'BooleanLiteralTypeAnnotation':
          case 'NullLiteralTypeAnnotation':
          case 'ExistsTypeAnnotation':
          case 'FunctionTypeAnnotation':
          case 'GenericTypeAnnotation':
          case 'InterfaceTypeAnnotation':
          case 'IntersectionTypeAnnotation':
          case 'MixedTypeAnnotation':
          case 'EmptyTypeAnnotation':
          case 'NullableTypeAnnotation':
          case 'NumberLiteralTypeAnnotation':
          case 'NumberTypeAnnotation':
          case 'ObjectTypeAnnotation':
          case 'StringLiteralTypeAnnotation':
          case 'StringTypeAnnotation':
          case 'SymbolTypeAnnotation':
          case 'ThisTypeAnnotation':
          case 'TupleTypeAnnotation':
          case 'TypeofTypeAnnotation':
          case 'UnionTypeAnnotation':
          case 'VoidTypeAnnotation':
          case 'IndexedAccessType':
          case 'OptionalIndexedAccessType':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isFlowBaseAnnotation(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'AnyTypeAnnotation':
          case 'BooleanTypeAnnotation':
          case 'NullLiteralTypeAnnotation':
          case 'MixedTypeAnnotation':
          case 'EmptyTypeAnnotation':
          case 'NumberTypeAnnotation':
          case 'StringTypeAnnotation':
          case 'SymbolTypeAnnotation':
          case 'ThisTypeAnnotation':
          case 'VoidTypeAnnotation':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isFlowDeclaration(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'DeclareClass':
          case 'DeclareFunction':
          case 'DeclareInterface':
          case 'DeclareModule':
          case 'DeclareModuleExports':
          case 'DeclareTypeAlias':
          case 'DeclareOpaqueType':
          case 'DeclareVariable':
          case 'DeclareExportDeclaration':
          case 'DeclareExportAllDeclaration':
          case 'InterfaceDeclaration':
          case 'OpaqueType':
          case 'TypeAlias':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isFlowPredicate(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'DeclaredPredicate':
          case 'InferredPredicate':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isEnumBody(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'EnumBooleanBody':
          case 'EnumNumberBody':
          case 'EnumStringBody':
          case 'EnumSymbolBody':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isEnumMember(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'EnumBooleanMember':
          case 'EnumNumberMember':
          case 'EnumStringMember':
          case 'EnumDefaultedMember':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isJSX(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'JSXAttribute':
          case 'JSXClosingElement':
          case 'JSXElement':
          case 'JSXEmptyExpression':
          case 'JSXExpressionContainer':
          case 'JSXSpreadChild':
          case 'JSXIdentifier':
          case 'JSXMemberExpression':
          case 'JSXNamespacedName':
          case 'JSXOpeningElement':
          case 'JSXSpreadAttribute':
          case 'JSXText':
          case 'JSXFragment':
          case 'JSXOpeningFragment':
          case 'JSXClosingFragment':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isMiscellaneous(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'Noop':
          case 'Placeholder':
          case 'V8IntrinsicIdentifier':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isTypeScript(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'TSParameterProperty':
          case 'TSDeclareFunction':
          case 'TSDeclareMethod':
          case 'TSQualifiedName':
          case 'TSCallSignatureDeclaration':
          case 'TSConstructSignatureDeclaration':
          case 'TSPropertySignature':
          case 'TSMethodSignature':
          case 'TSIndexSignature':
          case 'TSAnyKeyword':
          case 'TSBooleanKeyword':
          case 'TSBigIntKeyword':
          case 'TSIntrinsicKeyword':
          case 'TSNeverKeyword':
          case 'TSNullKeyword':
          case 'TSNumberKeyword':
          case 'TSObjectKeyword':
          case 'TSStringKeyword':
          case 'TSSymbolKeyword':
          case 'TSUndefinedKeyword':
          case 'TSUnknownKeyword':
          case 'TSVoidKeyword':
          case 'TSThisType':
          case 'TSFunctionType':
          case 'TSConstructorType':
          case 'TSTypeReference':
          case 'TSTypePredicate':
          case 'TSTypeQuery':
          case 'TSTypeLiteral':
          case 'TSArrayType':
          case 'TSTupleType':
          case 'TSOptionalType':
          case 'TSRestType':
          case 'TSNamedTupleMember':
          case 'TSUnionType':
          case 'TSIntersectionType':
          case 'TSConditionalType':
          case 'TSInferType':
          case 'TSParenthesizedType':
          case 'TSTypeOperator':
          case 'TSIndexedAccessType':
          case 'TSMappedType':
          case 'TSLiteralType':
          case 'TSExpressionWithTypeArguments':
          case 'TSInterfaceDeclaration':
          case 'TSInterfaceBody':
          case 'TSTypeAliasDeclaration':
          case 'TSInstantiationExpression':
          case 'TSAsExpression':
          case 'TSSatisfiesExpression':
          case 'TSTypeAssertion':
          case 'TSEnumDeclaration':
          case 'TSEnumMember':
          case 'TSModuleDeclaration':
          case 'TSModuleBlock':
          case 'TSImportType':
          case 'TSImportEqualsDeclaration':
          case 'TSExternalModuleReference':
          case 'TSNonNullExpression':
          case 'TSExportAssignment':
          case 'TSNamespaceExportDeclaration':
          case 'TSTypeAnnotation':
          case 'TSTypeParameterInstantiation':
          case 'TSTypeParameterDeclaration':
          case 'TSTypeParameter':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isTSTypeElement(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'TSCallSignatureDeclaration':
          case 'TSConstructSignatureDeclaration':
          case 'TSPropertySignature':
          case 'TSMethodSignature':
          case 'TSIndexSignature':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isTSType(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'TSAnyKeyword':
          case 'TSBooleanKeyword':
          case 'TSBigIntKeyword':
          case 'TSIntrinsicKeyword':
          case 'TSNeverKeyword':
          case 'TSNullKeyword':
          case 'TSNumberKeyword':
          case 'TSObjectKeyword':
          case 'TSStringKeyword':
          case 'TSSymbolKeyword':
          case 'TSUndefinedKeyword':
          case 'TSUnknownKeyword':
          case 'TSVoidKeyword':
          case 'TSThisType':
          case 'TSFunctionType':
          case 'TSConstructorType':
          case 'TSTypeReference':
          case 'TSTypePredicate':
          case 'TSTypeQuery':
          case 'TSTypeLiteral':
          case 'TSArrayType':
          case 'TSTupleType':
          case 'TSOptionalType':
          case 'TSRestType':
          case 'TSUnionType':
          case 'TSIntersectionType':
          case 'TSConditionalType':
          case 'TSInferType':
          case 'TSParenthesizedType':
          case 'TSTypeOperator':
          case 'TSIndexedAccessType':
          case 'TSMappedType':
          case 'TSLiteralType':
          case 'TSExpressionWithTypeArguments':
          case 'TSImportType':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isTSBaseType(e, t) {
        if (!e) return false;
        switch (e.type) {
          case 'TSAnyKeyword':
          case 'TSBooleanKeyword':
          case 'TSBigIntKeyword':
          case 'TSIntrinsicKeyword':
          case 'TSNeverKeyword':
          case 'TSNullKeyword':
          case 'TSNumberKeyword':
          case 'TSObjectKeyword':
          case 'TSStringKeyword':
          case 'TSSymbolKeyword':
          case 'TSUndefinedKeyword':
          case 'TSUnknownKeyword':
          case 'TSVoidKeyword':
          case 'TSThisType':
          case 'TSLiteralType':
            break;
          default:
            return false;
        }
        return t == null || (0, s.default)(e, t);
      }
      function isNumberLiteral(e, t) {
        (0, i.default)('isNumberLiteral', 'isNumericLiteral');
        if (!e) return false;
        if (e.type !== 'NumberLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isRegexLiteral(e, t) {
        (0, i.default)('isRegexLiteral', 'isRegExpLiteral');
        if (!e) return false;
        if (e.type !== 'RegexLiteral') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isRestProperty(e, t) {
        (0, i.default)('isRestProperty', 'isRestElement');
        if (!e) return false;
        if (e.type !== 'RestProperty') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isSpreadProperty(e, t) {
        (0, i.default)('isSpreadProperty', 'isSpreadElement');
        if (!e) return false;
        if (e.type !== 'SpreadProperty') return false;
        return t == null || (0, s.default)(e, t);
      }
      function isModuleDeclaration(e, t) {
        (0, i.default)('isModuleDeclaration', 'isImportOrExportDeclaration');
        return isImportOrExportDeclaration(e, t);
      }
    },
    3685: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = is;
      var s = r(79);
      var i = r(1009);
      var n = r(6937);
      var a = r(7405);
      function is(e, t, r) {
        if (!t) return false;
        const o = (0, i.default)(t.type, e);
        if (!o) {
          if (!r && t.type === 'Placeholder' && e in a.FLIPPED_ALIAS_KEYS) {
            return (0, n.default)(t.expectedNode, e);
          }
          return false;
        }
        if (typeof r === 'undefined') {
          return true;
        } else {
          return (0, s.default)(t, r);
        }
      }
    },
    8731: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isBinding;
      var s = r(6675);
      function isBinding(e, t, r) {
        if (
          r &&
          e.type === 'Identifier' &&
          t.type === 'ObjectProperty' &&
          r.type === 'ObjectExpression'
        ) {
          return false;
        }
        const i = s.default.keys[t.type];
        if (i) {
          for (let r = 0; r < i.length; r++) {
            const s = i[r];
            const n = t[s];
            if (Array.isArray(n)) {
              if (n.indexOf(e) >= 0) return true;
            } else {
              if (n === e) return true;
            }
          }
        }
        return false;
      }
    },
    2821: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isBlockScoped;
      var s = r(6428);
      var i = r(9552);
      function isBlockScoped(e) {
        return (
          (0, s.isFunctionDeclaration)(e) ||
          (0, s.isClassDeclaration)(e) ||
          (0, i.default)(e)
        );
      }
    },
    5456: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isImmutable;
      var s = r(1009);
      var i = r(6428);
      function isImmutable(e) {
        if ((0, s.default)(e.type, 'Immutable')) return true;
        if ((0, i.isIdentifier)(e)) {
          if (e.name === 'undefined') {
            return true;
          } else {
            return false;
          }
        }
        return false;
      }
    },
    9552: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isLet;
      var s = r(6428);
      var i = r(1227);
      function isLet(e) {
        return (
          (0, s.isVariableDeclaration)(e) &&
          (e.kind !== 'var' || e[i.BLOCK_SCOPED_SYMBOL])
        );
      }
    },
    6516: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isNode;
      var s = r(7405);
      function isNode(e) {
        return !!(e && s.VISITOR_KEYS[e.type]);
      }
    },
    1840: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isNodesEquivalent;
      var s = r(7405);
      function isNodesEquivalent(e, t) {
        if (
          typeof e !== 'object' ||
          typeof t !== 'object' ||
          e == null ||
          t == null
        ) {
          return e === t;
        }
        if (e.type !== t.type) {
          return false;
        }
        const r = Object.keys(s.NODE_FIELDS[e.type] || e.type);
        const i = s.VISITOR_KEYS[e.type];
        for (const s of r) {
          const r = e[s];
          const n = t[s];
          if (typeof r !== typeof n) {
            return false;
          }
          if (r == null && n == null) {
            continue;
          } else if (r == null || n == null) {
            return false;
          }
          if (Array.isArray(r)) {
            if (!Array.isArray(n)) {
              return false;
            }
            if (r.length !== n.length) {
              return false;
            }
            for (let e = 0; e < r.length; e++) {
              if (!isNodesEquivalent(r[e], n[e])) {
                return false;
              }
            }
            continue;
          }
          if (typeof r === 'object' && !(i != null && i.includes(s))) {
            for (const e of Object.keys(r)) {
              if (r[e] !== n[e]) {
                return false;
              }
            }
            continue;
          }
          if (!isNodesEquivalent(r, n)) {
            return false;
          }
        }
        return true;
      }
    },
    6937: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isPlaceholderType;
      var s = r(7405);
      function isPlaceholderType(e, t) {
        if (e === t) return true;
        const r = s.PLACEHOLDERS_ALIAS[e];
        if (r) {
          for (const e of r) {
            if (t === e) return true;
          }
        }
        return false;
      }
    },
    7391: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isReferenced;
      function isReferenced(e, t, r) {
        switch (t.type) {
          case 'MemberExpression':
          case 'OptionalMemberExpression':
            if (t.property === e) {
              return !!t.computed;
            }
            return t.object === e;
          case 'JSXMemberExpression':
            return t.object === e;
          case 'VariableDeclarator':
            return t.init === e;
          case 'ArrowFunctionExpression':
            return t.body === e;
          case 'PrivateName':
            return false;
          case 'ClassMethod':
          case 'ClassPrivateMethod':
          case 'ObjectMethod':
            if (t.key === e) {
              return !!t.computed;
            }
            return false;
          case 'ObjectProperty':
            if (t.key === e) {
              return !!t.computed;
            }
            return !r || r.type !== 'ObjectPattern';
          case 'ClassProperty':
          case 'ClassAccessorProperty':
            if (t.key === e) {
              return !!t.computed;
            }
            return true;
          case 'ClassPrivateProperty':
            return t.key !== e;
          case 'ClassDeclaration':
          case 'ClassExpression':
            return t.superClass === e;
          case 'AssignmentExpression':
            return t.right === e;
          case 'AssignmentPattern':
            return t.right === e;
          case 'LabeledStatement':
            return false;
          case 'CatchClause':
            return false;
          case 'RestElement':
            return false;
          case 'BreakStatement':
          case 'ContinueStatement':
            return false;
          case 'FunctionDeclaration':
          case 'FunctionExpression':
            return false;
          case 'ExportNamespaceSpecifier':
          case 'ExportDefaultSpecifier':
            return false;
          case 'ExportSpecifier':
            if (r != null && r.source) {
              return false;
            }
            return t.local === e;
          case 'ImportDefaultSpecifier':
          case 'ImportNamespaceSpecifier':
          case 'ImportSpecifier':
            return false;
          case 'ImportAttribute':
            return false;
          case 'JSXAttribute':
            return false;
          case 'ObjectPattern':
          case 'ArrayPattern':
            return false;
          case 'MetaProperty':
            return false;
          case 'ObjectTypeProperty':
            return t.key !== e;
          case 'TSEnumMember':
            return t.id !== e;
          case 'TSPropertySignature':
            if (t.key === e) {
              return !!t.computed;
            }
            return true;
        }
        return true;
      }
    },
    7910: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isScope;
      var s = r(6428);
      function isScope(e, t) {
        if (
          (0, s.isBlockStatement)(e) &&
          ((0, s.isFunction)(t) || (0, s.isCatchClause)(t))
        ) {
          return false;
        }
        if (
          (0, s.isPattern)(e) &&
          ((0, s.isFunction)(t) || (0, s.isCatchClause)(t))
        ) {
          return true;
        }
        return (0, s.isScopable)(e);
      }
    },
    9003: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isSpecifierDefault;
      var s = r(6428);
      function isSpecifierDefault(e) {
        return (
          (0, s.isImportDefaultSpecifier)(e) ||
          (0, s.isIdentifier)(e.imported || e.exported, { name: 'default' })
        );
      }
    },
    1009: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isType;
      var s = r(7405);
      function isType(e, t) {
        if (e === t) return true;
        if (e == null) return false;
        if (s.ALIAS_KEYS[t]) return false;
        const r = s.FLIPPED_ALIAS_KEYS[t];
        if (r) {
          if (r[0] === e) return true;
          for (const t of r) {
            if (e === t) return true;
          }
        }
        return false;
      }
    },
    5563: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isValidES3Identifier;
      var s = r(9994);
      const i = new Set([
        'abstract',
        'boolean',
        'byte',
        'char',
        'double',
        'enum',
        'final',
        'float',
        'goto',
        'implements',
        'int',
        'interface',
        'long',
        'native',
        'package',
        'private',
        'protected',
        'public',
        'short',
        'static',
        'synchronized',
        'throws',
        'transient',
        'volatile',
      ]);
      function isValidES3Identifier(e) {
        return (0, s.default)(e) && !i.has(e);
      }
    },
    9994: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isValidIdentifier;
      var s = r(3442);
      function isValidIdentifier(e, t = true) {
        if (typeof e !== 'string') return false;
        if (t) {
          if ((0, s.isKeyword)(e) || (0, s.isStrictReservedWord)(e, true)) {
            return false;
          }
        }
        return (0, s.isIdentifierName)(e);
      }
    },
    7407: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isVar;
      var s = r(6428);
      var i = r(1227);
      function isVar(e) {
        return (
          (0, s.isVariableDeclaration)(e, { kind: 'var' }) &&
          !e[i.BLOCK_SCOPED_SYMBOL]
        );
      }
    },
    3794: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = matchesPattern;
      var s = r(6428);
      function matchesPattern(e, t, r) {
        if (!(0, s.isMemberExpression)(e)) return false;
        const i = Array.isArray(t) ? t : t.split('.');
        const n = [];
        let a;
        for (a = e; (0, s.isMemberExpression)(a); a = a.object) {
          n.push(a.property);
        }
        n.push(a);
        if (n.length < i.length) return false;
        if (!r && n.length > i.length) return false;
        for (let e = 0, t = n.length - 1; e < i.length; e++, t--) {
          const r = n[t];
          let a;
          if ((0, s.isIdentifier)(r)) {
            a = r.name;
          } else if ((0, s.isStringLiteral)(r)) {
            a = r.value;
          } else if ((0, s.isThisExpression)(r)) {
            a = 'this';
          } else {
            return false;
          }
          if (i[e] !== a) return false;
        }
        return true;
      }
    },
    9482: function (e, t) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = isCompatTag;
      function isCompatTag(e) {
        return !!e && /^[a-z]/.test(e);
      }
    },
    835: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = void 0;
      var s = r(5659);
      const i = (0, s.default)('React.Component');
      var n = (t['default'] = i);
    },
    7159: function (e, t, r) {
      'use strict';
      Object.defineProperty(t, '__esModule', { value: true });
      t['default'] = validate;
      t.validateChild = validateChild;
      t.validateField = validateField;
      var s = r(7405);
      function validate(e, t, r) {
        if (!e) return;
        const i = s.NODE_FIELDS[e.type];
        if (!i) return;
        const n = i[t];
        validateField(e, t, r, n);
        validateChild(e, t, r);
      }
      function validateField(e, t, r, s) {
        if (!(s != null && s.validate)) return;
        if (s.optional && r == null) return;
        s.validate(e, t, r);
      }
      function validateChild(e, t, r) {
        if (r == null) return;
        const i = s.NODE_PARENT_VALIDATIONS[r.type];
        if (!i) return;
        i(e, t, r);
      }
    },
    5633: function (e) {
      'use strict';
      e.exports = JSON.parse(
        '["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","label","legend","li","link","main","map","mark","math","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rb","rp","rt","rtc","ruby","s","samp","script","search","section","select","slot","small","source","span","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr"]',
      );
    },
    7188: function (e) {
      'use strict';
      e.exports = JSON.parse(
        '["a","altGlyph","altGlyphDef","altGlyphItem","animate","animateColor","animateMotion","animateTransform","circle","clipPath","color-profile","cursor","defs","desc","ellipse","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","filter","font","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignObject","g","glyph","glyphRef","hkern","image","line","linearGradient","marker","mask","metadata","missing-glyph","mpath","path","pattern","polygon","polyline","radialGradient","rect","script","set","stop","style","svg","switch","symbol","text","textPath","title","tref","tspan","use","view","vkern"]',
      );
    },
  };
  var t = {};
  function __nccwpck_require__(r) {
    var s = t[r];
    if (s !== undefined) {
      return s.exports;
    }
    var i = (t[r] = { id: r, loaded: false, exports: {} });
    var n = true;
    try {
      e[r](i, i.exports, __nccwpck_require__);
      n = false;
    } finally {
      if (n) delete t[r];
    }
    i.loaded = true;
    return i.exports;
  }
  !(function () {
    __nccwpck_require__.nmd = function (e) {
      e.paths = [];
      if (!e.children) e.children = [];
      return e;
    };
  })();
  if (typeof __nccwpck_require__ !== 'undefined')
    __nccwpck_require__.ab = __dirname + '/';
  var r = __nccwpck_require__(831);
  module.exports = r;
})();
